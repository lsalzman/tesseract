<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<title>Cube 2: Sauerbraten - Editing Reference</title>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="shortcut icon" href="favicon.ico" />
</head>

<body>
<h1>Cube 2: Sauerbraten - Editing Reference</h1>

<div class="contents">
<ul class="contents">
<li>
<a href="#preface"><b>Preface</b></a>
</li>
<li>
<a href="#editing"><b>Editing</b></a>
<ul class="contents2">
<li>
<a href="#edittoggle"><tt>edittoggle</tt></a>
</li>
<li>
<a href="#dragging"><tt>dragging</tt></a>
</li>
<li>
<a href="#editdrag"><tt>editdrag</tt></a>
</li>
<li>
<a href="#selcorners"><tt>selcorners</tt></a>
</li>
<li>
<a href="#moving"><tt>moving</tt></a>
</li>
<li>
<a href="#editmovedrag"><tt>editmovedrag</tt></a>
</li>
<li>
<a href="#cancelsel"><tt>cancelsel</tt></a>
</li>
<li>
<a href="#editface"><tt>editface</tt></a>
</li>
<li>
<a href="#gridpower"><tt>gridpower</tt></a>
</li>
<li>
<a href="#edittex"><tt>edittex</tt></a>
</li>
<li>
<a href="#gettex"><tt>gettex</tt></a>
</li>
<li>
<a href="#selextend"><tt>selextend</tt></a>
</li>
<li>
<a href="#passthrough"><tt>passthrough</tt></a>
</li>
<li>
<a href="#reorient"><tt>reorient</tt></a>
</li>
<li>
<a href="#flip"><tt>flip</tt></a>
</li>
<li>
<a href="#rotate"><tt>rotate</tt></a>
</li>
<li>
<a href="#undo"><tt>undo</tt></a>
</li>
<li>
<a href="#redo"><tt>redo</tt></a>
</li>
<li>
<a href="#copy"><tt>copy</tt></a>
</li>
<li>
<a href="#paste"><tt>paste</tt></a>
</li>
<li>
<a href="#editcopy"><tt>editcopy</tt></a>
</li>
<li>
<a href="#editpaste"><tt>editpaste</tt></a>
</li>
<li>
<a href="#replace"><tt>replace</tt></a>
</li>
<li>
<a href="#replacesel"><tt>replacesel</tt></a>
</li>
<li>
<a href="#editmat"><tt>editmat</tt></a>
</li>
<li>
<a href="#recalc"><tt>recalc</tt></a>
</li>
<li>
<a href="#havesel"><tt>havesel</tt></a>
</li>
<li>
<a href="#gotosel"><tt>gotosel</tt></a>
</li>
</ul>
</li>
<li>
<a href="#heightfield"><b>Heightfield</b></a>
<ul class="contents2">
<li>
<a href="#hmapedit"><tt>hmapedit</tt></a>
</li>
<li>
<a href="#hmapselect"><tt>hmapselect</tt></a>
</li>
<li>
<a href="#hmapcancel"><tt>hmapcancel</tt></a>
</li>
<li>
<a href="#selectbrush"><tt>selectbrush</tt></a>
</li>
<li>
<a href="#clearbrush"><tt>clearbrush</tt></a>
</li>
<li>
<a href="#brushvert"><tt>brushvert</tt></a>
</li>
<li>
<a href="#brushx"><tt>brushx</tt></a>
</li>
<li>
<a href="#brushy"><tt>brushy</tt></a>
</li>
</ul>
</li>
<li>
<a href="#entity"><b>Entity</b></a>
<ul class="contents2">
<li>
<a href="#newent"><tt>newent</tt></a>
</li>
<li>
<a href="#delent"><tt>delent</tt></a>
</li>
<li>
<a href="#entflip"><tt>entflip</tt></a>
</li>
<li>
<a href="#entpush"><tt>entpush</tt></a>
</li>
<li>
<a href="#entrotate"><tt>entrotate</tt></a>
</li>
<li>
<a href="#entmoving"><tt>entmoving</tt></a>
</li>
<li>
<a href="#entdrop"><tt>entdrop</tt></a>
</li>
<li>
<a href="#dropent"><tt>dropent</tt></a>
</li>
<li>
<a href="#trigger"><tt>trigger</tt></a>
</li>
<li>
<a href="#platform"><tt>platform</tt></a>
</li>
<li>
<a href="#entselect"><tt>entselect</tt></a>
</li>
<li>
<a href="#entloop"><tt>entloop</tt></a>
</li>
<li>
<a href="#entcancel"><tt>entcancel</tt></a>
</li>
<li>
<a href="#enthavesel"><tt>enthavesel</tt></a>
</li>
<li>
<a href="#entget"><tt>entget</tt></a>
</li>
<li>
<a href="#insel"><tt>insel</tt></a>
</li>
<li>
<a href="#et"><tt>et</tt></a>
</li>
<li>
<a href="#ea"><tt>ea</tt></a>
</li>
<li>
<a href="#entset"><tt>entset</tt></a>
</li>
<li>
<a href="#entproperty"><tt>entproperty</tt></a>
</li>
<li>
<a href="#entfind"><tt>entfind</tt></a>
</li>
<li>
<a href="#clearents"><tt>clearents</tt></a>
</li>
<li>
<a href="#replaceents"><tt>replaceents</tt></a>
</li>
<li>
<a href="#entautoview"><tt>entautoview</tt></a>
</li>
</ul>
</li>
<li>
<a href="#settings"><b>Settings</b></a>
<ul class="contents2">
<li>
<a href="#undomegs"><tt>undomegs</tt></a>
</li>
<li>
<a href="#showsky"><tt>showsky</tt></a>
</li>
<li>
<a href="#outline"><tt>outline</tt></a>
</li>
<li>
<a href="#wireframe"><tt>wireframe</tt></a>
</li>
<li>
<a href="#allfaces"><tt>allfaces</tt></a>
</li>
<li>
<a href="#showmat"><tt>showmat</tt></a>
</li>
<li>
<a href="#optmats"><tt>optmats</tt></a>
</li>
<li>
<a href="#entselradius"><tt>entselradius</tt></a>
</li>
<li>
<a href="#entselsnap"><tt>entselsnap</tt></a>
</li>
<li>
<a href="#entitysurf"><tt>entitysurf</tt></a>
</li>
<li>
<a href="#selectionsurf"><tt>selectionsurf</tt></a>
</li>
</ul>
</li>
<li>
<a href="#map_and_config"><b>Map and Config</b></a>
<ul class="contents2">
<li>
<a href="#map"><tt>map</tt></a>
</li>
<li>
<a href="#sendmap"><tt>sendmap</tt></a>
</li>
<li>
<a href="#getmap"><tt>getmap</tt></a>
</li>
<li>
<a href="#savemap"><tt>savemap</tt></a>
</li>
<li>
<a href="#savecurrentmap"><tt>savecurrentmap</tt></a>
</li>
<li>
<a href="#newmap"><tt>newmap</tt></a>
</li>
<li>
<a href="#mapenlarge"><tt>mapenlarge</tt></a>
</li>
<li>
<a href="#maptitle"><tt>maptitle</tt></a>
</li>
<li>
<a href="#loadsky"><tt>loadsky</tt></a>
</li>
<li>
<a href="#texturereset"><tt>texturereset</tt></a>
</li>
<li>
<a href="#materialreset"><tt>materialreset</tt></a>
</li>
<li>
<a href="#texture"><tt>texture</tt></a>
</li>
<li>
<a href="#autograss"><tt>autograss</tt></a>
</li>
<li>
<a href="#grassscale"><tt>grassscale</tt></a>
</li>
<li>
<a href="#grasscolour"><tt>grasscolour</tt></a>
</li>
<li>
<a href="#grassalpha"><tt>grassalpha</tt></a>
</li>
<li>
<a href="#texscroll"><tt>texscroll</tt></a>
</li>
<li>
<a href="#texrotate"><tt>texrotate</tt></a>
</li>
<li>
<a href="#vrotate"><tt>vrotate</tt></a>
</li>
<li>
<a href="#texoffset"><tt>texoffset</tt></a>
</li>
<li>
<a href="#voffset"><tt>voffset</tt></a>
</li>
<li>
<a href="#texscale"><tt>texscale</tt></a>
</li>
<li>
<a href="#vscale"><tt>vscale</tt></a>
</li>
<li>
<a href="#texalpha"><tt>texalpha</tt></a>
</li>
<li>
<a href="#valpha"><tt>valpha</tt></a>
</li>
<a href="#texcolor"><tt>texcolor</tt></a>
</li>
<li>
<a href="#vcolor"><tt>vcolor</tt></a>
</li>
<li>
<a href="#vreset"><tt>vreset</tt></a>
</li>
<li>
<a href="#vdelta"><tt>vdelta</tt></a>
</li>
<li>
<a href="#fog"><tt>fog</tt></a>
</li>
<li>
<a href="#fogcolour"><tt>fogcolour</tt></a>
</li>
<li>
<a href="#waterspec"><tt>waterspec</tt></a>
</li>
<li>
<a href="#waterfog"><tt>waterfog</tt></a>
</li>
<li>
<a href="#watercolour"><tt>watercolour</tt></a>
</li>
<li>
<a href="#waterfallcolour"><tt>waterfallcolour</tt></a>
</li>
<li>
<a href="#lavafog"><tt>lavafog</tt></a>
</li>
<li>
<a href="#lavacolour"><tt>lavacolour</tt></a>
</li>
<li>
<a href="#shader"><tt>shader</tt></a>
</li>
<li>
<a href="#fastshader"><tt>fastshader</tt></a>
</li>
<li>
<a href="#setshader"><tt>setshader</tt></a>
</li>
<li>
<a href="#setshaderparam"><tt>setshaderparam</tt></a>
</li>
<li>
<a href="#vshaderparam"><tt>vshaderparam</tt></a>
</li>
<li>
<a href="#setpixelparam"><tt>setpixelparam</tt></a>
</li>
<li>
<a href="#setvertexparam"><tt>setvertexparam</tt></a>
</li>
<li>
<a href="#setuniformparam"><tt>setuniformparam</tt></a>
</li>
<li>
<a href="#music"><tt>music</tt></a>
</li>
<li>
<a href="#n"><tt>N</tt></a>
</li>
<li>
<a href="#sound"><tt>sound</tt></a>
</li>
<li>
<a href="#mapsound"><tt>mapsound</tt></a>
</li>
<li>
<a href="#mapmodel"><tt>mapmodel</tt></a>
</li>
<li>
<a href="#mmodel"><tt>mmodel</tt></a>
</li>
<li>
<a href="#shadowmapambient"><tt>shadowmapambient</tt></a>
</li>
<li>
<a href="#shadowmapangle"><tt>shadowmapangle</tt></a>
</li>
<li>
<a href="#causticscale"><tt>causticscale</tt></a>
</li>
<li>
<a href="#causticmillis"><tt>causticmillis</tt></a>
</li>
<li>
<a href="#skybox"><tt>skybox</tt></a>
</li>
<li>
<a href="#spinsky"><tt>spinsky</tt></a>
</li>
<li>
<a href="#yawsky"><tt>yawsky</tt></a>
</li>
<li>
<a href="#cloudbox"><tt>cloudbox</tt></a>
</li>
<li>
<a href="#spinclouds"><tt>spinclouds</tt></a>
</li>
<li>
<a href="#yawclouds"><tt>yawclouds</tt></a>
</li>
<li>
<a href="#cloudclip"><tt>cloudclip</tt></a>
</li>
<li>
<a href="#cloudlayer"><tt>cloudlayer</tt></a>
</li>
<li>
<a href="#cloudscrollx"><tt>cloudscrollx</tt></a>
</li>
<li>
<a href="#cloudscrolly"><tt>cloudscrolly</tt></a>
</li>
<li>
<a href="#cloudscale"><tt>cloudscale</tt></a>
</li>
<li>
<a href="#cloudheight"><tt>cloudheight</tt></a>
</li>
<li>
<a href="#cloudfade"><tt>cloudfade</tt></a>
</li>
<li>
<a href="#cloudcolour"><tt>cloudcolour</tt></a>
</li>
<li>
<a href="#cloudalpha"><tt>cloudalpha</tt></a>
</li>
<li>
<a href="#fogdomeheight"><tt>fogdomeheight</tt></a>
</li>
<li>
<a href="#fogdomemin"><tt>fogdomemin</tt></a>
</li>
<li>
<a href="#fogdomemax"><tt>fogdomemax</tt></a>
</li>
<li>
<a href="#fogdomecap"><tt>fogdomecap</tt></a>
</li>
<li>
<a href="#fogdomeclip"><tt>fogdomeclip</tt></a>
</li>
<li>
<a href="#fogdomecolour"><tt>fogdomecolour</tt></a>
</li>
<li>
<a href="#skytexture"><tt>skytexture</tt></a>
</li>
<li>
<a href="#importcube"><tt>importcube</tt></a>
</li>
<li>
<a href="#writeobj"><tt>writeobj</tt></a>
</li>
</ul>
</li>
<li>
<a href="#lighting"><b>Lighting</b></a>
<ul class="contents2">
<li>
<a href="#ambient"><tt>ambient</tt></a>
</li>
<li>
<a href="#edgetolerance"><tt>edgetolerance</tt></a>
</li>
<li>
<a href="#sunlight"><tt>sunlight</tt></a>
</li>
<li>
<a href="#sunlightyaw"><tt>sunlightyaw</tt></a>
</li>
<li>
<a href="#sunlightpitch"><tt>sunlightpitch</tt></a>
</li>
<li>
<a href="#sunlightscale"><tt>sunlightscale</tt></a>
</li>
<li>
<a href="#skylight"><tt>skylight</tt></a>
</li>
<li>
<a href="#lmshadows"><tt>lmshadows</tt></a>
</li>
<li>
<a href="#lmaa"><tt>lmaa</tt></a>
</li>
<li>
<a href="#calclight"><tt>calclight</tt></a>
</li>
<li>
<a href="#patchlight"><tt>patchlight</tt></a>
</li>
<li>
<a href="#lightthreads"><tt>lightthreads</tt></a>
</li>
<li>
<a href="#fullbright"><tt>fullbright</tt></a>
</li>
<li>
<a href="#lerpangle"><tt>lerpangle</tt></a>
</li>
<li>
<a href="#lerpsubdiv"><tt>lerpsubdiv</tt></a>
</li>
<li>
<a href="#lerpsubdivsize"><tt>lerpsubdivsize</tt></a>
</li>
<li>
<a href="#lightprecision"><tt>lightprecision</tt></a>
</li>
<li>
<a href="#lighterror"><tt>lighterror</tt></a>
</li>
<li>
<a href="#lightlod"><tt>lightlod</tt></a>
</li>
<li>
<a href="#blurlms"><tt>blurlms</tt></a>
</li>
<li>
<a href="#blurskylight"><tt>blurskylight</tt></a>
</li>
<li>
<a href="#dumplms"><tt>dumplms</tt></a>
</li>
</ul>
</li>
<li>
<a href="#texture_blending"><b>Texture Blending</b></a>
<ul class="contents2">
<li>
<a href="#defining_blended_textures">Defining Blended Textures</a>
</li>
<li>
<a href="#texlayer"><tt>texlayer</tt></a>
</li>
<li>
<a href="#vlayer"><tt>vlayer</tt></a>
</li>
<li>
<a href="#blend_brushes">Blend Brushes</a>
</li>
<li>
<a href="#addblendbrush"><tt>addblendbrush</tt></a>
</li>
<li>
<a href="#setblendbrush"><tt>setblendbrush</tt></a>
</li>
<li>
<a href="#nextblendbrush"><tt>nextblendbrush</tt></a>
</li>
<li>
<a href="#rotateblendbrush"><tt>rotateblendbrush</tt></a>
</li>
<li>
<a href="#painting">Painting</a>
</li>
<li>
<a href="#blendpaintmode"><tt>blendpaintmode</tt></a>
</li>
<li>
<a href="#paintblendmap"><tt>paintblendmap</tt></a>
</li>
<li>
<a href="#showblendmap"><tt>showblendmap</tt></a>
</li>
<li>
<a href="#reverting_paints">Reverting Paints</a>
</li>
<li>
<a href="#clearblendmap"><tt>clearblendmap</tt></a>
</li>
<li>
<a href="#clearblendmapsel"><tt>clearblendmapsel</tt></a>
</li>
<li>
<a href="#blending_hints_and_tips">Blending Hints and Tips</a>
</li>
</ul>
</li>
<li>
<a href="#entity_types"><b>Entity Types</b></a>
<ul class="contents2">
<li>
<a href="#_light_"><tt>"light"</tt></a>
</li>
<li>
<a href="#_spotlight_"><tt>"spotlight"</tt></a>
</li>
<li>
<a href="#_envmap_"><tt>"envmap"</tt></a>
</li>
<li>
<a href="#_sound_"><tt>"sound"</tt></a>
</li>
<li>
<a href="#_playerstart_"><tt>"playerstart"</tt></a>
</li>
<li>
<a href="#_flag_"><tt>"flag"</tt></a>
</li>
<li>
<a href="#_base_"><tt>"base"</tt></a>
</li>
<li>
<a href="#_shells_"><tt>"shells"</tt></a>
</li>
<li>
<a href="#_bullets_"><tt>"bullets"</tt></a>
</li>
<li>
<a href="#_rockets_"><tt>"rockets"</tt></a>
</li>
<li>
<a href="#_riflerounds_"><tt>"riflerounds"</tt></a>
</li>
<li>
<a href="#_grenades_"><tt>"grenades"</tt></a>
</li>
<li>
<a href="#_cartridges_"><tt>"cartridges"</tt></a>
</li>
<li>
<a href="#_health_"><tt>"health"</tt></a>
</li>
<li>
<a href="#_healthboost_"><tt>"healthboost"</tt></a>
</li>
<li>
<a href="#_greenarmour_"><tt>"greenarmour"</tt></a>
</li>
<li>
<a href="#_yellowarmour_"><tt>"yellowarmour"</tt></a>
</li>
<li>
<a href="#_quaddamage_"><tt>"quaddamage"</tt></a>
</li>
<li>
<a href="#_teleport_"><tt>"teleport"</tt></a>
</li>
<li>
<a href="#_teledest_"><tt>"teledest"</tt></a>
</li>
<li>
<a href="#_jumppad_"><tt>"jumppad"</tt></a>
</li>
<li>
<a href="#_mapmodel_"><tt>"mapmodel"</tt></a>
</li>
<li>
<a href="#_box_"><tt>"box"</tt></a>
</li>
<li>
<a href="#_barrel_"><tt>"barrel"</tt></a>
</li>
<li>
<a href="#_platform_"><tt>"platform"</tt></a>
</li>
<li>
<a href="#_elevator_"><tt>"elevator"</tt></a>
</li>
<li>
<a href="#_monster_"><tt>"monster"</tt></a>
</li>
<li>
<a href="#_respawnpoint_"><tt>"respawnpoint"</tt></a>
</li>
<li>
<a href="#_particles_"><tt>"particles"</tt></a>
</li>
</ul>
</li>

<li>
<a href="#pvs_culling"><b>PVS Culling</b></a>
<ul class="contents2">
<li>
<a href="#pvs"><tt>pvs</tt></a>
</li>
<li>
<a href="#pvsthreads"><tt>pvsthreads</tt></a>
</li>
<li>
<a href="#genpvs"><tt>genpvs</tt></a>
</li>
<li>
<a href="#clearpvs"><tt>clearpvs</tt></a>
</li>
<li>
<a href="#lockpvs"><tt>lockpvs</tt></a>
</li>
<li>
<a href="#testpvs"><tt>testpvs</tt></a>
</li>
<li>
<a href="#pvsstats"><tt>pvsstats</tt></a>
</li>
</ul>
</li>

<li>
<a href="#waypoints"><b>Waypoints</b></a>
<ul class="contents2">
<li>
<a href="#showwaypoints"><tt>showwaypoints</tt></a>
</li>
<li>
<a href="#dropwaypoints"><tt>dropwaypoints</tt></a>
</li>
<li>
<a href="#loadwaypoints"><tt>loadwaypoints</tt></a>
</li>
<li>
<a href="#savewaypoints"><tt>savewaypoints</tt></a>
</li>
<li>
<a href="#clearwaypoints"><tt>clearwaypoints</tt></a>
</li>
<li>
<a href="#delselwaypoints"><tt>delselwaypoints</tt></a>
</li>
</ul>
</li>

<li>
<a href="#the_hud"><b>The HUD</b></a>
<ul class="contents2">
<li>
<a href="#hidestats"><tt>hidestats</tt></a>
</li>
<li>
<a href="#hidehud"><tt>hidehud</tt></a>
</li>
</ul>
</li>
</ul>
</div>

<h2 id="preface">Preface</h2>
<p>
<b>IMPORTANT NOTE:</b> When dealing with array attributes (getting a piece of information from a set of values)
it is important to know that most start at zero (0) and count upwards from there. This means that the first
value is 0, the second is 1, the third is 2 and so forth. Please keep this in mind, especially when dealing
with entity attributes, as zero is always considered to be the first/default value, not 1.
</p>

<h2 id="editing">Editing</h2>

<pre id="edittoggle">edittoggle</pre>
<p>
Switches between map edit mode and normal (default key: e). In map edit mode
you can select bits of the map by clicking or dragging your crosshair on the
cubes (using the "attack" command, normally MOUSE1), then use the commands
below to modify the selection. While in edit mode, physics &amp; collision
don't apply (noclip), and key repeat is ON.
</p>

<pre id="dragging">dragging 0/1</pre>
<p>
Select cubes when set to 1. stop selection when set to 0
</p>

<pre id="editdrag">editdrag</pre>
<p>
Select cubes and entities. (default: left mouse button)
</p>

<pre id="selcorners">selcorners</pre>
<p>
Select the corners of cubes. (default: middle mouse button)
</p>

<pre id="moving">moving 0/1</pre>
<p>
set to 1 to turn on. when on, it will move the selection (cubes not included) to another position. 
the plane on which it will move on is dependent on which side of the selection your cursor was on when 
turned on. set to 0 to turn off moving. if cursor is not on selection when turned on, moving
will automatically be turned off.
</p>

<pre id="editmovedrag">editmovedrag</pre>
<p>
if cursor is in current cube selection, holding will move selection. otherwise will create new selection.
</p>

<pre id="cancelsel">cancelsel</pre>
<p>
Cancels out any explicit selection you currently have (default: space).
</p>

<pre id="editface">editface D N</pre>
<p>
This is the main editing command. D is the direction of the action, -1 for
towards you, 1 for away from you (default: scroll wheel). N=0 to push all corners in the white box (hold F). N=1
create or destroy cubes (default). N=2 push or pull a corner you are pointing at (hold Q).       
</p>

<pre id="gridpower">gridpower N</pre>
<p>
Changes the size of the grid. (default: g + scrollwheel)
</p>

<pre id="edittex">edittex D</pre>
<p>
Changes the texture on current selection by browsing through a list of textures
directly shown on the cubes. D is the direction you want to cycle the textures
in (1 = forwards, -1 = backwards) (default: y + scrollwheel).
The way this works is slightly strange at first, but allows for very fast
texture assignment. All textures are in a list. and each time a texture is
used, it is moved to the top of the list. So after a bit of editing, all your
most frequently used textures will come first, and the most recently used
texture is set immediately when you press the forward key for the type. These
lists are saved with the map.
</p>

<pre id="gettex">gettex</pre>
<p>
moves the texture on the current selection to the top of the texture list. Useful for quickly
texturing things using already textured geometry.
</p>

<pre id="selextend">selextend</pre>
<p>
Extend current selection to include the cursor.
</p>

<pre id="passthrough">passthrough</pre>
<p>
normally cubes of equal size to the grid are given priority when selecting.
passthrough removes this priority while held down so that the cube the cursor is directly on is selected.   
Holding down passthrough will also give priority to cube over entities. (default: alt)
</p>

<pre id="reorient">reorient</pre>
<p>
Change the side the white box is on to be the same as where you are currently
pointing. (default: shift)
</p>

<pre id="flip">flip</pre>
<p>
Flip (mirror) the selected cubes front to back relative to the side of the
white box. (default: x)
</p>

<pre id="rotate">rotate D</pre>
<p>
Rotates the selection 90 degrees around the side of the white box.
Automatically squares the selection if it isn't already.
(default: r + scroll wheel)
</p>

<pre id="undo">undo</pre>
<p>
Multi-level undo of any of the changes caused by the above operations (default: z [or u]).
</p>

<pre id="redo">redo</pre>
<p>
Multi-level redo of any of the changes caused by the above undo (default: i).      
</p>

<pre id="copy">copy</pre>
<pre id="paste">paste</pre>
<p>
Copy copies the current selection into a buffer. Upon pressing 'paste', a 
selection box will be created to identify the location of the pasted cubes. 
Releasing the 'paste' button will actually paste the cubes. So combined with
the 'moving' command you can easily place and clone sets of cubes.
If the current gridsize is changed from the copy,
the pasted copy will be stretched by the same factor.
</p>

<pre id="editcopy">editcopy</pre>
<pre id="editpaste">editpaste</pre>
<p>
Will copy cubes as normal copy, but also features entity copies. There are three 
different methods of use:
</p>

<ul class="list-style-type: decimal">
<li>If no entity is explicitly selected, editcopy will copy the selected cube, 
just like normal the normal 'copy' command.</li>
<li>If one or more entities are selected, editcopy will copy the last entity selected. 
Editpaste will create a new entity using copy as the template if no entities are selected, 
otherwise it will overwrite all selected entities with the copied ent.</li>
<li>If there are both entity and cube selections, editcopy will copy the entire selection.
In other words, when editpaste is used it will paste the cube selection along with all of the
entities that were selected.</li>
</ul>

<pre id="replace">replace</pre>
<p>
Repeats the last texture edit across the whole map. Only those faces with
textures matching the one that was last edited will be
replaced.        
</p>

<pre id="replacesel">replacesel</pre>
<p>
Repeats the last texture edit only within the currently selected region. Only those faces with
textures matching the one that was last edited will be
replaced.
</p>

<pre id="editmat">editmat MAT [FILTER]</pre>
<p>
Changes the type of material left behind when a cube is deleted to MAT. If FILTER is specified, then only cubes with that material named by FILTER are changed to MAT. MAT may also be "", indicating that only those parts of the material mask matching FILTER will be cleared, as opposed to setting MAT to "air", which would clear the entire material mask.
</p>

<p>
Currently the following types of materials are supported:
</p>

<ul>
<li>
air: the default material, has no effect. Overwrites other volume materials.
</li>
<li>
water: acts as you would expect. Renders the top as a reflection/refraction and the
sides as a waterfall if it isn't contained. Should be placed with a floor at the bottom
to contain it. Shows blue volume in edit mode. Overwrites other volume materials.
</li>
<li>
glass: a clip-like material with a blended/reflective surface. Glass also stops bullets.
Will reflect the closest envmap entity, or if none is in range, the skybox.
Shows cyan volume in edit mode. Overwrites other volume materials.
</li>
<li>
lava: renders the top as a glowing lava flow and the sides as lavafalls if it isn't contained. It kills any players who enter it. Shows orange volume in edit mode. Overwrite other volume materials.
</li>
<li>
clip: an invisible wall that blocks players movement but not bullets. Is
ideally used to keep players "in bounds" in a map. Can be used sparingly to
smooth out the flow around decoration. Shows red volume in edit mode. Overwrites other clip materials.
</li>
<li>
noclip: cubes are always treated as empty in physics. Shows green volume in edit mode. Overwrites other clip materials.
</li>
<li>
gameclip: a game mode specific clip material. Currently it can block monsters in SP modes, it can stop flags from being picked up in areas in CTF/protect modes, and it can stop capturing of bases in areas in capture modes. Overwrites other clip materials.
</li>
<li>
death: causes the player to suicide if he is inside the material. Shows black volume in edit mode.
</li>
<li>
alpha: all faces of cubes with this material are rendered transparently. Use the "valpha" and "texalpha" commands to control the transparency of front and back faces. Shows pink volume in edit mode.
</li>
</ul>

<pre id="recalc">recalc</pre>
<p>
Recalculates scene geometry. This also will regenerate any envmaps to reflect the changed geometry,
and fix any geometry with "bumpenv*" shaders to use the closest available envmaps. This command is also
implicitly used by <a href="#calclight">calclight</a>.
</p>

<pre id="havesel">havesel</pre>
<p>
Returns the number of explicitly selected cubes for scripting purposes. 
Returns 0 if the cubes are only implicitly selected.
</p>

<pre id="gotosel">gotosel</pre>
<p>
Goes to the position of the currently selected cube or entity.
</p>

<h2 id="heightfield">Heightfield</h2>

<p>
Heightfields are very different than what most people are probably used to; they are just normal cubes and are NOT special meshes. Really, it's just another way of editing the same geometry.
Editing this way is a bit different from normal editing, but just as easy. First, instead of selecting cubes,
you select a brush (B+wheel) and textures (middle mouse button while in heightmap mode to toggle). Once this is done, you can apply the brush to all cubes that match the textures you've selected. Making hills and valleys can be quite fast when using this feature. By default all textures are automatically selected. 
</p>

<pre id="hmapedit">hmapedit 0/1</pre>
<p>
Set to 1 to turn on heightmap mode (default: hold LCTRL or use H to toggle on and off). In heightmap mode the cursor will turn bright green when hilighting heightmap cubes and the <a href="#editface">editface</a> command will now use brushes to edit heightmap cubes. In order to avoid accidental edits only heightmap cubes are editable in this mode. If a cubic selection is present, then only cubes within the column of the selection will be modifiable.
</p>

<pre id="hmapselect">hmapselect</pre>
<p>
Selects the texture and orientation of the hilighted cube (default: mouse buttons while in heightmap mode, or H key). If hmapselall is set to 1, then all textures are automatically selected, and this command will simply select the orientation. All cubes, of equal or larger size, that match the selection will be considered part of the heightmap.
</p>

<pre id="hmapcancel">hmapcancel</pre>
<p>
Return the heightmap texture selection to default (ie: select all textures).
</p>

<pre id="selectbrush">selectbrush D</pre>
<p>
Switches between the various height map brushes (default: hold B + wheel).
</p>

<pre id="clearbrush">clearbrush</pre>
<p>
This resets the current brush that is used during heightmap mode editing.
</p>

<pre id="brushvert">brushvert x y depth </pre>
<p>
A brush is a 2D map that describes the depth that the editface commands should
push into the cubes at various points. The first two parameters of brushvert are the X and Y
coordinates, respectively, of a vert on this 2D map. The last parameter
is used to set the depth. NOTE: if all of the brush verts are 0, then a smoothing filter will be 
applied instead of the brush. This filter will affect the same square sized region as the brush.
</p>

<pre id="brushx">brushx</pre>
<pre id="brushy">brushy</pre>
<p>
Along with the 2D map, all brushes also have a handle. This handle is a reference
point on the 2D map which defines where the brush is relative to the editing cursor.
These two variables define the brush handle's coordinates.
</p>

<h2 id="entity">Entity</h2>

<pre id="newent">newent type value1 value2 value3 value4</pre>
<p>
Adds a new entity where (x,y) is determined by the current selection (the red
dot corner) and z by the camera height, of said type. Type is a string giving
the type of entity, such as "light", and may optionally take values (depending
on the entity). The types are defines below in the <a href="#entity_types">Entity
Types</a> section.
</p>

<pre id="delent">delent</pre>
<p>
deletes the selected entities
</p>

<pre id="entflip">entflip</pre>
<p>
flip the selected entities. cube selection serves as both reference point and 
orientation to flip around.
</p>

<pre id="entpush">entpush D</pre>
<p>
push the selected entities. cube selection serves as orientation to push towards.
</p>

<pre id="entrotate">entrotate D</pre>
<p>
rotate the selected entities in relation to the cube selection.
</p>

<pre id="entmoving">entmoving 0/1/2</pre>
<p>
set to 1 to turn on. if an entity is under the cursor when turned on, the
entity will get toggled selected/unselected (set to 2 to add to selection instead of toggle). 
if selected, one can move the
entity around using the cursor. if multiple entities are selected, they will 
also move. the plane on which the entity will be moved is
dependent on the orientation of the cube surrounding the entity. set to 0 to turn off moving.
if no entity is under the cursor when turned on, it will automatically turn off.

</p>


<pre id="entdrop">entdrop N</pre>
<p>
variable controlling where entities created with "newent" will be placed.
N=0 place entities at your current eye position.
N=1 drop entities to the floor beneath you. Lights, however, will be placed at
your current eye position as for N=0.
N=2 place entities at the center of the currently selected cube face. If a
corner is selected, the entity will be placed at the corner vertex.
N=3 behaves as with N=2, except all entities, including lights, will then
bedropped from that position to whatever floor lies beneath. This mode is
useful for placing objects on selected floors. Lights are also dropped to the
floor, unlike for N=1.
</p>

<pre id="dropent">dropent</pre>
<p>
Positions the selected entity according to the entdrop variable.
</p>

<pre id="trigger">trigger T N</pre>
<p>
Sets the state of all locked triggers with tag T to N.
</p>

<pre id="platform">platform T N</pre>
<p>
If N = 0, stops all platforms or elevators with tag T.
If N = 1, causes all platforms or elevators with tag T to move forwards or up, respectively.
If N = -1, causes all platforms or elevators with tag T to move backwards or down, respectively.
</p>

<pre id="entselect">entselect X</pre>
<p>
Takes a boolean expression as argument. Selects all entities that evaluate to true for the given expression.
examples:
</p>

<ul>
<li>entselect insel // select all entities in blue selection box</li>
<li>entselect [ strcmp (et) "shells" ] // select all shells in map</li>
</ul>

<pre id="entloop">entloop X</pre>
<p>
Loops through and executes the given expression for all selected entities.
Note that most of the entity commands are already vector based and will 
automatically do this. Therefore they don't need to be explicitly executed within an entloop. 
Entloop is to be used when more precise custom instructions need to be executed on a selection. 
</p>

<p>
Another property of entloop is that entity commands within it, that are normally executed 
on the entire selection, will only be done on the current entity iterator.
In other words, the two following examples are equivalent:
</p>

<ul>
<li>entset light 120 0 0 0</li>
<li>entloop [ entset light 120 0 0 0 ]</li>
</ul>

<p>
The entset in the second statement will NOT be applied n squared times. Entloops can be nested.
</p>

<pre id="entcancel">entcancel</pre>
<p>
Deselect all entities.
</p>

<pre id="enthavesel">enthavesel</pre>
<p>
Returns the number of entities in the current selection.
</p>

<pre id="entget">entget</pre>
<p>
Returns a string in the form of "type value1 value2 value3 value4".
This string is the definition of the current selected entity. 
For example, the following statement will display the values of
all the entities within the current selection:
</p>
<ul>
<li>entloop [ echo (entget) ]</li>
</ul>

<p>
Outside of an entloop, the last entity selected will be returned. 
Normally, if an entity is highlighted by the cursor, it will
only be considered as in the selection if an explicit one does not exisit 
(like cubic selections). However, entget is special in that it considers
the highlighted entity as being the last entity in the selection.
Entget is used to generate the default entdisplay at the bottom of the screen.
</p>

<pre id="insel">insel</pre>
<p>
Returns true if the selected entity is inside the cube selection
</p>

<pre id="et">et</pre>
<p>
Cuts out the 'type' field from entget.
</p>

<pre id="ea">ea N</pre>
<p>
Cuts out the given 'value' field from entget. Attributes are numbered 0 to 3.
</p>

<pre id="entset">entset type value1 value2 value3 value4</pre>
<p>
Change the type and attributes of the selected entity.
To quickly bring up the entset command in the console press '.' (default: period). 
It will come pre-filled with the values of the current entity selection (from entget).
</p>

<pre id="entproperty">entproperty P A</pre>
<p>
Changes property P (0..3) of the selected entities by amount A. For example
"entproperty 0 2" when executed near a lightsource would increase its radius by
2.
</p>

<pre id="entfind">entfind type value1 value2 value3 value4</pre>
<p>
Select all entities matching given values. '*' and blanks are wildcard.
All ents that match the pattern will be ADDED to the selection.
</p>

<pre id="clearents">clearents type</pre>
<p>
Deletes all entities of said type.
</p>

<pre id="replaceents">replaceents type value1 value2 value3 value4</pre>
<p>
Replaces the given values for the selected entity and all entities that are
equal to the selected entity. 
To quickly bring up the replaceents command in the console press ',' (default: comma). It will come pre-filled with the values of the current entity selection.
</p>

<pre id="entautoview">entautoview N</pre>
<p>
Centers view on selected entity. Increment through selection by N. ex: N = 1 => next, N = -1 => previous. entautoviewdist N, sets the distance from entity.
</p>

<h2 id="settings">Settings</h2>

<pre id="undomegs">undomegs N</pre>
<p>
Sets the number of megabytes used for the undo buffer (default 5, max 100).
Undo's work for any size areas, so the amount of undo steps per megabyte is
more for small areas than for big ones.
</p>

<pre id="showsky">showsky B</pre>
<p>
This variable controls whether explicit sky polygons are outlined (in purple) in edit mode.
Default = 1.
</p>

<pre id="outline">outline B</pre>
<p>
This variable controls whether geometry boundaries (outlines) are shown.
Default = 0.
</p>

<pre id="wireframe">wireframe 0/1</pre>
<p>
Turns on wireframe drawing of the map.
</p>

<pre id="allfaces">allfaces 0/1</pre>
<p>
when on, causes the texturing commands to apply the new texture to all sides of the selected cubes
rather than just the selected face.
</p>

<pre id="showmat">showmat B</pre>
<p>
This variables whether volumes are shown for invisible material surfaces in edit mode.
Material volumes may also be selected while this is enabled. Default = 1.
</p>

<pre id="optmats">optmats B</pre>
<p>
This variables controls whether material rendering should be optimized by grouping materials
into the largest possible surfaces. This will always make rendering faster, so the only reason
to disable it is for testing. Default = 1.
</p>

<pre id="entselradius">entselradius N</pre>
<p>
Sets the 'handle' size of entities when trying to select them. 
Larger sizes means it should be easier to select entities.
</p>

<pre id="entselsnap">entselsnap 0/1</pre>
<p>
Turns on snap-to-grid while draggin entities. (default: 6)
</p>

<pre id="entitysurf">entitysurf 0/1</pre>
<p>
When on, you will move with the entity as you push it with the scroll wheel. 
Of course, in order to push an entity, you must be holding it.
</p>

<pre id="selectionsurf">selectionsurf 0/1</pre>
<p>
When on, you will move with the selection box as you push it with the scroll wheel. 
Of course, in order to push a selection box, you must be holding it.
</p>

<h2 id="map_and_config">Map and Config</h2>

<pre id="map">map name</pre>
<p>
Loads up map "name" in the gamemode set previously by "mode". A map given as
"blah" refers to "packages/base/blah.ogz", "mypackage/blah" refers to
"packages/mypackage/blah.ogz". The menu has a set of maps that can be loaded.
See also map in the gameplay docs.
</p>

<p>
At every map load, "data/default_map_settings.cfg" is loaded which sets up all
texture definitions etc. Everything defined in there can be overridden per
package or per map by creating a "package.cfg" or "mapname.cfg" which contains
whatever you want to do differently from the default. It can also set up
triggers scripts per map etc.
</p>

<p>
When the map finishes it will load the next map when one is defined, otherwise
reloads the current map. You can define what map follows a particular map by
making an alias like (in the map script): <i>alias nextmap_blah1 blah2</i>
(loads "blah2" after "blah1").
</p>

<pre id="sendmap">sendmap</pre>
<p>
Saves the current map (without lightmaps) and sends it to the server so other clients may download it.
Only works in coopedit game mode.
</p>

<pre id="getmap">getmap</pre>
<p>
Gets a map from the server if one is available. Automatically loads the map when done. Only works in coopedit
game mode.        
</p>

<pre id="savemap">savemap name</pre>
<pre id="savecurrentmap">savecurrentmap</pre>
<p>
Saves the current map, using the same naming scheme as "map". Makes a versioned
backup to "mapname_N.BAK" if a map by that name already exists, so you can never
lose a map. With "savemap", if you leave out the "name" argument, it is saved under the current map name.
With "savecurrentmap", the map is saved with the name determined by the current game.

Where you store a map depends on the complexity of what you are creating: if
its a single map (maybe with its own .cfg) then the "base" package is the best
place. If its multiple maps or a map with new media (textures etc.) its better
to store it in its own package (a directory under "packages"), which makes
distributing it less messy.
</p>

<pre id="newmap">newmap size</pre>
<p>
Creates a new map of size^2 cubes (on the smallest grid size). 10 is a small
map, 15 is a large map but it goes up to 20.
</p>

<pre id="mapenlarge">mapenlarge</pre>
<p>
Doubles the dimensions of the current map.        
</p>

<pre id="maptitle">maptitle "Title by Author"</pre>
<p>
sets the map title, which will be displayed when the map loads. Either use the
above format, or simply "by Author" if the map has no particular title (always
displayed after the map load msg).
</p>

<pre id="loadsky">loadsky NAME [SPIN]</pre>
<p>
loads the skybox described by NAME, where NAME is a file name relative
to the "packages/" directory. The engine will look for 6 sky box images:
NAME_up.jpg, NAME_dn.jpg, NAME_lf.jpg, NAME_rt.jpg, NAME_ft.jpg, NAME_bk.jpg.
These represent the skybox in the up, down, left, right, front, and back
directions, respectively. If a .jpg file is not found, it will attempt to
search for the files with a .png extension. SPIN, if specified, is floating point value that
specifies, in degrees per second, the rate at which to spin/yaw the skybox.

NOTE: This is an alias for the "skybox" and "spinsky" commands.
</p>

<pre id="texturereset">texturereset</pre>
<p>
Sets the texture slot to 0 for the subsequent "texture" commands.
</p>

<pre id="materialreset">materialreset</pre>
<p>
Resets the material texture slots for subsequent "texture" commands.
</p>

<pre id="texture">texture TYPE FILENAME ROT X Y SCALE</pre>
<table>
<tr>
	<td>FILENAME</td>
	<td>
		Binds the texture indicated to the current texture slot, then increments the slot number
		depending on TYPE.
	</td>
</tr>
<tr>
	<td>TYPE</td>
	<td>
		Specifying the primary diffuse texture advances to the next texture slot,
		while secondary types fill additional texture units in the order specified in the .cfg
		file. Allows secondary textures to be specified for a single texture slot, for use in
		shaders and other features, the combinations of multiple textures into a single texture
		are performed automatically in the shader rendering path:
		<ul>
			<li>"c" or 0 for primary diffuse texture (RGB)</li>
			<li>"u" or 1 for generic secondary texture</li>
			<li>"d" for decals (RGBA), blended into the diffuse texture if running in fixed-function mode. To disable this combining, specify secondary textures as generic with 1 or "u"</li>
			<li>"n" for normal maps (XYZ)</li>
			<li>"g" for glow maps (RGB), blended into the diffuse texture if running in fixed-function mode. To disable this combining, specify secondary textures as generic with 1 or "u"</li>
			<li>"s" for specularity maps (grey-scale), put in alpha channel of diffuse ("c")</li>
			<li>"z" for depth maps (Z), put in alpha channel of normal ("n") maps</li>
			<li>"e" for environment maps (skybox), uses the same syntax as "loadsky", and set a custom environment map (overriding the "envmap" entities) to use in environment-mapped shaders ("bumpenv*world")</li>
		</ul>
		This may also be a material name, in which case it behaves like 0, but instead associates the slot with a material.
	</td>
</tr>
<tr>
	<td>ROT</td>
	<td>
		Specifies preprocessing on the image, currently only rotation and flipping:
		<ul>
			<li>0 = none</li>
			<li>1 = 90 CW</li>
			<li>2 = 180</li>
			<li>3 = 270 CW</li>
			<li>4 = X flip</li>
			<li>5 = Y flip</li>
		</ul>
	</td>
</tr>
<tr>
	<td>X and Y</td>
	<td>These are the X and Y offset in texels.</td>
</tr>
<tr>
	<td>SCALE</td>
	<td>This will multiply the size of the texture as it appears on world geometry.</td>
</tr>
</table>

<pre id="autograss">autograss FILENAME</pre>
<p>
Automatically generates grass for the current texture slot on any upward facing surface. The grass texture FILENAME is used to to texture the grass blades. 
</p>

<pre id="grassscale">grassscale N</pre>
<p>
Sets the scaling of all grass textures to N where N=1..64 (default: 2).
</p>

<pre id="grasscolour">grasscolour R G B</pre>
<p>
The colour of the grass, specified as R G B values from 0..255 (default: 255 255 255).
</p>

<pre id="grassalpha">grassalpha A</pre>
<p>
Sets the opacity of all grass textures to A where floating point value A=0..1 (default: 1).
</p>

<pre id="texscroll">texscroll X Y</pre>
<p>
Scrolls the current texture slot at X and Y Hz, along the X and Y axes of the texture respectively.
</p>

<pre id="texrotate">texrotate N</pre>
<p>
Rotates the current texture slot by N*90 degrees for N=0..3. N=4 flips along the X axis, and N=5 flips along the Y axis. 
</p>

<pre id="vrotate">vrotate N</pre>
<p>
Rotates all textures in the current selection as if by the "texrotate" command.
</p>

<pre id="texoffset">texoffset X Y</pre>
<p>
Offsets the current texture slot by X and Y texels along the X and Y axes of the texture respectively.
</p>

<pre id="voffset">voffset X Y</pre>
<p>
Offsets all textures in the current selection as if by the "texoffset" command.
</p>

<pre id="texscale">texscale N</pre>
<p>
Scales the current texture slot such that it is N times its normal size.
</p>

<pre id="vscale">vscale N</pre>
<p>
Scales all textures in the current selection as if by the "texscale" command.
</p>

<pre id="texalpha">texalpha F B</pre>
<p>
Sets the alpha transparency of the front faces to F and back faces to B, where F and B are floating point values in the range 0.0 to 1.0. F defaults to 0.5, and B defaults to 0 (invisible).
</p>

<pre id="valpha">valpha F B</pre>
<p>
Sets the alpha transparency of all textures in the current selection as if by the "texalpha" command.
</p>

<pre id="texcolor">texcolor R G B</pre>
<p>
Sets the color multiplier of the current texture slot to the color R G B, where R, G, and B are floating point values in the range 0.0 to 1.0. The default is white, i.e. (1.0 1.0 1.0).
</p>

<pre id="vcolor">vcolor R G B</pre>
<p>
Sets the color multiplier of all textures in the current selection as if by the "texcolor" command.
</p>

<pre id="vreset">vreset</pre>
<p>
Resets the texture configuration of all textures in the current selection to the defaults defined in the map cfg file.
</p>

<pre id="vdelta">vdelta BODY</pre>
<p>
Excutes all of the "v*" commands in BODY such that they now only add to the current values for the textures in the current selection, rather than simply setting them. For example, vdelta [vrotate 1] would add 1 to the current rotation value for the textures, rather than just setting their rotation value to 1. This affects the "vrotate" (adds), "voffset" (adds), "vscale" (multiplies), "vshaderparam" (overrides), and "vcolor" (multiplies) commands.
</p>

<pre id="fog">fog N</pre>
<p>
Sets fog distance to N (default: 4000). You can do this for tweaking the visual effect of the fog, or if you are on a slow machine,
setting the fog to a low value can also be a very effective way to increase fps (if you are geometry limited). Try out different
values on big maps or maps which give you low fps.
</p>

<pre id="fogcolour">fogcolour R G B</pre>
<p>
The colour of the fog, specified as R G B values from 0..255 (default: 128 153 179).
</p>

<pre id="waterspec">waterspec N</pre>
<p>
This sets the percentage of light water shows as specularity (default: 150).
</p>

<pre id="waterfog">waterfog N</pre>
<p>
Sets the distance beneath the surface of water at which it fogs, from 1..10000 (default: 150).
</p>

<p>
</p>

<pre id="watercolour">watercolour R G B</pre>
<p>
Sets the the colour of fog inside the water to the specified R G B value from 0..255 (default: 20 70 80). Used to give water some colour. Setting to the values 0 0 0 will cause it to reset to the default watercolour.
</p>

<pre id="waterfallcolour">waterfallcolour R G B</pre>
<p>
Sets the the colour used for waterfall turbulence to the specified R G B value from 0..255 (default: 0 0 0). If the default of 0 0 0 is specified, waterfalls will use the colour supplied via "watercolour" instead.
</p>

<pre id="lavafog">lavafog N</pre>
<p>
Sets the distance beneath the surface of lava at which it fogs, from 1..10000 (default: 50).
</p>

<pre id="lavacolour">lavacolour R G B</pre>
<p>
Sets the the colour of fog inside the lava to the specified R G B value from 0..255 (default: 255 64 0). Used to give lava some colour. Setting to the values 0 0 0 will cause it to reset to the default watercolour.
</p>

<pre id="shader">shader TYPE NAME VS PS</pre>
<p>
defines a shader NAME with vertex shader VS and pixel shader PS (both in ARB OpenGL 1.5 assembly format). See data/stdshader.cfg for examples.
These definitions can be put in map cfg files or anywhere else, and will only be compiled once.
TYPE indicates what resources the shader provides, or what backup method should be used if the graphics card does not support shaders.
TYPE is either 0 for default shader, or 1 for normal-mapped world shaders.
Requires DX9 / shader 2 class hardware (radeon 9500 or better, geforce 5200 or better) to run (older hardware will default to basic rendering).
</p>

<pre id="fastshader">fastshader NICE FAST N</pre>
<p>
Associates shader FAST so that it will run in place of shader NICE if shaderdetail is less than or equal to N.
</p>

<pre id="setshader">setshader NAME</pre>
<p>
Sets a previously defined shader as the current shader. Any following texture slots (see "texture" command) will have this shader
attached to them. Any pixel or vertex parameters are reset to the shader's defaults when this command is used.
</p>

<pre id="setshaderparam">setshaderparam NAME X Y Z W</pre>
<p>
Overrides a uniform parameter for the current shader. Any following texture slots will use this pixel parameter until its value is set/reset by subsequent commands.
NAME is the name of a defined parameter of the current shader. It's value is set to the vector (X, Y, Z, W). Coordinates that are not specified default to 0.
</p>

<pre id="vshaderparam">vshaderparam NAME X Y Z W</pre>
<p>
Overrides a uniform parameter for the shaders of all textures in the current selection, as if by the "setshaderparam" command.
</p>

<pre id="setpixelparam">setpixelparam INDEX X Y Z W</pre>
<p>
Overrides a pixel parameter for the current shader. Any following texture slots will use this pixel parameter until its value is set/reset by subsequent commands.
INDEX is the index of a program environment parameter (program.env[10+INDEX]) to the pixel program of the current shader. It's value is set to the vector (X, Y, Z, W). Coordinates that are not specified default to 0.
</p>

<pre id="setvertexparam">setvertexparam INDEX X Y Z W</pre>
<p>
Overrides a vertex parameter for the current shader. Any following texture slots will use this vertex parameter until its value is set/reset by subsequent commands.
INDEX is the index of a program environment parameter (program.env[10+INDEX]) to the vertex program of the current shader. It's value is set to the vector (X, Y, Z, W). Coordinates that are not specified default to 0.
</p>

<pre id="setuniformparam">setuniformparam NAME X Y Z W</pre>
<p>
Overrides a uniform parameter for the current shader. Any following texture slots will use this pixel parameter until its value is set/reset by subsequent commands.
NAME is the name of a uniform variable in the current GLSL shader. It's value is set to the vector (X, Y, Z, W). Coordinates that are not specified default to 0.
</p>

<table>
<tr>
<td>Shader</td>
<td>Shader params</td>
<td>Texture slots</td>
<td></td>
</tr>

<tr>
<td>stdworld</td>
<td></td>
<td>c</td>
<td>The default lightmapped world shader. 
</td>
</tr>

<tr>
<td>decalworld</td>
<td></td>
<td>c, d
</td>
<td>Like stdworld, except alpha blends decal texture on diffuse texture.
</td>
</tr>

<tr>
<td>glowworld</td>
<td>  <ul><li>glowcolor: Rk, Gk, Bk - multiplies the glow map color by the factors Rk, Gk, Bk</li></ul>
</td>
<td>c, g</td>
<td>Like stdworld, except adds light from glow map.
</td>
</tr>

<tr>
<td>bumpworld</td>
<td></td>
<td>c, n</td>
<td>Normal-mapped shader without specularity (diffuse lighting only).  
</td>
</tr>

<tr>
<td>bumpglowworld</td>
<td>  <ul><li>glowcolor: Rk, Gk, Bk - multiplies the glow map color by the factors Rk, Gk, Bk</li></ul>
</td>
<td>c, n, g</td>
<td>Normal-mapped shader with glow map and without specularity.
</td>
</tr>

<tr>
<td>bumpspecworld</td>
<td>  <ul><li>specscale: Rk, Gk, Bk - multiplies the specular light color by the factors Rk, Gk, Bk</li></ul>
</td>
<td>c, n</td>
<td>Normal-mapped shader with constant specularity factor.
</td>
</tr>

<tr>
<td>bumpspecmapworld</td>
<td>same as above
</td>
<td>c, n, s</td>
<td>Normal-mapped shader with specularity map.
</td>
</tr>

<tr>
<td>bumpspecglowworld</td>
<td>  <ul>
        <li>glowcolor: Rk, Gk, Bk - multiplies the glow map color by the factors Rk, Gk, Bk</li>
        <li>specscale: Rk, Gk, Bk - multiplies the specular light color by the factors Rk, Gk, Bk</li>
  </ul>
</td>
<td>c, n, g</td>
<td>Normal-mapped shader with constant specularity factor and glow map.
</td>
</tr>

<tr>
<td>bumpspecmapglowworld</td>
<td>same as above
</td>
<td>c, n, s, g</td>
<td>Normal-mapped shader with specularity map and glow map.
</td>
</tr>

<tr>
<td>bumpparallaxworld</td>
<td>    <ul>
        <li>parallaxscale: Scale, Bias - Scales the heightmap offset</li>
    </ul>
</td>
<td>c, n, z</td>
<td>Normal-mapped shader with height map and without specularity.
</td>
</tr>

<tr>
<td>bumpspecparallaxworld</td>
<td>  <ul>
        <li>specscale: Rk, Gk, Bk - multiplies the specular light color by the factors Rk, Gk, Bk</li>
            <li>parallaxscale: Scale, Bias - Scales the heightmap offset</li>
        </ul> 
</td>
<td>c, n, z</td>
<td>Normal-mapped shader with constant specularity factor and height map.
</td>
</tr>

<tr>
<td>bumpspecmapparallaxworld</td>
<td>same as above
</td>
<td>c, n, s, z</td>
<td>Normal-mapped shader with specularity map and height map.
</td>
</tr>

<tr>
<td>bumpparallaxglowworld</td>
<td>  <ul>
        <li>glowcolor: Rk, Gk, Bk - multiplies the glow map color by the factors Rk, Gk, Bk</li>
            <li>parallaxscale: Scale, Bias - Scales the heightmap offset</li>
        </ul>
</td>
<td>c, n, z, g</td>
<td>Normal-mapped shader with height and glow maps, and without specularity.
</td>
</tr>

<tr>
<td>bumpspecparallaxglowworld</td>
<td>  <ul>
        <li>glowcolor: Rk, Gk, Bk - multiplies the glow map color by the factors Rk, Gk, Bk</li>
        <li>specscale: Rk, Gk, Bk - multiplies the specular light color by the factors Rk, Gk, Bk</li>
            <li>parallaxscale: Scale, Bias - Scales the heightmap offset</li>
        </ul>
</td>
<td>c, n, z, g</td>
<td>Normal-mapped shader with constant specularity factor, and height and glow maps.
</td>
</tr>

<tr>
<td>bumpspecmapparallaxglowworld</td>
<td>same as above
</td>
<td>c, n, s, z, g</td>
<td>Normal-mapped shader with specularity, height, and glow maps.
</td>
</tr>

<tr>
<td>bumpenv*</td>
<td>  <ul>
        <li>envscale: Rk, Gk, Bk - multiplies the environment map color by the factors Rk, Gk, Bk</li>
        </ul>
</td>
<td></td>
<td>Any of the above bump* shader permutations may replace "bump" with "bumpenv"
(i.e. bumpenvspecmapworld), and will then reflect the closest <a href="#_envmap_">envmap</a>
entity (or the skybox if necessary). They support all their usual texture slots and pixel params,
in addition to the envmap multiplier pixel param. If a specmap is present in the given shader,
the raw specmap value will be scaled by the envmap multipliers (instead of the specmap ones),
to determine how much of the envmap to reflect. A <a href="#calclight">calclight</a> (if it
has not been done before) or <a href="#recalc">recalc</a> (thereafter) is also needed by this
shader to properly setup its engine state.</td> 
</tr>

</table>

<pre id="music">music name [ondone]</pre>
<p>
Plays song "name" (with "packages" as base dir). This command is best used from
map cfg files or triggers. Evaluates ondone when the song is finished, or just keeps
looping the song if ondone is missing. Example: <i>music "songs/music.ogg" [ echo "Song done playing!" ]</i>
</p>



<pre id="n">N = registersound name V</pre>
<p>
Registers sound "name" (see for example data/sounds.cfg). This
command returns the sound number N, which is assigned from 0 onwards, and which
can be used with "sound" command below. if the sound was already registered,
its existing index is returned. registersound does not actually load the sound,
this is done on first play. V is volume adjustment; if not specified (0), it is the default 100, valid
range is 1-255.</p>

<pre id="sound">sound N</pre>
<p>
Plays sound N, see data/sounds.cfg for default sounds, and use registersound to
register your own. for example, <i>sound 0</i> and <i>sound (registersound
"aard/jump")</i> both play the standard jump sound.
</p>

<pre id="mapsound">mapsound name V N</pre>
<p>
Registers sound "name" as a map-specific sounds. These map-specific sounds may currently only
be used with "sound" entities within a map. The first map sound registered in a map has index 0, 
and increases afterwards (the second sound in the config is 1 and the third is 2, and so on).
V is volume adjustment; if not specified (0), it is the default 100, valid
range is 1-255. N is the maximum number instances of this sound that are allowed to play simultaneously;
the default is only 1 instance. If N is -1, then an unlimited number of instances may play simultaneously.</p>

<pre id="mapmodel">mapmodel R H T N SH</pre>
<pre id="mmodel">mmodel N</pre>
<p>
<i>NOTE: the mapmodel form is deprecated.. set additional properties of a mapmodel in its .cfg</i>
Registers a mapmodel that can be placed in maps using <i>newent
mapmodel</i> (see newent). N is the name, R is the square
radius, H the height, T the texture slot to skin the model with (0 for default skin), and SH toggles whether the it
will cast shadows (not given or 1 casts shadows, 0 has no shadows). The radius R and height
H define the collision bounding box of the model (if either is 0, players won't collide
with the mapmodel). Name N is the name of a folder inside packages/models folder, e.g.
"hudguns/rifle". Loaded from that folder are: tris.md2 and skin.jpg (and if not available,
skin.png, or the same from the parent folder to allow skin sharing).
</p>
<p>
Example: <i>mapmodel 4 32 0 "tree1"</i>
</p>
<p>
This map model is loaded from packages/models/tree1/. It has a collision box 8x8x32 in size (x=2*R, y=2*R, z=H). It uses the model's default skin (texture slot=0).
It casts shadows (default).
</p>

<pre id="shadowmapambient">shadowmapambient N</pre>
<p>
specifies a colour to use for the ambient light value of shadows created by shadowmapping, where N
is a hexadecimal colour value of the form "0xRRGGBB". Note that any value of 255 or less are treated
as gray-scale. If N is 0 or unset, this value is determined by the "ambient" variable and the "skylight"
command. (Default: 0)
</p>

<pre id="shadowmapangle">shadowmapangle N</pre>
<p>
specifies the angle in degrees at which shadows created by shadowmapping point. If N is 0 or unset,
this value is guessed based on any radius 0 lights in the map.
</p>

<pre id="causticscale">causticscale N</pre>
<p>
specifies the scale, as a percent, to multiply the size of water caustics by.
</p>

<pre id="causticmillis">causticmillis N</pre>
<p>
specifies the speed at which water caustics play, in milliseconds per frame.
</p>

<pre id="skybox">skybox NAME</pre>
<p>
loads the skybox described by NAME, where NAME is a file name relative
to the "packages/" directory. The engine will look for 6 sky box images:
NAME_up.jpg, NAME_dn.jpg, NAME_lf.jpg, NAME_rt.jpg, NAME_ft.jpg, NAME_bk.jpg.
These represent the skybox in the up, down, left, right, front, and back
directions, respectively. If a .jpg file is not found, it will attempt to
search for the files with a .png extension.
</p>

<pre id="spinsky">spinsky SPIN</pre>
<p>
a floating point value that specifies, in degrees per second, the rate at which to 
spin/yaw the skybox.
</p>

<pre id="yawsky">yawsky YAW</pre>
<p>
specifies in degrees a constant yaw rotation to apply
to the skybox.
</p>

<pre id="cloudbox">cloudbox NAME</pre>
<p>
loads the cloudbox described by NAME, similar to the "skybox" command. The cloudbox
should have an alpha channel which is used to blend it over the normal skybox.
</p>

<pre id="spinclouds">spinclouds SPIN</pre>
<p>
a floating point value that specifies, in degrees per second, the rate at which to 
spin/yaw the cloudbox.
</p>

<pre id="yawclouds">yawclouds YAW</pre>
<p>
specifies in degrees a constant yaw rotation to apply
to the cloudbox.
</p>

<pre id="cloudclip">cloudclip CLIP</pre>
<p>
specifies a vertical offset at which to clip the cloudbox, a floating point value between 0 and 1.
This defaults to 0.5, meaning the bottom half of the cloudbox is clipped away.
</p>

<pre id="cloudlayer">cloudlayer NAME</pre>
<p>
loads the cloud layer described by NAME, where NAME is a file name relative
to the "packages/" directory. The engine will look for either "packages/NAME.png"
or "packages/NAME.jpg".  The cloud layer should have an alpha channel which is used
to blend it onto the skybox. The cloud layer is mapped onto a horizontal circle 
that fades into the edges of the skybox.
</p>

<pre id="cloudscrollx">cloudscrollx N</pre>
<p>
specifies the rate, a floating-point value in Hz, at which the cloud layer scrolls in the X direction.
</p>

<pre id="cloudscrolly">cloudscrolly N</pre>
<p>
specifies the rate, a floating-point value in Hz, at which the cloud layer scrolls in the Y direction.
</p>

<pre id="cloudscale">cloudscale N</pre>
<p>
specifies the scale as a floating-point value telling how much to multiply the size of the cloud layer.
(Default: 1)
</p>

<pre id="cloudheight">cloudheight N</pre>
<p>
specifies the height of the cloud layer as a floating-point value, where -1 corresponds to the bottom of
the skybox, 0 corresponds to the middle of the skybox, and 1 corresponds to the top of the skybox. Intermediate
values place the cloud layer at intermediate heights of those. (Default: 0.2)
</p>

<pre id="cloudfade">cloudfade N</pre>
<p>
specifies the offset towards the center of the cloud layer at which the cloud layer will start fading into the skybox.
This is a floating-point value between 0 and 1, where 0 corresponds to the edge of the cloud layer, and 1 corresponds
to the center. (Default: 0.2)
</p>

<pre id="cloudcolour">cloudcolour N</pre>
<p>
specifies a colour multiplier for the cloud layer, where N is a hexadecimal colour value in the form of "0xRRGGBB".
(Default: 0xFFFFFF, white)
</p>

<pre id="cloudalpha">cloudalpha A</pre>
<p>
specifies an opacity for the cloud layer, where A is a floating-point value between 0 and 1.
(Default: 1, solid)
</p>

<pre id="fogdomeheight">fogdomeheight N</pre>
<p>
specifies the height of the fog dome as a floating-point value, where -1 corresponds to the bottom of
the skybox, 0 corresponds to the middle of the skybox, and 1 corresponds to the top of the skybox. Intermediate
values place the fog dome at intermediate heights of those. (Default: -0.5)
</p>

<pre id="fogdomemin">fogdomemin A</pre>
<p>
specifies a minimum opacity for the fog dome, where A is a floating-point value between 0 and 1.
(Default: 0, invisible)
</p>

<pre id="fogdomemax">fogdomemax A</pre>
<p>
specifies a maximum opacity for the fog dome, where A is a floating-point value between 0 and 1.
(Default: 0, invisible)
</p>

<pre id="fogdomecap">fogdomecap B</pre>
<p>
specifies whether the bottom of the fog dome should be capped, where B is 0 or 1 (Default: 1, on).
</p>

<pre id="fogdomeclip">fogdomeclip Z</pre>
<p>
specifies whether the top of the fog dome should be clipped off at a relative size Z, where Z is a floating-point value between 0 and 1 (Default: 1, not clipped).
</p>

<pre id="fogdomecolour">fogdomecolour R G B</pre>
<p>
The colour of the fog dome, specified as R G B values from 0..255 (default: 0 0 0). If the colour is 0, then the value of fogcolour is used instead of fogdomecolour.
</p>

<pre id="skytexture">skytexture B</pre>
<p>
specifies whether or not to enable rendering of sky-textured surfaces. If set to 0, sky-textured surfaces are not rendered,
allowing sky texture to be used as a "don't render this" surface. Disabling this also allows the skybox to be rendered last
after the scene, which yields speedups on some video cards, so disable this if possible in your map, even though it defaults
to on. (Default: 1)
</p>

<pre id="importcube">importcube N</pre>
<p>
Imports a cube map (.cgz) and converts it to the new OCTA (.ogz) map format. N is the
name of the map, without the .cgz. The map file must reside in packages/cube,
which is because that folder has a package.cfg that sets the default cube
textures. If the cube map in question has a custom texture list, it will have
to be adapted manually. Currently converts everything relatively faithfully,
except heighfields which are converted as best as possible but not always
accurately. Slopes tend to work faultlessly, landscape style stuff is usuable,
but curves/arches are problematic, and may have to be redone. All entities are
converted though mapmodels may not be present, and light entities are useless
because of their 2d nature, so probably the first thing to do after converting
a map is /clearents light, and place some new lights. Pickups and other items
may spawn inside the walls because they have no proper Z value, you may have to
correct these manually. The importcube command does not automatically save the
map, you still have to do a /savecurrentmap which will create
packages/cube/N.ogz. Reload the map to be able to pick up stuff. Waterlevel is
also not supported, you will have to add water using the new material system.
</p>

<pre id="writeobj">writeobj N</pre>
<p>
Writes out the current map as N.obj, so you could use the engine as a generic modeller
with any program/engine that uses meshes. The meshes aren't very optimal and don't
have texture/lighting information.
</p>

<pre id="flipnormalmapy">flipnormalmapy D N</pre>
<p>
Normalmaps generally come in two kinds, left-handed or righ-handed coordinate systems. If you are
trying to use normalmaps authored for other engines, you may find that the lighting goes the wrong
way along one axis, this can be fixed by flipping the Y coordinate of the normal. This command loads normalmap
N (MUST be 24bit .tga), and writes out a flipped normalmap as D (also tga).
</p>

<pre id="mergenormalmaps">mergenormalmaps H N</pre>
<p>
Normalmaps authored for Quake 4 often come as a base normal map, with seperate height offset file *_h.tga.
This is NOT a height file as used for parallax, instead its detail to be blended onto the normals.
This command takes normalmap N and a _h file H (both MUST be 24bit .tga), and outputs a combined normalmap N
(it *overwrites* N).  
</p>

<h2 id="lighting">Lighting</h2>

<pre id="ambient">ambient R [G B]</pre>
<p>
This sets the level of ambient light (default: 25), where R G B are color values 0..255. If only R is specified, it is interpreted as a grayscale light value. This is the minimum amount of light that a surface will get, even when no light entities reach the surface.
</p>

<pre id="edgetolerance">edgetolerance N</pre>
<p>
This controls how far an intersection with some geometry has to be from the surface of the actual triangle in question before it counts as a shadow (default: 4), where N is 1..8; the distance immediately in front of the triangle along the edge where it ignores shadows.
</p>
<p>
When lighting a map, each lightmap pixel is the result of many samples from a grid-pattern, as a result the sampling pattern may go over the edge of one triangle but behind another. Increasing this variable helps alleviate this, especially in terrain heavy maps.
 </p>

<pre id="sunlight">sunlight R [G B]</pre>
<p>
This sets the color of a simple directional sunlight. R G B are values in the range 0..255 (default: 0). If only R, is specified it is interpreted as a grayscale light value. Use "sunlight 0" to disable.
</p>

<pre id="sunlightyaw">sunlightyaw YAW</pre>
<p>
This sets the yaw of the directional sunlight to YAW.
</p>

<pre id="sunlightpitch">sunlightpitch PITCH</pre>
<p>
This sets the pitch of the directional sunlight to PITCH.
</p>

<pre id="sunlightscale">sunlightscale F</pre>
<p>
This sets the color scale of the direction sunlight to the floating-point value F (default: 1.0).
</p>

<pre id="skylight">skylight R [G B]</pre>
<p>
This enables the skybox to "emit" light, that can be occluded by geometry or models in the map. A surface will cast
a number of rays (currently 17), and any of them that hit the skybox will contribute a portion of the R G B 
light value above the "ambient" level to the surface (1/17th of the light). Effectively, the light will vary between 
the "ambient" value and the "skylight" value depending on how much of the skybox is visible. R G B are values in the 
range 0..255 (default: 0). If only R, is specified it is interpreted as a grayscale light value. Use "skylight 0" to disable.
</p>

<pre id="lmshadows">lmshadows N</pre>
<p>
This controls the level of shadowing used when "calclight" or "patchlight" are not given a quality setting, where N is:
</p>
<ul>
<li>2 (default): world and mapmodel shadows</li>
<li>1: world shadows only</li>
<li>0: no shadows</li>
</ul>

<pre id="lmaa">lmaa N</pre>
<p>
This controls the level of anti-aliasing used when "calclight" or "patchlight" are not given a quality setting, where N is:
</p>
<ul>
<li>3 (default): 8xAA</li>
<li>2: 4xAA</li>
<li>1: 2xAA</li>
<li>0: no AA</li>
</ul>

<pre id="calclight">calclight Q</pre>
<p>
This calculates all lightmaps. Usually takes only a few seconds, depending on
map size and settings. If you "savemap", the lightmap will be stored along with
it. Q is these predefined quality settings:
</p>
<ul>
<li>1: 8x anti aliasing, world and mapmodel shadows (maximum quality, slow)</li>
<li>0 or not given: controlled by "lmshadows" and "lmaa" values</li>
<li>-1: no anti aliasing, world shadows only (low quality, good for lighting previews)</li>
</ul>

<pre id="patchlight">patchlight Q</pre>
<p>
This will calculate lightmaps for any newly created cubes. This will generally
be much quicker than doing a "calclight", and so is very useful when editing.
However, it will make very inefficient use of lightmap textures, and any new
cubes will not properly cast shadows on surfaces that are already lit. It is
recommended you do a "calclight" on your map before you publish it with
"savemap". A quality setting Q may be supplied, which behaves the same as for
"calclight".
</p>

<pre id="lightthreads">lightthreads N</pre>
<p>
This controls the number of threads (N) used by the "calclight" and "patchlight" commands
You should set this variable to the number of processor cores you have to get a speed-up. 
By default (N=1), no multi-threading is used. 
</p>

<pre id="fullbright">fullbright B</pre>
<p>
This variable controls whether the map will be shown with lighting disabled.
Fullbright 1 will disable lighting, whereas 0 will enable lighting. (Default =
0)
</p>

<pre id="lerpangle">lerpangle A</pre>
<p>
Default = 44. This variable controls whether surface normals are interpolated for
lighting. Normals are sampled at each vertex of the surface. If the angle between
two surfaces' normals (which meet at a vertex) is less than A, then the resulting
normal will be the average of the two. Normals are then later interpolated between
the normals at the vertexes of a surface.
</p>

<pre id="lerpsubdiv">lerpsubdiv N</pre>
<p>
Default = 2. This allows more normals to be sampled at points along an edge between
two vertexes of a surface. 2^N-1 extra normals will be sampled along the edge, i.e.
the edge is split in half for every increment of N.
</p>

<pre id="lerpsubdivsize">lerpsubdivsize N</pre>
<p>
Default = 4. This sets the minimum size to which an edge may be subdivided. Edges
smaller than N or edge sections smaller than N will not be sampled.
</p>

<pre id="lightprecision">lightprecision P</pre>
<p>
Default = 32. This is the most important variable for tweaking the lighting, it
determines what the resolution of the lightmap is. As such has a BIG effect on
calculation time, video memory usage, and map file size. The default is good
for most maps, you may go as low as 16 if you are lighting a really small map
and love hard shadows, and for bigger maps you may need to set it to 64 or so
to get reasonable memory usage.
</p>

<p>
The number to watch out for is the number of lightmaps generated which are
shown on the HUD (and also as output after a calclight). 1 or 2 lightmap
textures is very good, over 10 lightmap textures is excessive.
</p>

<p>
The map file size is 90% determined by the lightmaps, so tweak this value
to get an acceptable quality to size ratio. Look at the size of the map files,
sometimes a slightly higher lightprecision can halve the size of your .ogz.
</p>

<p>
Every surface matters, even though the engine attempts to compress surfaces
with a uniform lightvalue, it is always a good ideas to delete parts of the
world that are not part of your map. Lightprecision, lighterror, and lightlod
are stored as part of map files.
</p>

<pre id="lighterror">lighterror E</pre>
<p>
There should be little reason to tweak this. If in your map you can see visible
polygon boundaries caused by lighting, you can try stepping this down to 6 or 4
to improve quality at the expense of lightmap space. If you have an insanely
large map and looking for ways to reduce file size, increasing error up to 16
may help. (Default = 8)
</p>

<pre id="lightlod">lightlod D</pre>
<p>
Default = 0. This will double the resolution of lightmaps (cut the
lightprecision in half) if size of the surface being lit is smaller than 2^D
units. This allows large maps to have pockets of detailed lighting without
using a high resolution over everything.


NOTE: if you feel like using this, test it thoroughly. On medium or small sized
detailed maps, this command wastes space, use lightlod 0. Lightlod &gt; 0 is
only useful for huge maps
</p>

<pre id="blurlms">blurlms N</pre>
<p>
This variable controls whether to apply a blur filter to the lightmap after
they are generated, as a post-pass. For N=0, no blur is applied. For N=1, a
3x3 blur filter is used. For N=2, a 5x5 blur filter is used. 

NOTE: this can cause lightmaps to mismatch at surface boundaries in complex scenes.
</p>

<pre id="blurskylight">blurskylight N</pre>
<p>
This variable controls whether to apply a blur filter to the ambient skylight
(enabled via the "skylight" command) before it is combined with the other 
lighting to create the final lightmap. This variable is useful for softening
the skylight and making it appear more scattered. For N=0, no blur is applied. 
For N=1, a 3x3 blur filter is used. For N=2, a 5x5 blur filter is used.
</p>

<pre id="dumplms">dumplms</pre>
<p>
Dumps all lightmaps to a set of .bmps. Mostly interesting for developers, but
mappers may find it interesting too.
</p>

<h2 id="texture_blending">Texture Blending</h2>

<p>
Texture blending in maps is accomplished by smoothly blending two textures together to create variations on architecture and terrain.
</p>

<h3 id="defining_blended_textures">Defining Blended Textures</h3>
<p>
Texture blending can use any two textures that are already set in your map.cfg, but you need to define the textures normally first. Texture thumbnails that have an additional texture layer to blend will have the texture they are set to blend with in one of the corners in the texture browser (f2).
</p>

<p>
To set up textures to blend, in your map cfg, under the texture that you want to have a second texture layer, you would add:
</p>

<pre id="texlayer">texlayer N</pre>

<p>
N is the index of the texture slot you want to use as the bottom texture layer to blend with. Texture slots start at 0, which is the first slot, 1 is the second slot, 2 is the third slot, etc. If N is a negative number, it will reference N slots back from the current slot, i.e. -1 references the previous texture slot.
</p>

<pre id="vlayer">vlayer N</pre>

<p>
Sets the bottom texture layer for all textures in the current selection, as if by "texlayer" command. However, negative values of N are not supported.
</p>

<h3 id="blend_brushes">Blend Brushes</h3>
<p>
There will be a number of brushes already included and set up in the default "data/brush.cfg". If you want to set up your own brush, create a grayscale PNG file to use as a pattern. Keep in mind that the size of the brushes are relatively large, and not meant for super detailed work. So a 16 x 16 size image will make a brush that covers a very large patch of architecture.
</p>

<h4>Adding a New Brush</h4>

<pre id="addblendbrush">addblendbrush N F</pre>

<p>
Where N is the name of your brush, that you will use later to load the brush, and F is the file name, relative to the data directory. So if the brush you want to add is called "mybrush.png", then you would add the following line to your map.cfg file: <tt>addblendbrush mybrush "mybrush.png""</tt>. Note that the filename of the brush image is relative to the root directory.
</p>

<h4>Loading a Brush</h4>

<pre id="setblendbrush">setblendbrush N</pre>

<p>
Where N is the name of your brush that you defined in the cfg, or the name of an existing brush. So to set the brush to the one that was defined above, you would open the console with the tilde key and type: <tt>/setblendbrush mybrush</tt>
</p>

<pre id="nextblendbrush">nextblendbrush N</pre>

<p>
Selects the next brush after the current one if N is not specified, or is 1. Otherwise, it will advance the current brush selected by N over the list of brushes. N may be negative, in which case it will go backwards in the list of brushes. By default this is bound to the scroll wheel.
</p>

<pre id="rotateblendbrush">rotateblendbrush</pre>
<p>
Rotates the current blend brush. By default this is bound to MOUSE2 (right mouse button).
</p>

<h3 id="painting">Painting</h3>
<p>
First, texture the surfaces that you will want to paint with the textures that have had an extra texture layer defined for them in your map.cfg. You can only paint on textures that have had a second layer defined in the cfg. Now, you need to turn on a painting mode with the following command:
</p>

<pre id="blendpaintmode">blendpaintmode N</pre>

<p>
Where N is a number from 0 to 5, which defines how the painting will be done. Setting it to 0 turns paint mode off. Usually you should paint with mode 2. By default each of these modes are bound to their corresponding number on the numeric keypad.
</p>

<ul>
<li>0 - off</li>
<li>1 - set - use for replacing/clearing</li>
<li>2 - min(destination, source) - use for digging where black is the dig pattern</li>
<li>3 - max(destination, source) - use for filling where white is the fill pattern</li>
<li>4 - min(destination, invert(source)) - use for digging where white is the dig pattern</li>
<li>5 - max(destination, invert(source)) - use for filling where black is the fill pattern</li>
</ul>

<p>
Experiment with the numbers to understand what they do. Finally, in order to paint on to the surface, you would open the console and type
</p>

<pre id="paintblendmap">paintblendmap</pre>

<p>
If you've done everything right, you should see your first blended textures. By default this is bound to MOUSE1 (left mouse button).
</p>

<pre id="showblendmap">showblendmap</pre>

<p>
If for some reason the blendmap gets messed up while editing, you can use this command cause the blendmap to reshow without doing a full calclight.
</p>


<h3 id="reverting_paints">Reverting Paints</h3>
<p>
There is NO UNDO for texture blending. If you've screwed something up, you can do one of two things. Open the console with the tilde key and type
</p>

<pre id="clearblendmap">clearblendmap</pre>

<p>
This will delete ALL of the texture blending for the ENTIRE level.
</p>

<pre id="clearblendmapsel">clearblendmapsel</pre>

<p>
This will clear the texture blending on the selected geometry.
</p>

<h3 id="blending_hints_and_tips">Blending Hints and Tips</h3>
<p>
The amount of rendering passes the engine is required to make doubles on areas where the textures have been blended.
</p>

<h2 id="entity_types">Entity Types</h2>
<p>
Entities are shown in editmode by blue sparklies, and the closest one is
indicated on the HUD.
</p>

<pre id="_light_">"light" radius r g b</pre>
<p>
If G and B are 0 the R value will be taken as brightness for a white light. A
good radius for a small wall light is 64, for a middle sized room 128... for a
sun probably more like 1000. Lights with a radius of 0 do not attenuate and may
be more appropriate for simulating sunlight or ambient light; however, this
comes at the cost of slightly greater map file sizes. See the <a href="#lightingcommands">
lighting commands</a> for an indepth list of all lighting related commands.
</p>

<pre id="_spotlight_">"spotlight" radius</pre>
<p>
Creates a spotlight with the given "radius" (in degrees, 0 to 90). A 90 degree spotlight will
be a full hemisphere, whereas 0 degrees is simply a line. These will attach to the nearest "light"
entity within 100 units of the spotlight. The spotlight will shine in the direction of the spotlight,
relative to the "light" entity it is attached to. It inherits the sphere of influence (length of the spotlight) and 
color values from the attached light as well. Do not move these very far from the light they're or attached to or
you risk them detaching or attaching to the wrong lights on a map load!
</p>

<pre id="_envmap_">"envmap" [radius]</pre>
<p>
Creates an environment map reflecting the geometry around the entity. The optional radius
overrides the maximum distance within which glass or geometry using the "bumpenv*" shaders will reflect from this environment map. If none is specified,
the default is taken from the variable "envmapradius" (which defaults to 128 units), which may also be set in 
map cfgs. Environment maps are generated on a map load, or can be regenerated while editing using the "recalc" command.

Please use the absolute minimum number of these possible. Each one uses up a decent amount of texture memory. 
For instance, rather than using two environment maps on each side of a window, use only one in the middle of the pane
of glass. If you have a wall with many windows, place only one environment map in the middle of the wall geometry, and 
it should work just fine for all the windows.
</p>

<pre id="_sound_">"sound" N radius [size]</pre>
<p>
Will play map-specific sound N so long as the player is within the radius. However, only up to the max uses allowed for N (specified in the <a href="#mapsound">mapsound</a> command) will play, even if the player is within the radius of more N sounds than the max. 

By default (size 0), the sound is a point source. Its volume is maximal at the entity's location, and tapers off to 0 at the radius. If size is specified, the volume is maximal within the specified size, and only starts tapering once outside this distance. Radius is always defined as distance from the entity's location, so a size greater than or equal to the radius will just make a sound that is always max volume within the radius, and off outside.
</p>

<pre id="_playerstart_">"playerstart" [Y] [T]</pre>
<p>
Spawn spot, yaw Y is taken from the current camera yaw (should not be explicitly specified to "newent"). If T is specified, then the playerstart is used as a team-spawn for CTF modes ONLY, where team T may be either 1 or 2, matching the parameter supplied to "flag" entities. For all other modes, team T should either be 0 or simply not specified at all! Note that normal playerstarts are never used for CTF, and CTF playerstarts are never used for spawns in other modes.
</p>

<pre id="_flag_">"flag" [Y] T</pre>
<p>
A team flag for CTF maps ONLY. Yaw Y is taken from the current camera yaw (should not be explicitly specified to "newent"). Team T may be either 1 or 2. Playerstarts with a matching team will be chosen in CTF mode. 
</p>

<pre id="_base_">"base" [ammo [N]]</pre>
<p>
A base for capture mode. If N is specified, the alias "base_N" will be looked up, and its value used for the name of the base, or otherwise a default name will be assigned. If ammo is specified, the base will always produce that type of ammo. If ammo is unspecified or 0, the server will randomly choose a type of ammo to produce at the start of the match. If ammo is negative, then it will pick a random type, but will match all other bases with the same negative ammo value. Ammo types are:</p>
<ul>
<li>1: shells (shotgun)</li>
<li>2: bullets (chaingun)</li>
<li>3: rockets (rocket launcher)</li>
<li>4: rifle rounds (rifle)</li>
<li>5: grenades (grenade launcher</li>
<li>6: cartridges (pistol)</li>
</ul>
<pre id="_shells_">"shells"</pre>
<pre id="_bullets_">"bullets"</pre>
<pre id="_rockets_">"rockets"</pre>
<pre id="_riflerounds_">"riflerounds"</pre>
<pre id="_grenades_">"grenades"</pre>
<pre id="_cartridges_">"cartridges"</pre>
<pre id="_health_">"health"</pre>
<pre id="_healthboost_">"healthboost"</pre>
<pre id="_greenarmour_">"greenarmour"</pre>
<pre id="_yellowarmour_">"yellowarmour"</pre>
<pre id="_quaddamage_">"quaddamage"</pre>
<p>
A variety of pickup-able items, see <a href="./game.html">here</a>.
</p>

<pre id="_teleport_">"teleport" N [M]</pre>
<pre id="_teledest_">"teledest" [Y] N [P]</pre>
<p>
Creates a teleport connection, teleports are linked to a teledest with the same
N (of which there should be exactly one). N can be 0..255. Y is the yaw of the destination and is
initially taken from the current camera yaw, it cannot be specified when creating the entity. If M
is 0 or not specified, the default teleporter model is used. If M is -1, no model is rendered for
the teleporter. If M is a value 1 or greater, the corresponding mapmodel slot is used as the teleporter's
model. If P is 1, the teledest preserves the velocity of the player, otherwise the player's velocity is
reset upon teleporting.
</p>

<pre id="_jumppad_">"jumppad" Z [Y] [X]</pre>
<p>
A jumppad entity which gives you a push in the direction specified. For example, "jumppad 30 5" makes
you bounce up quite a bit and also pushes you forward a bit (so it is easier to land on a higher platform).
This entity does not render anything, so you are responsible for creating something that looks logical below
this entity.
</p>

<pre id="_mapmodel_">"mapmodel" [Y] N T R</pre>
<p>
A map model, i.e. an object rendered as md2/md3 which you collide against, cast
shadows etc. Y is the yaw of the model and is initially taken from the current camera yaw,
it cannot be specified when creating the entity. N determines which mapmodel you want, this
depends on "mapmodel" declarations in the maps cfg file. T specifies mapmodel behaviour such
as triggers, see table below. R is the trigger number, 0 means no trigger. This number specifies
what trigger to activate, and in addition, the alias
"<tt>level_trigger_Trigger</tt>"
will be executed, where Trigger is substituted accordingly (this allows you to script
additional actions upon a trigger, i.e. put this into your map cfg file to print
a message: <tt>alias level_trigger_1 "echo A door opened nearby"</tt>). The alias
"<tt>triggerstate</tt>" will hold a value of -1, 0, or 1 indicating how the trigger was activated.
</p>

<table border="1" cellpadding="2" cellspacing="0" style="font-size: 8pt">
<tr>
<td>Type</td>
<td>Trigger states</td>
<td>Trigger how often</td>
<td>Sound</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>loops mapmodel animation</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>do trigger animation when touched for the first time only and return to starting position (best for switches, use switch/lever models)</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>1</td>
<td>rumble</td>
<td>same as above but with sound</td>
</tr>
<tr>
<td>3</td>
<td>toggle (0/1) </td>
<td>1</td>
<td></td>
<td>do trigger animation when touched for the first time only and stay in toggled position (best for switches, use switch/lever models)</td>
</tr>
<tr>
<td>4</td>
<td>toggle (0/1) </td>
<td>1</td>
<td>rumble</td>
<td>same as above but with sound</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>N</td>
<td></td>
<td>do trigger animation when touched every time and return to starting position (best for switches, use switch/lever models)</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>N</td>
<td>rumble</td>
<td>same as above but with sound</td>
</tr>
<tr>
<td>7</td>
<td>toggle (0/1) </td>
<td>N</td>
<td></td>
<td>do trigger animation when touched every time and toggle positions (best for reversible switches, use switch/lever models)</td>
</tr>
<tr>
<td>8</td>
<td>toggle (0/1)</td>
<td>N</td>
<td>rumble</td>
<td>same as above but with sound</td>
</tr>
<tr>
<td>9</td>
<td>closed/open (0/1)</td>
<td>1</td>
<td>door?</td>
<td>opened by approach first time only, stays open afterwards. Collides while closed. (use door specific models)</td>
</tr>
<tr>
<td>10</td>
<td>closed/open (0/1)</td>
<td>N</td>
<td>door?</td>
<td>opened by approach every time, closes after 5 seconds. Collides while closed. (use door specific models)</td>
</tr>
<tr>
<td>11</td>
<td>locked (-1) </td>
<td>0/N</td>
<td>door?</td>
<td>opened/closed only by associated trigger. When approached while closed, collides and invokes level trigger with triggerstate -1. (use door specific models)</td>
</tr>
<tr>
<td>12</td>
<td>disappear (0)</td>
<td>1</td>
<td></td>
<td>do trigger animation once when touched, disappear after (good for triggers that look more like pickups, such as the carrot)</td>
</tr>
<tr>
<td>13</td>
<td>disappear (0)</td>
<td>1</td>
<td>rumble</td>
<td>same as above but with sound</td>
</tr>
<tr>
<td>14</td>
<td>disappear (-1)</td>
<td>0</td>
<td></td>
<td>like 11, but disappears after opening. </td>
</tr>
<tr>
<td>29</td>
<td>disappear (0)</td>
<td>1</td>
<td>end?</td>
<td>FPS specific. END LEVEL</td>
</tr>
</table>

<p>
Be careful when using "switch many" for thing that affect gameplay, such as opening
doors, as it can be confusing. Best is to reserve a particular model to mean "many"
and others "once". All types &gt;0 are snapped to 15 degree angles for orientation.
</p>

<pre id="_box_">"box" [Y] N W</pre>
<pre id="_barrel_">"barrel" [Y] N W H</pre>
<p>
Like a mapmodel, except that damage done to it will push the entity around. Y is the yaw of the model and is initially taken from the current camera yaw, it cannot be specified when creating the entity. N determines which mapmodel you want, this depends on "mapmodel" declarations in the maps cfg file. W is the weight of the box or barrel where the heavier it is the less it moves; if W is not specified or 0, it defaults to 25. Barrels, unlike boxes, will explode if more than H damage is done to them; if H is not specified or 0, it defaults to 50.
</p>

<pre id="_platform_">"platform" [Y] N T S</pre>
<pre id="_elevator_">"elevator" [Y] N T S</pre>
<p>
Like a mapmodel, except it moves around and carries players, monsters, or other dynamic entities. Y is the yaw of the model and is initially taken from the current camera yaw, it cannot be specified when creating the entity. N determines which mapmodel you want, this depends on "mapmodel" declarations in the maps cfg file. A platform will travel horizontally back and forth along the direction of its yaw, while an elevator will travel only up and down. When they hit an obstacle such as geometry, they will reverse their direction. T is a tag that may be used to start or stop the elevator with the "platform" command; if a non-zero tag is specified, then the platform or elevator will stop upon hitting an obstacle, rather than reversing direction. S is the speed at which the entity moves, in units per second; if S is not specified or 0, it defaults to to 8.
</p>

<pre id="_monster_">"monster" N [T]</pre>
<p>
A monster, currently N = 0..4 (see gameplay docs). Monster entities will be
spawned when in classic single player mode, and will attack you when you come
into view. yaw is taken from the current camera yaw. T is an optional tag number
that is assigned to this monster. When the monster dies, the script alias "monster_dead_T"
will be invoked.
</p>

<pre id="_respawnpoint_">"respawnpoint"</pre>
<p>

A respawnpoint for classic SP mode (see "SP Respawning"), when the player dies, they will repsawn at the last
one of these they touched, otherwise they start at the <a href="#_playerstart_">playerstart</a> entity.
</p>

<pre id="_particles_">"particles" type value1 value2 value3 value4</pre>
<p>
A particle emitter. Particles includes many of the effects as seen for weapons, explosions, and lens flares.
</p>

<table border="1" cellpadding="2" cellspacing="0" style="font-size: 8pt">
<tr>
<td>Type</td>
<td>Values</td>
<td>Description</td>
</tr>
<tr>
<td>0</td>
<td>radius, height, rgb (0x000..0xFFF) - 0 values are compat with older maps, otherwise radius&amp;height=100 is a 'classic' size</td>
<td>colored flames with smoke</td>
</tr>
<tr>
<td>1</td>
<td>direction (0..5)</td>
<td>steam vent</td>
</tr>
<tr>
<td>2</td>
<td>direction (0..5) - color comes from water color</td>
<td>water fountain</td>
</tr>
<tr>
<td>3</td>
<td>size (0..40), rgb (0x000..0xFFF)</td>
<td>explosion, i.e. fire ball [*expensive compared to other particles]</td>
</tr>
<tr>
<td>4</td>
<td>direction (0..5), length(0..100), rgb (0x000..0xFFF)</td>
<td>streak/flare</td>
</tr>
<tr>
<td>4</td>
<td>direction (256+effect), length(0..100), rgb (0x000..0xFFF)</td>
<td>
multiple streak/flare effect
<table>
<tr>
<td>Effect</td>
<td>Description</td>
</tr>
<tr>
<td>0..2</td>
<td>circlular</td>
</tr>
<tr>
<td>3..5</td>
<td>cylinderical shell</td>
</tr>
<tr>
<td>6..11</td>
<td>conic shell</td>
</tr>
<tr>
<td>12..14</td>
<td>cubic volume</td>
</tr>
<tr>
<td>15..20</td>
<td>planar surface</td>
</tr>
<tr>
<td>21</td>
<td>sphere</td>
</tr>
</table>
note: +32 to reverse direction of streaks
</td>
</tr>
<tr>
<td>5</td>
<td>percentage (0..100), rgb (0x000..0xFFF)</td>
<td>capture meter, i.e. rgb vs black</td>
</tr>
<tr>
<td>6</td>
<td>percentage (0..100), rgb (0x000..0xFFF)</td>
<td>vs capture meter, i.e. rgb vs bgr</td>
</tr>
<tr>
<td>7</td>
<td>direction, length, rgb - see type 4</td>
<td>lightning</td>
</tr>
<tr>
<td>9</td>
<td>direction, length, rgb - see type 4</td>
<td>steam</td>
</tr>
<tr>
<td>10</td>
<td>direction, length, rgb - see type 4</td>
<td>water</td>
</tr>
<tr>
<td>11</td>
<td>radius, height, rgb - radius&amp;height=100 is a 'classic' size</td>
<td>flames</td>
</tr>
<tr>
<td>12</td>
<td>radius, height, rgb - radius&amp;height=100 is a 'classic' size</td>
<td>smoke plume</td>
</tr>
<tr>
<td>32</td>
<td>red (0..255), green (0..255), blue (0..255)</td>
<td>plain lens flare</td>
</tr>
<tr>
<td>33</td>
<td>red (0..255), green (0..255), blue (0..255)</td>
<td>lens flare with sparkle center</td>
</tr>
<tr>
<td>34</td>
<td>red (0..255), green (0..255), blue (0..255)</td>
<td>sun lens flare, i.e. fixed size regardless of distance</td>
</tr>
<tr>
<td>35</td>
<td>red (0..255), green (0..255), blue (0..255)</td>
<td>sun lens flare with sparkle center</td>
</tr>
</table>

<h2 id="pvs_culling">PVS Culling</h2>
<p>Cube 2 provides a precomputed visibility culling system as described in the technical paper "Conservative Volumetric Visibility with Occluder Fusion" by Schaufler et al (see paper for technical details). Basically, it divides the world into small cube-shaped "view cells" of empty space that the player might possibly occupy, and for each of these view cells calculates what other parts of the octree might be visible from it. Since this is calculated ahead of time, the engine can cheaply look up at runtime whether some part of the octree is possibly visible from the player's current view cell. Once pre-calculated, this PVS (potential visibility set) data is stored within your map and saved along with it, so that it may be reused during gameplay. This data is only valid for a particular map/octree, and if you change your map, you must recalculate it or otherwise expect culling errors. It is recommended you do this only after you are sure you are finished working on your map and ready to release it, as it can take a very long time to compute this data. If you have a multi-core processor or multi-processor system, it can use multiple threads to speed up the pre-calculation (essentially N processors/cores will calculate N times faster).
</p>

<p>The number of pre-calculated view cells stored with your map will show up in the edit HUD stats under the "pvs:" stat. It is recommended you keep this number to less than 10,000, or otherwise the amount of storage used for the PVS data in your map can become excessive. For very large SP maps, up to 15,000 view cells is acceptable. The number of view cells is best controlled by use of the "clip" material, or by setting the view cell size (default is 32, equal to a gridpower 5 cube). View cell sizes of 64 or 128 are worth trying if your map still has an excessive number of view cells, but try to use the default view cell size of 32 if it stays reasonable. Note that if you have a map with a lot of open space, there will be a lot of view cells, and so the initial pre-calculation may take a long time. You can use the "clip" material, if necessary, to mark empty space the player can't go into, and the PVS calculation will skip computing view cells for these areas. Filling places the player can't go with solid cubes/sealing the map will similarly reduce the number of possible view cells.
</p>

<p>Visibility from a view cell, to some other part of the octree, is determined by looking for large square or block-shaped surfaces and seeing if they block the view from the view cell to each part of the octree. So surfaces like large walls, ceilings, solid buildings, or even mountains and hills, that have large solid cross-sections to them will make the best occluders, and allow the PVS system to cull away large chunks of the octree that are behind them, with respect to the current view cell. Avoid putting holes running entirely through these structures, or this will prevent large cross-section of them from being used as an occluder (since the player could possibly see through them). You can use the "testpvs" command to check how well your occluders are working while building them. If your map is an open arena-style map, then using the PVS system will have little to no effect, since few things are blocking visibility, and it is not worth using the PVS system for such maps.</p>

<p>Note that there is already an occlusion culling system based on hardware occlusion queries, in addition to the PVS system, so the main function of the PVS system is to provide occlusion culling for older 3D hardware that does not support occlusion queries, and also to speed up occlusion queries by reducing the amount of such queries (which can be expensive themselves) even for 3D hardware that supports them. If PVS is used effectively (a map with lots of good occluders), it should always provide some speed-up regardless of whether or not the 3D hardware supports occlusion queries. However, if you are doing open arena-style maps for which there are few good occluders, then it is recommended you skip using the PVS system (as it will just take up memory without providing a speedup) and rely upon the hardware occlusion queries instead.
</p>

<pre id="pvs">pvs N</pre>
<p>
Toggles PVS culling, where N=1 enables it, and N=0 disables it. This is mostly useful for testing the performance effect of the PVS system and should usually be left on.
</p>

<pre id="pvsthreads">pvsthreads N</pre>
<p>
Sets the number of threads (N) that will be used for calculating PVS info with the "genpvs" command. By default, only 1 thread (N=1) is used. If you have N processor or N processor cores, then set this variable to N to make the pre-calculation effectively N times faster. Setting this variable higher than the number of processors/cores will not make it any faster, but setting it lower will not utilize all of them, so try and set it to the exact number.
</p>

<pre id="genpvs">genpvs [N]</pre>
<p>
Pre-calculates PVS data for the current version of the map. N is the size of the view cell used for calculation. If N is not specified or 0, then the default view cell size of 32 is used. Try to always use the default view cell size where reasonable.
</p>

<pre id="clearpvs">clearpvs</pre>
<p>
Clears the PVS data for the map. Use this to clear away stale PVS data if you are editing a map for which PVS data was already pre-calculated to avoid culling errors (i.e. stuff being invisible that should otherwise be visible).
</p>

<pre id="lockpvs">lockpvs N</pre>
<p>
If N=1, this locks the view cell used by the PVS culling to the current view cell, even if you happen to move outside of it. Everything that was occluded/invisible from that view cell will still be so, even if you move outside of it. This is useful for seeing all the things that are being culled from a current vantage point by the PVS system. If N=0, the view cell is unlocked and PVS will function as normal again.
</p>

<pre id="testpvs">testpvs [N]</pre>
<p>
Generates PVS data for only the current view cell you are inside (of size N, or default 32 if not specified) and locks the view cell to it as if "lockpvs 1" were used. This allows you to quickly test the effectiveness of occlusion in your map without generating full PVS data, so that you can more easily optimize your map for PVS before the actual expensive pre-calculation is done. Use "lockpvs 0" to release the lock on the view cell when you are done testing. Note that this will not overwrite any existing PVS data already calculated for the map. 
</p>

<pre id="pvsstats">pvsstats</pre>
<p>
Prints out some useful info about the PVS data stored with the map, such as the number of view cells, the total amount of storage used for all the view cells, and the average amount of storage used for each individual view cell.
</p>

<h2 id="waypoints">Waypoints</h2>
<p>Cube 2 provides waypoints to aid bot navigation, and without these bots are not able to calculate safe paths from place to place on the map.
</p>

<p>
Waypoints are entities in a map that tell where it is safe for bots to move to. Each waypoint can link to other waypoints, telling a bot how to get from one waypoint to another. To set up waypoints, first either add a bot (which causes you to drop waypoints as a side-effect) or set the "dropwaypoints" variable to 1. Run around the level through all valid paths, making sure to run through teleporters and touch all items and playerstarts. Waypoints should be dropped at ground level in an even grid across the map, i.e. only jump where it is necesssary to jump. Avoid any movement tricks like weapon jumping that might confuse the AI. 
</p>

<p>Set the "showwaypoints" variable to 1 so you can see the waypoints you are dropping, and you will see blue lines representing the links between these waypoints. When you are done, use the "savewaypoints" command to save the waypoints for your map; they will be saved to a file named "yourmap.wpt" for a map named "yourmap" in the same directory as your map. It also helps to add some bots before you save and make sure there are no bots stuck at playerstarts without waypoints to guide them.
</p>

<p>Note waypoints are not loaded until required, i.e. until a "loadwaypoints" or "addbot" command is issued.
</p>

<pre id="showwaypoints">showwaypoints 0/1</pre>
<p>
Toggles showing of waypoints, where 1 enables it, and 0 disables it. This is mostly useful when laying waypoints so as to see the possible paths and ensure good coverage. 
</p>

<pre id="dropwaypoints">dropwaypoints 0/1</pre>
<p>
Toggles dropping of waypoints, where 1 enables it, and 0 disables it.  By default the player is dropping waypoints whilst playing against bots, this enables bots to "learn" from the player. Note that if enabled, waypoints will be saved automatically once the map is changed, and the variable will then be reset back to 0.
</p>

<pre id="loadwaypoints">loadwaypoints [filename]</pre>
<p>
Loads the waypoints for the current map (or specified file).
</p>

<pre id="savewaypoints">savewaypoints [filename]</pre>
<p>
Saves the waypoints for the current map (or specified file), e.g. as "&lt;mapname&gt;.wpt".
</p>

<pre id="clearwaypoints">clearwaypoints</pre>
<p>
Removes all waypoints.
</p>

<pre id="delselwaypoints">delselwaypoints</pre>
<p>
In editing mode this will remove waypoints within the selection region.
</p>

<h2 id="the_hud">The HUD</h2>
<p>
On the bottom left of the screen are a bunch of stats. You'll find out what they mean below.
</p>

<ul>
<li>
cube: the number of cubes in the current selection. Only the visible (leaf) cubes are counted.
</li>
<li>
fps: frames per second
</li>
<li>
ond: number of cubes in the system. This includes parent cubes, copied cubes, and undos.
</li>
<li>
va: number of vertex arrays used to store vertices in the map. You probably don't need to use this.
</li>
<li>
vtr: number of triangles currently being displayed. Will be a useful stat when culling is done.
</li>
<li>
vvt: number of vertices currently being displayed. Useful when culling is done.
</li>
<li>
tri: number of triangles in the entire map
</li>
<li>
wvt: number of vertices in the entire map
</li>
<li>
evt: misc rendering effects. Stuff like particles displayed, or text written on screen.
</li>
</ul>

<pre id="hidestats">hidestats 0/1</pre>
<p>
Turn on to hide the above stats
</p>

<pre id="hidehud">hidehud 0/1</pre>
<p>
Turn on to hide all HUD elements
</p>

</body>
</html>
