// standard shader definitions

lazyshader = [
    defershader $arg1 $arg2 [
        shader @arg1 @arg2 [@@arg3] [@@arg4]
    ]
]

gdepthinterp = [
    if (|| $gdepthformat $arg1) [result [
        uniform vec3 gdepthpackparams;
        varying float lineardepth;
    ]]
]
msaainterp = [gdepthinterp $msaasamples]

gdepthpackvert = [
    if (|| $gdepthformat $arg1) [result [
        lineardepth = dot(gl_ModelViewMatrixTranspose[2], gl_Vertex);
    ]]
]
msaapackvert = [gdepthpackvert $msaasamples]

gpackdepth = [
    result [
        vec3 @arg1 = @arg2 * gdepthpackparams;
        @arg1 = vec3(@arg1.x, fract(@arg1.yz));
        @arg1.xy -= @arg1.yz * (1.0/255.0);
    ]
]

ghashdepth = [
    if $arg3 [
        arg1 = [(@arg1 + 5.0*@arg3)]
    ] 
    if $arg2 [result [
        @arg2*0.76 + mix(0.75, 0.25, @arg2)*fract(@arg1*mix(-1.0/192.0, -1.0/64.0, @arg2))
    ]] [result [
        0.75*fract(@arg1*(-1.0/192.0))
    ]]
]
        
gdepthpackfrag = [
    result [
        @(if $gdepthformat [
            if (> $gdepthformat 1) [result [
                gl_FragData[3].r = lineardepth;
            ]] [result [
                @(gpackdepth packdepth lineardepth)
                gl_FragData[3].rgb = packdepth;
            ]]
        ])
        gl_FragData[1].a = @(if $arg1 [ghashdepth lineardepth $arg2 $arg3] [? $arg2 $arg2 [0.0]]);
    ]
]
msaapackfrag = [gdepthpackfrag $msaasamples $arg1 $arg2]

gdepthunpackparams = [
    result [
        uniform vec3 gdepthscale;
        uniform vec3 gdepthunpackparams;
    ]
]

gdepthunpack = [
    if $arg7 [
        if $arg8 [result [
            vec3 @[arg8] = gfetch(@[arg2], @[arg3]).rgb;
            float @[arg1] = dot(@[arg8], gdepthunpackparams); 
            @arg4
        ]] [result [
            float @[arg1] = dot(gfetch(@[arg2], @[arg3]).rgb, gdepthunpackparams); 
            @arg4
        ]]
    ] [if (|| $gdepthformat $arg6) [
        if (|| (> $gdepthformat 1) $arg6) [result [
            float @[arg1] = gfetch(@[arg2], @[arg3]).r;
            @arg4
        ]] [result [
            float @[arg1] = dot(gfetch(@[arg2], @[arg3]).rgb, gdepthunpackparams); 
            @arg4
        ]]
    ] [if (=s $arg5 []) [result [
        float @[arg1] = gdepthscale.x / (gfetch(@[arg2], @[arg3]).r*gdepthscale.y + gdepthscale.z);
    ]] [result [
        float @[arg1] = gfetch(@[arg2], @[arg3]).r;
        @arg5
    ]]]]
]

gdepthunpackproj = [
    if (|| $gdepthformat $arg6) [
        if (|| (> $gdepthformat 1) $arg6) [result [
            float @[arg1] = gfetchproj(@[arg2], @[arg3]).r;
            @arg4
        ]] [result [
            float @[arg1] = dot(gfetchproj(@[arg2], @[arg3]).rgb, gdepthunpackparams); 
            @arg4
        ]]
    ] [if (=s $arg5 []) [result [
        float @[arg1] = gdepthscale.x / (gfetchproj(@[arg2], @[arg3]).r*gdepthscale.y + gdepthscale.z);
    ]] [result [
        float @[arg1] = gfetchproj(@[arg2], @[arg3]).r;
        @arg5
    ]]]
]

gfetchdefs = [
    gfetchprefix = (? $arg3 $arg3 "gfetch")
    if (? (>= $numargs 2) $arg2 $msaasamples) [result [
        @(? (! $arg3) [
            #extension GL_ARB_texture_multisample : enable
            #ifdef GL_EXT_gpu_shader4
                #extension GL_EXT_gpu_shader4 : enable
            #endif
        ])
        uniform sampler2DMS @(prettylist $arg1);
        #define @[gfetchprefix](sampler, coords) texelFetch(sampler, ivec2(coords), 0)
        #define @[gfetchprefix]proj(sampler, coords) texelFetch(sampler, ivec2(coords.xy / coords.z), 0)
        #ifdef GL_EXT_gpu_shader4
            #define @[gfetchprefix]clamp(sampler, coords) texelFetch(sampler, clamp(ivec2(coords), ivec2(0), textureSize(sampler)-1), 0)
        #else
            #define @[gfetchprefix]clamp(sampler, coords) texelFetch(sampler, ivec2(clamp(coords, vec2(0), vec2(textureSize(sampler)-1))), 0)
        #endif
        @(if (! $arg3) [gdepthunpackparams])
    ]] [result [
        @(? (! $arg3) [#extension GL_ARB_texture_rectangle : enable])
        uniform sampler2DRect @(prettylist $arg1);
        #define @[gfetchprefix](sampler, coords) texture2DRect(sampler, coords)
        #define @[gfetchprefix]proj(sampler, coords) texture2DRectProj(sampler, coords)
        #define @[gfetchprefix]clamp(sampler, coords) texture2DRect(sampler, coords)
        @(if (! $arg3) [gdepthunpackparams])
    ]]
]

shader 0 "null" [
    void main(void)
    {
        gl_Position = gl_Vertex;
    }
] [
    void main(void)
    {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    }
]

///////////////////////////////////////////////////
//
// used for any textured polys that don't have a shader set
//
///////////////////////////////////////////////////

shader 0 "default" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture2D(tex0, gl_TexCoord[0].xy);
    }
]

shader 0 "rect" [ 
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture2DRect(tex0, gl_TexCoord[0].xy);
    }
]

shader 0 "tex3d" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform sampler3D tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture3D(tex0, gl_TexCoord[0].xyz);
    }
]

shader 0 "cubemap" [ 
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform samplerCube tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * textureCube(tex0, gl_TexCoord[0].xyz);
    }
]

shader 0 "rgbonly" [ 
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor.rgb = gl_Color.rgb * texture2D(tex0, gl_TexCoord[0].xy).rgb;
        gl_FragColor.a   = gl_Color.a;
    }
]

//////////////////////////////////////////////////////////////////////
//
// same, but now without texture sampling (some HUD stuff needs this)
//
//////////////////////////////////////////////////////////////////////

shader 0 "notexture" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
    }
] [
    void main(void)
    {
        gl_FragColor = gl_Color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// fogged variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "fogged" [
    #pragma CUBE2_fog
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture2D(tex0, gl_TexCoord[0].xy);
    }
]

shader 0 "foggednotexture" [
    #pragma CUBE2_fog
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
    }
] [
    void main(void)
    {
        gl_FragColor = gl_Color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// LDR variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "ldr" [
    uniform float ldrscale;
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = vec4(ldrscale * gl_Color.rgb, gl_Color.a);
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture2D(tex0, gl_TexCoord[0].xy);
    }
]

shader 0 "ldrnotexture" [
    uniform float ldrscale;
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = vec4(ldrscale * gl_Color.rgb, gl_Color.a);
    }
] [
    void main(void)
    {
        gl_FragColor = gl_Color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// for filling the z-buffer only (i.e. multi-pass rendering, OQ)
//
//////////////////////////////////////////////////////////////////////

shader 0 "nocolor" [
    void main() { gl_Position = ftransform(); } 
] [
    void main() {}
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

worldshader = [
  stype = 1
  if (>= (strstr $arg1 "env") 0) [stype = (+ $stype 2)]
  if (>= (strstr $arg1 "pulse") 0) [stype = (+ $stype 0x10)]
  loop i 3 [
    variantshader (? (= $i 2) (+ $stype 4) $stype) $arg1 (- $i 1) [
        @(if (>= $numargs 5) [result $arg5])
        uniform vec2 texgenscroll;
        varying vec3 normal;
        @(msaainterp)
        @(if (= $i 1) [result [uniform vec4 blendmapparams;]])

        void main(void)
        {
            gl_Position = ftransform();
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texgenscroll;
            @(if (= $i 1) [result [
                gl_TexCoord[1].xy = (gl_Vertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ]])
            normal = gl_Normal;
    
            @(msaapackvert)

            @arg2
        }
    ] [
        @(if (= $i 2) [result [
            @(gfetchdefs refractlight)
            uniform vec4 refractparams;
        ]])
        @(if (>= $numargs 5) [result $arg5])
        @(if (>= $numargs 6) [result $arg6])
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        @(? $msaasamples [uniform float hashid;])
        varying vec3 normal;
        @(msaainterp)
        @(if (= $i 1) [result [
            uniform float blendlayer;
            uniform sampler2D blendmap;
        ]])

        void main(void)
        {
            vec4 diffuse = texture2D(diffusemap, gl_TexCoord[0].xy);   

            @arg3

            @(if (= $i 2) [result [
                #define alpha 1.0
            ]] [result [
                #define alpha colorparams.a
            ]])
            
            gl_FragData[0].rgb = diffuse.rgb*colorparams.rgb;
            gl_FragData[0].a = 0.0;
            gl_FragData[1].rgb = normal*0.5+0.5;

            @(if (|| (< $numargs 4) [=s $arg4 []]) [result [gl_FragData[2].rgb = vec3(0.0);]] [result $arg4])

            @(if (= $i 2) [result [
                vec3 rlight = gfetch(refractlight, gl_FragCoord.xy).rgb;
                gl_FragData[2].rgb += rlight * refractparams.xyz;
            ]])

            @(msaapackfrag "" hashid)

            @(if (= $i 1) [result [
                float blend = abs(texture2D(blendmap, gl_TexCoord[1].xy).r - blendlayer);
                gl_FragData[0].rgb *= blend;
                gl_FragData[1].rgb *= blend;
                gl_FragData[1].a *= blendlayer;
                gl_FragData[2].rgb *= blend;
                gl_FragData[2].a = blendlayer;
            ]] [result [
                gl_FragData[2].a = alpha;
            ]])
        }
    ]
  ]
]

worldshader "stdworld" [] []

defershader 1 "glowworld" [
  defuniformparam "glowcolor" 1 1 1 // glow color
  worldshader "glowworld" [] [] [
    vec3 glow = texture2D(glowmap, gl_TexCoord[0].xy).rgb;
    glow *= glowcolor.rgb;
    gl_FragData[2].rgb = glow;
  ] [] [uniform sampler2D glowmap;]
]

defershader 0x11 "pulseworld" [
  defuniformparam "pulsespeed" 1 // pulse frequency (Hz)
  worldshader "pulseworld" [
    pulse = abs(fract(millis * pulsespeed.x)*2.0 - 1.0); 
  ] [
    vec3 diffuse2 = texture2D(decal, gl_TexCoord[0].xy).rgb; 
    diffuse.rgb = mix(diffuse.rgb, diffuse2, pulse);
  ] [] [uniform float millis; varying float pulse;] [uniform sampler2D decal;]
]

defershader 0x11 "pulseglowworld" [
  defuniformparam "glowcolor" 1 1 1 // glow color
  defuniformparam "pulseglowspeed" 1 // pulse frequency (Hz)
  defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
  worldshader "pulseglowworld" [
    pulse = mix(glowcolor.rgb, pulseglowcolor.rgb, abs(fract(millis * pulseglowspeed.x)*2.0 - 1.0));
  ] [] [
    vec3 glow = texture2D(glowmap, gl_TexCoord[0].xy).rgb;
    gl_FragData[2].rgb = glow*pulse;
  ] [uniform float millis; varying vec3 pulse;] [uniform sampler2D glowmap;]
]

defershader 3 "envworld" [
  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
  worldshader "envworld" [
    camvec = camera - gl_Vertex.xyz; 
  ] [
    vec3 reflect = textureCube(envmap, 2.0*normal*dot(camvec, normal) - camvec).rgb;
  ] [
    gl_FragData[0].rgb *= 1.0-envscale.x;
    gl_FragData[2].rgb = reflect*(0.5*envscale.x);
  ] [uniform vec3 camera; varying vec3 camvec;] [uniform samplerCube envmap;]

  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
  worldshader "envworldfast" [
    vec3 camvec = camera - gl_Vertex.xyz;
    rvec = 2.0*gl_Normal*dot(camvec, gl_Normal) - camvec;
  ] [
    vec3 reflect = textureCube(envmap, rvec).rgb;
  ] [
    gl_FragData[0].rgb *= 1.0-envscale.x;
    gl_FragData[2].rgb = reflect*(0.5*envscale.x);
  ] [uniform vec3 camera; varying vec3 rvec;] [uniform samplerCube envmap;]

  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
  worldshader "envworldalt" [] []

  altshader envworld envworldalt
  fastshader envworld envworldfast 2
  fastshader envworld envworldalt 1
]

// bumptype:
//    e -> reserve envmap texture slot
//    o -> orthonormalize
//    t -> tangent space cam
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    p -> parallax
//    P -> steep parallax (7 steps)
//    g -> glow
//    G -> pulse glow
//    b -> blendmap
//    a -> refractive

btopt = [ >= (strstr $bumptype $arg1) 0 ]

bumpvariantshader = [
    bumptype = $arg2
    stype = (? (btopt "e") 3 1)
    srow = -1
    if (btopt "G") [
        stype = (+ $stype 0x10)
        defuniformparam "glowcolor" 1 1 1 // glow color
        defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
        defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
    ] [if (btopt "g") [
        defuniformparam "glowcolor" 1 1 1  // glow color
    ]]
    if (btopt "S") [
        defuniformparam "specscale" 6 6 6 // spec map multiplier
    ] [if (btopt "s") [
        defuniformparam "specscale" 1 1 1 // spec multiplier
    ]]
    if (|| (btopt "p") (btopt "P")) [
        defuniformparam "parallaxscale" 0.06 -0.03 // parallax scaling
    ]
    if (btopt "R") [
        defuniformparam "envscale" 1 1 1 // reflectivity map multiplier
    ] [if (btopt "r") [
        defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
    ]]
    if (btopt "b") [
        srow = 0
    ]
    if (btopt "a") [
        stype = (+ $stype 4)
        srow = 1
    ]
    variantshader $stype $arg1 $srow [
        uniform vec2 texgenscroll;
        varying mat3 world;
        @(gdepthinterp (|| $msaasamples [btopt "a"]))
        @(if (|| (btopt "t") (btopt "r")) [result [uniform vec3 camera;]])
        @(if (btopt "t") [result [varying vec3 camvects;]])
        @(if (btopt "r") [result [varying vec3 camvecw;]])
        @(if (btopt "G") [result [uniform float millis; varying float pulse;]])
        @(if (btopt "b") [result [uniform vec4 blendmapparams;]])

        void main(void)
        {
            gl_Position = ftransform();
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texgenscroll;

            @(gdepthpackvert (|| $msaasamples [btopt "a"]))

            @(if (btopt "b") [result [
                gl_TexCoord[1].xy = (gl_Vertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ]])

            vec4 tangent = gl_Color*2.0 - 1.0;
            vec3 binormal = cross(gl_Normal, tangent.xyz) * tangent.w;
            // calculate tangent -> world transform
            world = mat3(tangent.xyz, binormal, gl_Normal);
       
            @(if (btopt "t") [result [camvects = (camera - gl_Vertex.xyz) * world; ]])
            @(if (btopt "r") [result [camvecw = camera - gl_Vertex.xyz;]])

            @(if (btopt "G") [result [
                pulse = abs(fract(millis*pulseglowspeed.x)*2.0 - 1.0);
            ]])
        }
    ] [
        @(if (btopt "a") [result [
            @(gfetchdefs [refractlight refractmask])
            uniform vec4 refractparams;
            uniform float refractdepth;
        ]])
        uniform vec4 colorparams;
        uniform sampler2D diffusemap, normalmap;
        @(? $msaasamples [uniform float hashid;])
        varying mat3 world;
        @(gdepthinterp (|| $msaasamples [btopt "a"]))
        @(if (btopt "t") [result [varying vec3 camvects;]])
        @(if (btopt "g") [result [uniform sampler2D glowmap;]])
        @(if (btopt "G") [result [varying float pulse;]])
        @(if (btopt "r") [result [uniform samplerCube envmap; varying vec3 camvecw;]])
        @(if (btopt "b") [result [
            uniform float blendlayer;
            uniform sampler2D blendmap;
        ]])

        void main(void)
        {
            @(if (btopt "t") [result [vec3 camdirts = normalize(camvects);]])
            @(if (btopt "p") [result [
                float height = texture2D(normalmap, gl_TexCoord[0].xy).a;
                vec2 dtc = gl_TexCoord[0].xy + camdirts.xy*(height*parallaxscale.x + parallaxscale.y);
            ]])
            @(if (btopt "P") [result [
                const float step = -1.0/7.0;
                vec3 duv = vec3((step*parallaxscale.x/camdirts.z)*camdirts.xy, step);
                vec3 htc = vec3(gl_TexCoord[0].xy + duv.xy*parallaxscale.y, 1.0);
                vec4 height = texture2D(normalmap, htc.xy);
                @@(loopconcat i 7 [concatword [
                    htc += height.w < htc.z ? duv : vec3(0.0);
                    height = texture2D(normalmap, htc.xy);
                ]])
                #define dtc htc.xy
                #define bump height.xyz    
            ]])
            @(if (|| (btopt "p") (btopt "P")) [] [result [#define dtc gl_TexCoord[0].xy]])

            vec4 diffuse = texture2D(diffusemap, dtc);

            @(if (btopt "a") [result [
                #define alpha 1.0
            ]] [result [
                #define alpha colorparams.a
            ]])

            gl_FragData[0].rgb = diffuse.rgb*colorparams.rgb;
            @(if (btopt "s") [
                if (btopt "S") [result [
                    gl_FragData[0].a = diffuse.a*specscale.x * 0.5;
                ]] [result [
                    gl_FragData[0].a = specscale.x * 0.5;
                ]]
            ] [result [
                gl_FragData[0].a = 0.0;
            ]])

            @(if (! (btopt "P")) [result [vec3 bump = texture2D(normalmap, dtc).rgb;]])

            bump = bump*2.0 - 1.0;
            vec3 bumpw = world * bump;
            gl_FragData[1].rgb = bumpw*0.5 + 0.5;

            @(if (btopt "g") [result [
                vec3 glow = texture2D(glowmap, dtc).rgb;
                @(if (btopt "G") [result [
                    vec3 pulsecol = mix(glowcolor.xyz, pulseglowcolor.xyz, pulse);
                ]])
                glow *= @(? (btopt "G") "pulsecol" "glowcolor.xyz"); 
                gl_FragData[2].rgb = glow;
            ]] [result [
                gl_FragData[2].rgb = vec3(0.0);
            ]])
 
            @(if (btopt "r") [result [
                vec3 camvecwn = normalize(camvecw);
                float invfresnel = dot(camvecwn, bumpw);
                vec3 rvec = 2.0*bumpw*invfresnel - camvecwn;
                vec3 reflect = textureCube(envmap, rvec).rgb;
                @(if (btopt "R") [result [
                    float rmod = envscale.x*diffuse.a;
                ]] [result [
                    #define rmod envscale.x
                ]])
                gl_FragData[0].rgb = mix(gl_FragData[0].rgb, reflect, rmod*clamp(1.0 - invfresnel, 0.0, 1.0));
            ]])

            @(if (btopt "a") [result [
                vec2 rtc = bump.xy*refractparams.w;
                float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(refractmask, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
                vec3 rlight = gfetch(refractlight, gl_FragCoord.xy + rtc*rmask).rgb;
                gl_FragData[2].rgb += rlight * refractparams.xyz;
            ]])

            @(gdepthpackfrag $msaasamples "" hashid)

            @(if (btopt "b") [result [
                float blend = abs(texture2D(blendmap, gl_TexCoord[1].xy).r - blendlayer);
                gl_FragData[0] *= blend;
                gl_FragData[1].rgb *= blend;
                gl_FragData[1].a *= blendlayer;
                gl_FragData[2].rgb *= blend;
                gl_FragData[2].a = blendlayer;
            ]] [result [
                gl_FragData[2].a = alpha;
            ]])
        }
    ]
]

bumpshader = [
    defershader (? (>= (strstr $arg2 "e") 0) 3 1) $arg1 [
        bumpvariantshader @arg1 @arg2
        bumpvariantshader @arg1 @(concatword $arg2 "b")
        bumpvariantshader @arg1 @(concatword $arg2 "a")
    ]
]

bumpshader "bumpworld" ""
bumpshader "bumpspecworld" "ots"
fastshader bumpspecworld bumpworld 2
altshader bumpspecworld bumpworld
bumpshader "bumpspecmapworld" "otsS"
fastshader bumpspecmapworld bumpworld 2
altshader bumpspecmapworld bumpworld

bumpshader "bumpglowworld" "g"
bumpshader "bumpspecglowworld" "otsg"
altshader bumpspecglowworld bumpglowworld
bumpshader "bumpspecmapglowworld" "otsSg"
fastshader bumpspecmapglowworld bumpglowworld 2
altshader bumpspecmapglowworld bumpglowworld

bumpshader "bumppulseglowworld" "gG"
bumpshader "bumpspecpulseglowworld" "otsgG"
altshader bumpspecpulseglowworld bumppulseglowworld
bumpshader "bumpspecmappulseglowworld" "otsSgG"
fastshader bumpspecmappulseglowworld bumppulseglowworld 2
altshader bumpspecmappulseglowworld bumppulseglowworld

bumpshader "bumpparallaxworld" "pot"
fastshader bumpparallaxworld bumpworld 1
altshader bumpparallaxworld bumpworld
bumpshader "bumpspecparallaxworld" "pots"
fastshader bumpspecparallaxworld bumpparallaxworld 2
fastshader bumpspecparallaxworld bumpworld 1
altshader bumpspecparallaxworld bumpworld
bumpshader "bumpspecmapparallaxworld" "potsS"
fastshader bumpspecmapparallaxworld bumpparallaxworld 2
fastshader bumpspecmapparallaxworld bumpworld 1
altshader bumpspecmapparallaxworld bumpworld

bumpshader "bumpparallaxglowworld" "potg"
fastshader bumpparallaxglowworld bumpglowworld 1
altshader bumpparallaxglowworld bumpglowworld
bumpshader "bumpspecparallaxglowworld" "potsg"
fastshader bumpspecparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecparallaxglowworld bumpglowworld 1
altshader bumpspecparallaxglowworld bumpglowworld
bumpshader "bumpspecmapparallaxglowworld" "potsSg"
fastshader bumpspecmapparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecmapparallaxglowworld bumpglowworld 1
altshader bumpspecmapparallaxglowworld bumpglowworld

bumpshader "bumpparallaxpulseglowworld" "potgG"
fastshader bumpparallaxpulseglowworld bumppulseglowworld 1
altshader bumpparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecparallaxpulseglowworld" "potsgG"
fastshader bumpspecparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecmapparallaxpulseglowworld" "potsSgG"
fastshader bumpspecmapparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecmapparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecmapparallaxpulseglowworld bumppulseglowworld

bumpshader "bumpenvworldalt" "e"
bumpshader "bumpenvworld" "eor"
altshader bumpenvworld bumpenvworldalt
fastshader bumpenvworld bumpenvworldalt 2
bumpshader "bumpenvspecworld" "eotsr"
altshader bumpenvspecworld bumpenvworldalt
fastshader bumpenvspecworld bumpenvworldalt 2
bumpshader "bumpenvspecmapworld" "eotsSrR"
altshader bumpenvspecmapworld bumpenvworldalt
fastshader bumpenvspecmapworld bumpenvworldalt 2

bumpshader "bumpenvglowworldalt" "eg"
bumpshader "bumpenvglowworld" "eorg"
altshader bumpenvglowworld bumpenvglowworldalt
fastshader bumpenvglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecglowworld" "eotsrg"
altshader bumpenvspecglowworld bumpenvglowworldalt
fastshader bumpenvspecglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecmapglowworld" "eotsSrRg"
altshader bumpenvspecmapglowworld bumpenvglowworldalt
fastshader bumpenvspecmapglowworld bumpenvglowworldalt 2

bumpshader "bumpenvpulseglowworldalt" "egG"
bumpshader "bumpenvpulseglowworld" "eorgG"
altshader bumpenvpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecpulseglowworld" "eotsrgG"
altshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecmappulseglowworld" "eotsSrRgG"
altshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt 2

bumpshader "bumpenvparallaxworldalt" "epot"
altshader bumpenvparallaxworldalt bumpenvworldalt
bumpshader "bumpenvparallaxworld" "epotr"
altshader bumpenvparallaxworld bumpenvparallaxworldalt
fastshader bumpenvparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecparallaxworld" "epotsr"
altshader bumpenvspecparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecmapparallaxworld" "epotsSrR"
altshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecmapparallaxworld bumpenvworldalt 1

bumpshader "bumpenvparallaxglowworldalt" "epotg"
altshader bumpenvparallaxglowworldalt bumpenvglowworldalt
bumpshader "bumpenvparallaxglowworld" "epotrg"
altshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecparallaxglowworld" "epotsrg"
altshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecmapparallaxglowworld" "epotsSrRg"
altshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecmapparallaxglowworld bumpenvglowworldalt 1

bumpshader "bumpenvparallaxpulseglowworldalt" "epotgG"
altshader bumpenvparallaxpulseglowworldalt bumpenvpulseglowworldalt
bumpshader "bumpenvparallaxpulseglowworld" "epotrgG"
altshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt
fastshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt 2
fastshader bumpenvparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecparallaxpulseglowworld" "epotsrgG"
altshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecmapparallaxpulseglowworld" "epotsSrRgG"
altshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvpulseglowworldalt 1

//bumpshader "steepworld" "Pot"

shader 0 shadowmapworld [
    void main(void)
    {
        gl_Position = ftransform();
    }
] [
    void main(void)
    {
    }
]

loop i 2 [
    variantshader 1 "rsmworld" (- $i 1) [
        uniform vec2 texgenscroll;
        uniform vec4 colorparams;
        uniform vec3 rsmdir;
        varying vec4 normal;
        @(if (= $i 1) [result [uniform vec4 blendmapparams;]])
        void main(void)
        {
            gl_Position = ftransform();
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texgenscroll;
            @(if (= $i 1) [result [
                gl_TexCoord[1].xy = (gl_Vertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ]])
            normal = vec4(gl_Normal, dot(gl_Normal, rsmdir));
        }
    ] [
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        varying vec4 normal;
        @(if (= $i 1) [result [
            uniform float blendlayer;
            uniform sampler2D blendmap;
        ]])
        void main(void)
        {
            vec4 diffuse = texture2D(diffusemap, gl_TexCoord[0].xy);   

            @(if (= $i 2) [result [
                #define alpha 1.0
            ]] [result [
                #define alpha colorparams.a
            ]])

            gl_FragData[0].rgb = normal.w*diffuse.rgb*colorparams.rgb;
            gl_FragData[1] = vec4(normal.xyz*0.5+0.5, 0.0);

            @(if (= $i 1) [result [
                float blend = abs(texture2D(blendmap, gl_TexCoord[1].xy).r - blendlayer);
                gl_FragData[0].rgb *= blend;
                gl_FragData[0].a = blendlayer;
                gl_FragData[1] *= blend;
            ]] [result [
                gl_FragData[0].a = alpha;
            ]])
        }
    ]
]

shader 0 "rsmsky" [
    void main(void)
    {
        gl_Position = ftransform();
    }
] [
    void main(void)
    {
        gl_FragData[0] = vec4(0.0, 0.0, 0.0, 1.0);
        gl_FragData[1] = vec4(0.5, 0.5, 0.5, 0.0);
    }
]

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

// skeletal animation for matrices and dual quaternions

skelanimdefs = [
    result [
        #pragma CUBE2_attrib vweights 6
        #pragma CUBE2_attrib vbones 7
        attribute vec4 vweights; 
        attribute vec4 vbones;
        #pragma CUBE2_uniform animdata
        uniform vec4 animdata[@@(min $maxvsuniforms $maxskelanimdata)];
    ]
]

skelmatanim = [
    result [
        int index = int(vbones.x);
        @(if (= $arg1 1) [result [
            vec4 mx = animdata[index];
            vec4 my = animdata[index+1];
            vec4 mz = animdata[index+2];
        ]] [result [
            vec4 mx = animdata[index] * vweights.x;
            vec4 my = animdata[index+1] * vweights.x;
            vec4 mz = animdata[index+2] * vweights.x;
            index = int(vbones.y);
            mx += animdata[index] * vweights.y;
            my += animdata[index+1] * vweights.y;
            mz += animdata[index+2] * vweights.y;
        ]])
        @(if (>= $arg1 3) [result [
            index = int(vbones.z);
            mx += animdata[index] * vweights.z;
            my += animdata[index+1] * vweights.z;
            mz += animdata[index+2] * vweights.z;
        ]])
        @(if (>= $arg1 4) [result [
            index = int(vbones.w);
            mx += animdata[index] * vweights.w;
            my += animdata[index+1] * vweights.w;
            mz += animdata[index+2] * vweights.w;
        ]])

        vec4 opos = vec4(dot(mx, gl_Vertex), dot(my, gl_Vertex), dot(mz, gl_Vertex), gl_Vertex.w);

        @(if $arg2 [result [
            vec3 onormal = vec3(dot(mx.xyz, gl_Normal), dot(my.xyz, gl_Normal), dot(mz.xyz, gl_Normal));
        ]])

        @(if $arg3 [result [
            vec3 otangent = vec3(dot(mx.xyz, vtangent.xyz), dot(my.xyz, vtangent.xyz), dot(mz.xyz, vtangent.xyz));
        ]])
    ]
]

skelquatanim = [
    result [
        int index = int(vbones.x);
        @(if (= $arg1 1) [result [
            vec4 dqreal = animdata[index];
            vec4 dqdual = animdata[index+1];
        ]] [result [ 
            vec4 dqreal = animdata[index] * vweights.x;
            vec4 dqdual = animdata[index+1] * vweights.x;
            index = int(vbones.y);
            dqreal += animdata[index] * vweights.y;
            dqdual += animdata[index+1] * vweights.y;
            @(if (>= $arg1 3) [result [
                index = int(vbones.z);
                dqreal += animdata[index] * vweights.z;
                dqdual += animdata[index+1] * vweights.z;
            ]])
            @(if (>= $arg1 4) [result [
                index = int(vbones.w);
                dqreal += animdata[index] * vweights.w;
                dqdual += animdata[index+1] * vweights.w;
            ]])
            float len = length(dqreal);
            dqreal /= len;
            dqdual /= len;
        ]])

        vec4 opos = vec4((cross(dqreal.xyz, cross(dqreal.xyz, gl_Vertex.xyz) + gl_Vertex.xyz*dqreal.w + dqdual.xyz) + dqdual.xyz*dqreal.w - dqreal.xyz*dqdual.w)*2.0 + gl_Vertex.xyz, gl_Vertex.w);

        @(if $arg2 [result [
            vec3 onormal = cross(dqreal.xyz, cross(dqreal.xyz, gl_Normal) + gl_Normal*dqreal.w)*2.0 + gl_Normal;
        ]])

        @(if $arg3 [result [
            vec3 otangent = cross(dqreal.xyz, cross(dqreal.xyz, vtangent.xyz) + vtangent.xyz*dqreal.w)*2.0 + vtangent.xyz;
        ]])
    ]
]

// mdltype:
//    a -> alpha test
//    B -> matrix skeletal animation
//    b -> dual-quat skeletal animation

mdlopt = [ >= (strstr $modeltype $arg1) 0 ]

shadowmodelvertexshader = [
    modeltype = $arg1
    result [
        @(if (|| (mdlopt "b") (mdlopt "B")) [skelanimdefs $arg2 0 0])
        @(if (mdlopt "a") [result [
            uniform vec2 texscroll;
        ]])
        void main(void)
        {
            @(if (mdlopt "B") [skelmatanim $arg2 0 0])
            @(if (mdlopt "b") [skelquatanim $arg2 0 0])
            @(if (|| (mdlopt "b") (mdlopt "B")) [result [
                gl_Position = gl_ModelViewProjectionMatrix * opos;
            ]] [result [
                gl_Position = ftransform();
            ]])
            @(if (mdlopt "a") [result [
                gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texscroll;
            ]])
        }
    ]
]

shadowmodelfragmentshader = [
    modeltype = $arg1
    result [
        @(if (mdlopt "a") [result [
            uniform sampler2D tex0;
            uniform float alphatest;
        ]])
        void main(void)
        {
            @(if (mdlopt "a") [result [
                vec4 color = texture2D(tex0, gl_TexCoord[0].xy);
                if(color.a <= alphatest)    
                    discard;
                gl_FragColor = vec4(color.rgb, 1.0);
            ]])
        }
    ]
]

shadowmodelshader = [
    shader 0 $arg1 (shadowmodelvertexshader $arg2) (shadowmodelfragmentshader $arg2)
    loop i 4 [
        variantshader 0 $arg1 0 (shadowmodelvertexshader (concatword $arg2 "B") (+ $i 1)) []
        variantshader 1 $arg1 1 (shadowmodelvertexshader (concatword $arg2 "b") (+ $i 1)) []
    ]
]

shadowmodelshader "shadowmodel" ""
shadowmodelshader "alphashadowmodel" "a"

// mdltype:
//    a -> alpha test
//    e -> envmap
//    n -> normalmap
//    m -> masks
//    d -> decal
//    B -> matrix skeletal animation
//    b -> dual-quat skeletal animation

modelvertexshader = [
    modeltype = $arg1
    result [
        @(if (|| (mdlopt "b") (mdlopt "B")) [skelanimdefs $arg2 1 (mdlopt "n")])
        @(if (mdlopt "n") [result [
            #pragma CUBE2_attrib vtangent 1
            attribute vec4 vtangent;
        ]])
        uniform mat3 oworld;
        uniform vec3 ocamera;
        uniform vec2 texscroll;
        @(if (mdlopt "n") [result [
            varying mat3 world;
            @(if (mdlopt "e") [result [
                varying vec3 camvec;
            ]])
        ]] [result [
            varying vec3 nvec;
            @(if (mdlopt "e") [result [
                uniform vec2 envmapscale;
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        @(msaainterp)

        void main(void)
        {
            @(if (mdlopt "B") [skelmatanim $arg2 1 (mdlopt "n")])
            @(if (mdlopt "b") [skelquatanim $arg2 1 (mdlopt "n")])
            @(if (|| (mdlopt "b") (mdlopt "B")) [result [
                gl_Position = gl_ModelViewProjectionMatrix * opos;
            ]] [result [
                gl_Position = ftransform();
                #define opos gl_Vertex
                #define onormal gl_Normal
                #define otangent vtangent.xyz
            ]])

            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texscroll;
    
            @(msaapackvert)
 
            @(if (mdlopt "e") [result [
                vec3 camdir = normalize(ocamera - opos.xyz);
            ]])

            @(if (mdlopt "n") [result [
                @(if (mdlopt "e") [result [
                    camvec = oworld * camdir;
                ]])
                // composition of tangent -> object and object -> world transforms
                //   becomes tangent -> world
                vec3 wnormal = oworld * onormal;
                vec3 wtangent = oworld * otangent;
                vec3 wbitangent = cross(wnormal, wtangent) * vtangent.w;
                world = mat3(wtangent, wbitangent, wnormal);
            ]] [result [
                nvec = oworld * onormal; 
                @(if (mdlopt "e") [result [
                    float invfresnel = dot(camdir, onormal);
                    rvec = oworld * (2.0*invfresnel*onormal - camdir);
                    rmod = envmapscale.x*max(invfresnel, 0.0) + envmapscale.y;    
                ]])
            ]])
        }
    ] 
]

modelfragmentshader = [
    modeltype = $arg1
    result [
        @(if (mdlopt "n") [result [
            varying mat3 world; 
            @(if (mdlopt "e") [result [
                uniform vec2 envmapscale;
                varying vec3 camvec;
            ]])
        ]] [result [
            varying vec3 nvec;
            @(if (mdlopt "e") [result [
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        uniform vec2 fullbright;
        uniform vec2 maskscale;
        @(if (mdlopt "a") [result [uniform float alphatest;]])
        uniform sampler2D tex0;
        @(if (mdlopt "m") [result [uniform sampler2D tex1;]])
        @(if (mdlopt "e") [result [uniform samplerCube tex2;]])
        @(if (mdlopt "n") [result [uniform sampler2D tex3;]])
        @(if (mdlopt "d") [result [uniform sampler2D tex4;]])
        @(msaainterp)
        uniform float aamask;

        void main(void)
        {
            vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);

            @(if (mdlopt "a") [result [
                if(diffuse.a <= alphatest)
                    discard;
            ]])
            
            gl_FragData[0].rgb = diffuse.rgb;

            @(if (mdlopt "d") [result [
                vec4 decal = texture2D(tex4, gl_TexCoord[0].xy);
                gl_FragData[0].rgb = mix(gl_FragData[0].rgb, decal.rgb, decal.a);
            ]])

            @(if (mdlopt "m") [result [
                vec3 masks = texture2D(tex1, gl_TexCoord[0].xy).rgb;
            ]])

            float spec = maskscale.x;
            @(if (mdlopt "m") [result [spec *= masks.r;]])   // specmap in red channel
            gl_FragData[0].a = 0.5*spec;

            @(if (mdlopt "n") [result [
                vec3 normal = texture2D(tex3, gl_TexCoord[0].xy).rgb - 0.5;
                normal = normalize(world * normal);
            ]] [result [
                vec3 normal = normalize(nvec);
            ]])

            gl_FragData[1].rgb = 0.5*normal+0.5;

            @(if (mdlopt "m") [result [
                float gmask = max(maskscale.y*masks.g, fullbright.y); // glow mask in green channel
                gl_FragData[2].rgb = diffuse.rgb*gmask;
                gl_FragData[0].rgb *= fullbright.x-gmask;
                @(if (mdlopt "e") [result [
                    @(if (mdlopt "n") [result [
                        vec3 camn = normalize(camvec);
                        float invfresnel = dot(camn, normal);
                        vec3 rvec = 2.0*invfresnel*normal - camn;
                        float rmod = envmapscale.x*clamp(invfresnel, 0.0, 1.0) + envmapscale.y;
                    ]])
                    float rmask = rmod*masks.b; // envmap mask in blue channel
                    vec3 reflect = textureCube(tex2, rvec).rgb;
                    gl_FragData[0].rgb = mix(gl_FragData[0].rgb, reflect, rmask);
                ]])
            ]] [result [
                gl_FragData[2].rgb = diffuse.rgb*fullbright.y;
                gl_FragData[0].rgb *= fullbright.x-fullbright.y;
            ]])

            gl_FragData[2].a = 1.0;
 
            @(msaapackfrag aamask)
        }
    ]
]

modelshader = [
    defershader 0 $arg1 [
        basemodeltype = [@@arg2]
        shader 0 @arg1 (modelvertexshader $basemodeltype) (modelfragmentshader $basemodeltype)
        loop i 4 [
            variantshader 0 @@arg1 0 (modelvertexshader (concatword "B" $basemodeltype) (+ $i 1)) []
            variantshader 0 @@arg1 1 (modelvertexshader (concatword "b" $basemodeltype) (+ $i 1)) []
        ]
    ]
]

modelshader "stdmodel" ""
modelshader "masksmodel" "m"
modelshader "envmapmodel" "me"
altshader envmapmodel masksmodel

modelshader "bumpmodel" "n"
modelshader "bumpmasksmodel" "nm"
modelshader "bumpenvmapmodel" "nme"
altshader bumpenvmapmodel bumpmasksmodel

modelshader "alphamodel" "a"
modelshader "masksalphamodel" "am"
modelshader "envmapalphamodel" "ame"
altshader envmapalphamodel masksalphamodel

modelshader "bumpalphamodel" "an"
modelshader "bumpmasksalphamodel" "anm"
modelshader "bumpenvmapalphamodel" "anme"
altshader bumpenvmapalphamodel bumpmasksalphamodel

modelshader "decalmodel" "d"
modelshader "decalmasksmodel" "dm"
modelshader "decalenvmapmodel" "dme"
altshader decalenvmapmodel decalmasksmodel

modelshader "decalbumpmodel" "dn"
modelshader "decalbumpmasksmodel" "dnm"
modelshader "decalbumpenvmapmodel" "dnme"
altshader decalbumpenvmapmodel decalbumpmasksmodel

modelshader "decalalphamodel" "da"
modelshader "decalmasksalphamodel" "dam"
modelshader "decalenvmapalphamodel" "dame"
altshader decalenvmapalphamodel decalmasksalphamodel

modelshader "decalbumpalphamodel" "dan"
modelshader "decalbumpmasksalphamodel" "danm"
modelshader "decalbumpenvmapalphamodel" "danme"
altshader decalbumpenvmapalphamodel decalbumpmasksalphamodel

rsmmodelvertexshader = [
    modeltype = $arg1
    result [
        @(if (|| (mdlopt "b") (mdlopt "B")) [skelanimdefs $arg2 1 0])
        uniform mat3 oworld;
        uniform vec2 texscroll;
        uniform vec3 rsmdir;
        varying vec4 normal;
        varying float facing;
        void main(void)
        {
            @(if (mdlopt "B") [skelmatanim $arg2 1 (mdlopt "n")])
            @(if (mdlopt "b") [skelquatanim $arg2 1 (mdlopt "n")])
            @(if (|| (mdlopt "b") (mdlopt "B")) [result [
                gl_Position = gl_ModelViewProjectionMatrix * opos;
            ]] [result [
                gl_Position = ftransform();
                #define opos gl_Vertex
                #define onormal gl_Normal
            ]])
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texscroll;
            normal.xyz = oworld * onormal;
            normal.w = dot(normal.xyz, rsmdir);
        }
    ]
]

rsmmodelfragmentshader = [
    modeltype = $arg1
    result [
        varying vec4 normal;
        uniform vec2 fullbright;
        @(if (mdlopt "a") [result [uniform float alphatest;]])
        uniform sampler2D tex0;
        void main(void)
        {
            vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);
            @(if (mdlopt "a") [result [
                if(diffuse.a <= alphatest)
                    discard;
            ]])
            gl_FragData[0] = vec4(normal.w*diffuse.rgb, 1.0);
            gl_FragData[1] = vec4(normal.xyz*0.5+0.5, 0.0);
        }
    ]
]

rsmmodelshader = [
    shader 0 $arg1 (rsmmodelvertexshader $arg2) (rsmmodelfragmentshader $arg2)
    loop i 4 [
        variantshader 0 $arg1 0 (rsmmodelvertexshader (concatword "B" $arg2) (+ $i 1)) []
        variantshader 0 $arg1 1 (rsmmodelvertexshader (concatword "b" $arg2) (+ $i 1)) []
    ]
]

rsmmodelshader "rsmmodel" ""
rsmmodelshader "rsmalphamodel "a"

rhtapoffsets12 = [
"0.0565813, 0.61211, 0.763359"
"0.375225, 0.285592, 0.987915"
"0.615192, 0.668996, 0.604938"
"0.963195, 0.355937, 0.175787"
"0.0295724, 0.484268, 0.265694"
"0.917783, 0.88702, 0.201972"
"0.408948, 0.0675985, 0.427564"
"0.19071, 0.923612, 0.0553606"
"0.968078, 0.403943, 0.847224"
"0.384503, 0.922269, 0.990844"
"0.480605, 0.342418, 0.00195318"
"0.956664, 0.923643, 0.915799"
]

rhtapoffsets20 = [
"0.0540788, 0.411725, 0.134068"
"0.0163579, 0.416211, 0.992035"
"0.692068, 0.549272, 0.886502"
"0.305795, 0.781854, 0.571337"
"0.791681, 0.139042, 0.247047"
"0.83929, 0.973663, 0.460982"
"0.0336314, 0.0867641, 0.582324"
"0.148198, 0.961974, 0.0378124"
"0.948729, 0.0713828, 0.916379"
"0.586413, 0.591845, 0.031251"
"0.00189215, 0.973968, 0.932981"
"0.435865, 0.0853603, 0.995148"
"0.36848, 0.820612, 0.942717"
"0.500107, 0.0658284, 0.623005"
"0.580187, 0.4485, 0.379223"
"0.258614, 0.0201422, 0.241005"
"0.987152, 0.441664, 0.43318"
"0.925108, 0.917203, 0.921506"
"0.988372, 0.822047, 0.12479"
"0.330393, 0.43611, 0.762566"
]

rhtapoffsets32 = [
"0.0553911, 0.675924, 0.22129"
"0.562975, 0.508286, 0.549883"
"0.574816, 0.703452, 0.0513016"
"0.981017, 0.930479, 0.243873"
"0.889309, 0.133091, 0.319071"
"0.329112, 0.00759911, 0.472213"
"0.314463, 0.985839, 0.54442"
"0.407697, 0.202643, 0.985748"
"0.998169, 0.760369, 0.792932"
"0.0917692, 0.0666829, 0.0169683"
"0.0157781, 0.632954, 0.740806"
"0.938139, 0.235878, 0.87936"
"0.442305, 0.184942, 0.0901212"
"0.578051, 0.863948, 0.799554"
"0.0698569, 0.259194, 0.667592"
"0.872494, 0.576312, 0.344157"
"0.10123, 0.930082, 0.959929"
"0.178594, 0.991302, 0.046205"
"0.690176, 0.527543, 0.930509"
"0.982025, 0.389447, 0.0344554"
"0.033845, 0.0156865, 0.963866"
"0.655293, 0.154271, 0.640553"
"0.317881, 0.598621, 0.97998"
"0.247261, 0.398206, 0.121586"
"0.822626, 0.985076, 0.655232"
"0.00201422, 0.434278, 0.388348"
"0.511399, 0.977416, 0.278695"
"0.32371, 0.540147, 0.361187"
"0.365856, 0.41493, 0.758232"
"0.792871, 0.979217, 0.0309763"
"0.0509049, 0.459151, 0.996277"
"0.0305185, 0.13422, 0.306009"
]

rsmtapoffsets12 = [
"0.031084, 0.572114"
"0.040671, 0.95653"
"0.160921, 0.367819"
"0.230518, 0.134321"
"0.247078, 0.819415"
"0.428665, 0.440522"
"0.49846, 0.80717"
"0.604285, 0.0307766"
"0.684075, 0.283001"
"0.688304, 0.624171"
"0.833995, 0.832414"
"0.975397, 0.189911"
]

rsmtapoffsets20 = [
"0.00240055, 0.643992"
"0.0356464, 0.851616"
"0.101733, 0.21876"
"0.166119, 0.0278085"
"0.166438, 0.474999"
"0.24991, 0.766405"
"0.333714, 0.130407"
"0.400681, 0.374781"
"0.424067, 0.888211"
"0.448511, 0.678962"
"0.529383, 0.213568"
"0.608569, 0.47715"
"0.617996, 0.862528"
"0.631784, 0.0515881"
"0.740969, 0.20753"
"0.788203, 0.41923"
"0.794066, 0.615141"
"0.834504, 0.836612"
"0.89446, 0.0677863"
"0.975609, 0.446056"
]

rsmtapoffsets32 = [
"0.0262032, 0.215221"
"0.0359769, 0.0467256"
"0.0760799, 0.713481"
"0.115087, 0.461431"
"0.119488, 0.927444"
"0.22346, 0.319747"
"0.225964, 0.679227"
"0.238626, 0.0618425"
"0.243326, 0.535066"
"0.29832, 0.90826"
"0.335208, 0.212103"
"0.356438, 0.751969"
"0.401021, 0.478664"
"0.412027, 0.0245297"
"0.48477, 0.320659"
"0.494311, 0.834621"
"0.515007, 0.165552"
"0.534574, 0.675536"
"0.585357, 0.432483"
"0.600102, 0.94139"
"0.650182, 0.563571"
"0.672336, 0.771816"
"0.701811, 0.187078"
"0.734207, 0.359024"
"0.744775, 0.924466"
"0.763628, 0.659075"
"0.80735, 0.521281"
"0.880585, 0.107684"
"0.898505, 0.904047"
"0.902536, 0.718989"
"0.928022, 0.347802"
"0.971243, 0.504885"
]

radiancehintsshader = [
  numtaps = (cond [> $arg1 20] 32 [> $arg1 12] 20 12)
  shader 0 [radiancehints@arg1] [
    uniform mat4 rsmtcmatrix;
    varying vec3 rhcenter;
    varying vec2 rsmcenter;
    void main(void)
    {
        gl_Position = gl_Vertex;
        rhcenter = gl_MultiTexCoord0.xyz;
        rsmcenter = (rsmtcmatrix * gl_MultiTexCoord0).xy;
    }
  ] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0, tex1, tex2; 
    uniform mat4 rsmworldmatrix;
    uniform vec2 rsmspread;
    uniform float rhatten, rhspread;
    varying vec3 rhcenter;
    varying vec2 rsmcenter;

    void calcrhsample(vec3 rhtap, vec2 rsmtap, inout vec4 shr, inout vec4 shg, inout vec4 shb)
    {
        vec3 rhpos = rhcenter + rhtap*rhspread;
        vec2 rsmtc = rsmcenter + rsmtap*rsmspread;
        float rsmdepth = texture2DRect(tex0, rsmtc).x;
        vec3 rsmcolor = texture2DRect(tex1, rsmtc).rgb;
        vec3 rsmnormal = texture2DRect(tex2, rsmtc).xyz*2.0 - 1.0;
        vec3 rsmpos = (rsmworldmatrix * vec4(rsmtc, rsmdepth, 1.0)).xyz;

        vec3 dir = rhpos - rsmpos;
        float dist = dot(dir, dir);
        if(dist > 0.000049) dir = normalize(dir);
        float atten = clamp(dot(dir, rsmnormal), 0.0, 1.0) / (0.1 + dist*rhatten);
        rsmcolor *= atten;

        shr += vec4(rsmcolor.r*dir, rsmcolor.r);
        shg += vec4(rsmcolor.g*dir, rsmcolor.g);
        shb += vec4(rsmcolor.b*dir, rsmcolor.b);
    }

    void main(void)
    {
        vec4 shr = vec4(0.0), shg = vec4(0.0), shb = vec4(0.0);

        @(loopconcat i $numtaps [result [
            calcrhsample(vec3(@(at $[rhtapoffsets@numtaps] $i))*2.0 - 1.0, vec2(@(at $[rsmtapoffsets@numtaps] $i))*2.0 - 1.0, shr, shg, shb);
        ]])

        gl_FragData[0] = shr * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
        gl_FragData[1] = shg * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
        gl_FragData[2] = shb * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
    }
  ]
]

lazyshader 0 radiancehintsborder [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xyz = gl_MultiTexCoord0.xyz;
    }
] [
    uniform sampler3D tex3, tex4, tex5;
    uniform vec3 bordercenter, borderrange, borderscale;
    void main(void)
    {
        float outside = clamp(borderscale.z*(abs(gl_TexCoord[0].z - bordercenter.z) - borderrange.z), 0.0, 1.0);
        vec3 tc = vec3(gl_TexCoord[0].xy, clamp(gl_TexCoord[0].z, bordercenter.z - borderrange.z, bordercenter.z + borderrange.z));
        gl_FragData[0] = texture3D(tex3, tc);
        gl_FragData[1] = texture3D(tex4, tc);
        gl_FragData[2] = mix(texture3D(tex5, tc), vec4(0.5, 0.5, 0.5, 0.0), outside);
    }
]

lazyshader 0 radiancehintscached [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xyz = gl_MultiTexCoord0.xyz;
    }
] [
    uniform sampler3D tex6, tex7, tex8;
    void main(void)
    {
        gl_FragData[0] = texture3D(tex6, gl_TexCoord[0].xyz);
        gl_FragData[1] = texture3D(tex7, gl_TexCoord[0].xyz);
        gl_FragData[2] = texture3D(tex8, gl_TexCoord[0].xyz);
    }
]

////////////////////////////////////////////////
//
// deferred shading
//
////////////////////////////////////////////////

lazyshader 0 msaaresolve [
    void main(void)
    {
        gl_Position = gl_Vertex;
    }
] [
    #extension GL_ARB_texture_multisample : enable
    uniform sampler2DMS tex0;
    
    void main(void)
    {
        gl_FragColor = texelFetch(tex0, ivec2(gl_FragCoord.xy), 0);
    }
]

lazyshader 0 "msaareducew" [
    varying vec2 tap0, tap1;
    void main(void)
    {
        gl_Position = gl_Vertex;
        tap0 = gl_MultiTexCoord0.xy;
        tap1 = gl_MultiTexCoord0.xy + vec2(-1.0, 0.0);
    }
] [
    #extension GL_ARB_texture_multisample : enable
    uniform sampler2DMS tex0; 
    varying vec2 tap0, tap1;
    void main(void)
    {
        gl_FragColor = 0.5*(texelFetch(tex0, ivec2(tap0), 0) + texelFetch(tex0, ivec2(tap1), 0));
    }
]

lazyshader 0 "msaareduce" [
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_Position = gl_Vertex;
        tap0 = gl_MultiTexCoord0.xy;
        tap1 = gl_MultiTexCoord0.xy + vec2(-1.0,  0.0);
        tap2 = gl_MultiTexCoord0.xy + vec2( 0.0, -1.0);
        tap3 = gl_MultiTexCoord0.xy + vec2(-1.0, -1.0);
    }
] [
    #extension GL_ARB_texture_multisample : enable
    uniform sampler2DMS tex0; 
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_FragColor = 0.25*(texelFetch(tex0, ivec2(tap0), 0) + texelFetch(tex0, ivec2(tap1), 0) +
                             texelFetch(tex0, ivec2(tap2), 0) + texelFetch(tex0, ivec2(tap3), 0));
    }
]

lazyshader 0 msaaedgedetect [
    void main(void)
    {
        gl_Position = gl_Vertex;
    }
] [
    #extension GL_ARB_texture_multisample : enable
    uniform sampler2DMS tex0, tex1, tex2, tex3;

    void main(void)
    {
        vec4 e = texelFetch(tex1, ivec2(gl_FragCoord.xy), 0);
        e.xyz -= 0.5;
        float maxdiff = 0.98*0.98*dot(e.xyz, e.xyz); 
        @(loopconcat i (- $msaasamples 1) [result [
            vec4 e@i = texelFetch(tex1, ivec2(gl_FragCoord.xy), @(+ $i 1));
            e@i.xyz -= 0.5;
            if(abs(e.w-e@i.w) <= 4.0/255.0 && pow(dot(e@i.xyz, e.xyz), 2.0) >= maxdiff*dot(e@i.xyz, e@i.xyz))
            {
        ]])
                discard;
        @(loopconcat i (- $msaasamples 1) [result [
            }
        ]])
    }
]
    
// deferredlighttype:
//    p -> point-light shadow (default cubemap)
//    c -> CSM
//    a -> AO
//    A -> AO sun
//    r -> radiance hints
//    G -> 5x5 weighted gather filter
//    g -> 3x3 weighted gather filter
//    E -> 5x5 weighted bilinear filter
//    F -> 3x3 weighted bilinear filter
//    f -> 4x rotated grid filter
//    m -> minimap
//    M -> multisampled
//    R -> manual resolve
//    S -> sample shading
//    T -> manual resolve with edge detection
dlopt = [ >= (strstr $deferredlighttype $arg1) 0 ]

deferredlightvariantshader = [
    deferredlighttype = $arg3
    numsplits = (+ $arg4 0)
    numrh = (+ $arg5 0)
    numlights = (+ $arg6 0)
    baselight = (< (mod $arg2 4) 2)
    spotlight = (>= $arg2 4) 
    variantshader 0 $arg1 $arg2 (? (< $arg2 0) [
        void main(void)
        {
            gl_Position = ftransform();
        }
    ]) [
        #extension GL_ARB_texture_rectangle : enable
        @(if (dlopt "M") [result [
            #extension GL_ARB_texture_multisample : enable
            @(if (dlopt "S") [result [
                #extension GL_ARB_sample_shading : enable
            ]])
        ]])
        @(if (|| (dlopt "g") (dlopt "G")) [result [
            #ifdef GL_EXT_gpu_shader4
            #  extension GL_EXT_gpu_shader4 : enable
            #endif
            @(if (> $usetexgather 1) [result [
                #ifdef GL_ARB_gpu_shader5
                #  extension GL_ARB_gpu_shader5 : enable
                #endif
            ]])
            #ifdef GL_ARB_texture_gather
            #  extension GL_ARB_texture_gather : enable
            #else
            #  ifdef GL_AMD_texture_texture4
            #    extension GL_AMD_texture_texture4 : enable
            #  endif
            #endif
        ]])
        @(if (dlopt "M") [result [
            uniform sampler2DMS tex0, tex1, tex2, tex3;
        ]] [result [
            uniform sampler2DRect tex0, tex1, tex2, tex3;
        ]])
        @(if (|| (dlopt "p") (dlopt "c")) [
            if (|| (dlopt "g") (dlopt "G")) [if (> $usetexgather 1) [result [
                #if defined(GL_ARB_texture_gather) && defined(GL_ARB_gpu_shader5)
                    uniform sampler2DShadow tex4;
                #else
                    uniform sampler2D tex4;
                #endif
            ]] [result [
                uniform sampler2D tex4;
            ]]] [result [
                uniform sampler2DRectShadow tex4;
            ]]
        ])
        @(if $numlights [result [
            uniform vec4 lightpos[@@numlights];
            uniform vec3 lightcolor[@@numlights];
            @(if $spotlight [result [
                uniform vec4 spotparams[@@numlights];
            ]])
            @(if (dlopt "p") [result [
                @(if $spotlight [result [
                    uniform vec3 spotx[@@numlights];
                    uniform vec3 spoty[@@numlights];
                ]])
                uniform vec4 shadowparams[@@numlights];
                uniform vec2 shadowoffset[@@numlights];
            ]])
        ]])
        @(if $numsplits [result [
            uniform vec3 splitcenter[@@numsplits];
            uniform vec3 splitbounds[@@numsplits];
            uniform vec3 splitscale[@@numsplits];
            uniform vec3 splitoffset[@@numsplits];
        ]])
        @(if (dlopt "c") [result [
            uniform mat3 csmmatrix;
            uniform vec3 sunlightdir;
            uniform vec3 sunlightcolor;
            @(if (dlopt "r") [result [
                uniform float giscale, rhnudge;
                uniform vec4 rhbb[@@numrh];
                uniform vec3 rhscale[@@numrh];
                uniform vec3 rhoffset[@@numrh];
                uniform sampler3D tex6, tex7, tex8;
            ]])  
        ]])
        uniform vec3 camera;
        uniform mat4 worldmatrix;
        uniform vec4 fogdir;
        uniform vec3 fogcolor, fogparams;
        uniform vec2 shadowatlasscale;
        uniform vec4 lightscale;
        @(? (dlopt "a") [uniform sampler2DRect tex5; uniform vec2 aoscale; uniform vec4 aoparams;])
        @(gdepthunpackparams)

        @(if (dlopt "p") [
            if $spotlight [result [
                vec3 getspottc(vec3 dir, float spotdist, vec3 spotx, vec3 spoty, vec4 shadowparams, vec2 shadowoffset)
                {
                    vec2 mparams = shadowparams.xy / spotdist;
                    return vec3(vec2(dot(dir, spotx), dot(dir, spoty))*mparams.x + shadowoffset, mparams.y + shadowparams.w);
                }
            ]] [result [
                vec3 getshadowtc(vec3 dir, vec4 shadowparams, vec2 shadowoffset)
                {
                    vec3 adir = abs(dir);
                    float m = max(adir.x, adir.y);
                    vec2 mparams = shadowparams.xy / max(adir.z, m);
                    vec4 proj;
                    if(adir.x > adir.y) proj = vec4(dir.zyx, 0.0); else proj = vec4(dir.xzy, 1.0);
                    if(adir.z > m) proj = vec4(dir, 2.0);
                    return vec3(proj.xy * mparams.x + vec2(proj.w, step(proj.z, 0.0)) * shadowparams.z + shadowoffset, mparams.y + shadowparams.w);
                }
            ]]
        ])

        @(if (|| (dlopt "p") (dlopt "c")) [
            cond [dlopt "G"] [result [
                #ifdef GL_ARB_texture_gather
                @(if (> $usetexgather 1) [result [
                #  ifdef GL_ARB_gpu_shader5
                #      define shadowgather(center, xoff, yoff) textureGatherOffset(tex4, center, shadowtc.z, ivec2(xoff, yoff))
                #    else
                #      define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                #  endif
                ]] [result [
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                ]])
                #else
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, texture4(tex4, center + vec2(xoff, yoff)*shadowatlasscale))
                #endif
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5), center = (shadowtc.xy - offset)*shadowatlasscale;
                    vec4 group1 = shadowgather(center, -2.0, -2.0);
                    vec4 group2 = shadowgather(center,  0.0, -2.0);
                    vec4 group3 = shadowgather(center,  2.0, -2.0);
                    vec4 group4 = shadowgather(center, -2.0,  0.0);
                    vec4 group5 = shadowgather(center,  0.0,  0.0);
                    vec4 group6 = shadowgather(center,  2.0,  0.0);
                    vec4 group7 = shadowgather(center, -2.0,  2.0);
                    vec4 group8 = shadowgather(center,  0.0,  2.0);
                    vec4 group9 = shadowgather(center,  2.0,  2.0);
                    vec4 locols = vec4(group1.ab, group3.ab);
                    vec4 hicols = vec4(group7.rg, group9.rg);
                    locols.yz += group2.ab;
                    hicols.yz += group8.rg;
                    vec4 midcols = vec4(group1.rg, group3.rg) + vec4(group7.ab, group9.ab) +
                                   vec4(group4.rg, group6.rg) + vec4(group4.ab, group6.ab) +
                                   mix(locols, hicols, offset.y);
                    vec4 cols = group5 + vec4(group2.rg, group8.ab);
                    cols.xyz += mix(midcols.xyz, midcols.yzw, offset.x);
                    return dot(cols, vec4(1.0/25.0));
                }
            ]] [dlopt "g"] [result [
                #ifdef GL_ARB_texture_gather
                @(if (> $usetexgather 1) [result [
                #  ifdef GL_ARB_gpu_shader5
                #      define shadowgather(center, xoff, yoff) textureGatherOffset(tex4, center, shadowtc.z, ivec2(xoff, yoff))
                #    else
                #      define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                #  endif
                ]] [result [
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                ]])
                #else
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, texture4(tex4, center + vec2(xoff, yoff)*shadowatlasscale))
                #endif
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5), center = (shadowtc.xy - offset)*shadowatlasscale;
                    vec4 group1 = shadowgather(center, -1.0, -1.0);
                    vec4 group2 = shadowgather(center,  1.0, -1.0);
                    vec4 group3 = shadowgather(center, -1.0,  1.0);
                    vec4 group4 = shadowgather(center,  1.0,  1.0);
                    vec4 cols = vec4(group1.rg, group2.rg) + vec4(group3.ab, group4.ab) + mix(vec4(group1.ab, group2.ab), vec4(group3.rg, group4.rg), offset.y);
                    return dot(mix(cols.xyz, cols.yzw, offset.x), vec3(1.0/9.0));
                }
            ]] [dlopt "E"] [result [
                #define shadowval(xy) shadow2DRect(tex4, vec3(xy, shadowtc.z)).r
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5);
                    vec4 center = vec4(shadowtc.xy - offset + 0.5, shadowtc.xy - offset*0.5);
                    vec4 size = vec4(offset + 1.0, 2.0 - offset);
                    return (1.0/25.0)*dot(size.zxzx*size.wwyy, 
                            vec4(shadowval(center.zw - 1.5), 
                                 shadowval(center.zw + vec2(2.0, -1.5)), 
                                 shadowval(center.zw + vec2(-1.5, 2.0)), 
                                 shadowval(center.zw + 2.0))) + 
                           (2.0/25.0)*dot(size, 
                            vec4(shadowval(center.zy + vec2(2.0, 0.0)), 
                                 shadowval(center.xw + vec2(0.0, 2.0)),
                                 shadowval(center.zy + vec2(-1.5, 0.0)),
                                 shadowval(center.xw + vec2(0.0, -1.5)))) +
                           (4.0/25.0)*shadowval(center.xy);
                }   
            ]] [dlopt "F"] [result [
                #define shadowval(center, xyoff) shadow2DRect(tex4, vec3(center.xy + xyoff, center.z)).r
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5);
                    vec3 center = shadowtc;
                    //center.xy -= offset;
                    //vec4 size = vec4(offset + 1.0, 2.0 - offset), weight = vec4(2.0 - 1.0 / size.xy, 1.0 / size.zw - 1.0);
                    //return (1.0/9.0)*dot(size.zxzx*size.wwyy,
                    //    vec4(shadowval(center, weight.zw),
                    //         shadowval(center, weight.xw),
                    //         shadowval(center, weight.zy),
                    //         shadowval(center, weight.xy)));
                    center.xy -= offset*0.5;
                    vec4 size = vec4(offset + 1.0, 2.0 - offset);
                    return (1.0/9.0)*dot(size.zxzx*size.wwyy,
                        vec4(shadowval(center, -0.5),
                             shadowval(center, vec2(1.0, -0.5)),
                             shadowval(center, vec2(-0.5, 1.0)),
                             shadowval(center, 1.0)));
                }
            ]] [dlopt "f"] [result [
                #define shadowval(center, xoff, yoff) shadow2DRect(tex4, center + vec3(xoff, yoff, 0.0)).r
                float filtershadow(vec3 shadowtc)
                {
                    return dot(vec4(0.25),
                                vec4(shadowval(shadowtc, -0.4, 1.0),
                                    shadowval(shadowtc, -1.0, -0.4),
                                    shadowval(shadowtc, 0.4, -1.0),
                                    shadowval(shadowtc, 1.0, 0.4))); 
                }
            ]] [result [
                #define filtershadow(shadowtc) shadow2DRect(tex4, shadowtc).r
            ]]
        ])

        @(if (dlopt "c") [result [
            vec3 getcsmtc(vec3 pos)
            {
                pos = csmmatrix * pos;
                @(loopconcat j (- $numsplits 1) [result [
                    if(all(lessThan(abs(pos - splitcenter[@@j]), splitbounds[@@j])))
                        pos = pos*splitscale[@@j] + splitoffset[@@j];
                    else
                ]])
                if(all(lessThan(abs(pos.xy - splitcenter[@@(- $numsplits 1)].xy), splitbounds[@@(- $numsplits 1)].xy)))
                    pos = pos*splitscale[@@(- $numsplits 1)] + splitoffset[@@(- $numsplits 1)];
                else pos = vec3(-1.0);
                return pos;
            }
            
            @(if (dlopt "r") [result [
                vec3 getrhlight(vec3 pos, vec3 norm)
                {
                    vec3 tc;
                    pos += norm*rhnudge;
                    @(loopconcat j (- $numrh 1) [result [
                        if(all(lessThan(abs(pos - rhbb[@@j].xyz), vec3(rhbb[@@j].w))))
                            tc = pos*rhscale[@@j] + rhoffset[@@j];
                        else
                    ]])
                    if(all(lessThan(abs(pos - rhbb[@@(- $numrh 1)].xyz), vec3(rhbb[@@(- $numrh 1)].w))))
                        tc = pos*rhscale[@@(- $numrh 1)] + rhoffset[@@(- $numrh 1)];
                    else tc = vec3(-1.0);
                    vec4 shr = texture3D(tex6, tc), shg = texture3D(tex7, tc), shb = texture3D(tex8, tc);
                    shr.rgb -= 0.5;
                    shg.rgb -= 0.5;
                    shb.rgb -= 0.5;
                    vec4 basis = vec4(norm*-(1.023326*0.488603/3.14159*2.0), (0.886226*0.282095/3.14159));
                    return clamp(vec3(dot(basis, shr), dot(basis, shg), dot(basis, shb)), 0.0, 1.0);
                }
            ]])
        ]])
            
        void main(void)
        {
            @(if (dlopt "M") [
                if (dlopt "R") [result [
                    @(if (dlopt "T") [result [
                        bool shouldresolve = true;
                        {
                            vec4 e = texelFetch(tex1, ivec2(gl_FragCoord.xy), 0);
                            e.xyz -= 0.5;
                            float maxdiff = 0.98*0.98*dot(e.xyz, e.xyz); 
                            @(loopconcat i (- $msaasamples 1) [result [
                                vec4 e@i = texelFetch(tex1, ivec2(gl_FragCoord.xy), @(+ $i 1));
                                e@i.xyz -= 0.5;
                                if(abs(e.w-e@i.w) <= 4.0/255.0 && pow(dot(e@i.xyz, e.xyz), 2.0) >= maxdiff*dot(e@i.xyz, e@i.xyz))
                                {
                            ]])
                                    shouldresolve = false;
                            @(loopconcat i (- $msaasamples 1) [result [
                                }
                            ]])
                        }
                    ]])

                    #define gfetch(sampler, coords) texelFetch(sampler, ivec2(coords), sample)

                    vec4 resolved = vec4(0.0);
                    #define accumlight(light) resolved.rgb += light
                    #define accumalpha(alpha) resolved.a += alpha

                    @(if (&& $baselight [dlopt "a"]) [result [
                        float ao = texture2DRect(tex5, gl_FragCoord.xy*aoscale).r;
                    ]])

                    for(int sample = 0; sample < @msaasamples; sample++) 
                    {
                ]] [result [
                    #define gfetch(sampler, coords) texelFetch(sampler, ivec2(coords), @(? (dlopt "S") [gl_SampleID] [0]))

                    #define accumlight(light) gl_FragColor.rgb = light
                    #define accumalpha(alpha) gl_FragColor.a = alpha
                ]]
            ] [result [
                #define gfetch(sampler, coords) texture2DRect(sampler, coords)

                #define accumlight(light) gl_FragColor.rgb = light
                #define accumalpha(alpha) gl_FragColor.a = alpha
            ]])

            @(if (|| $baselight [> $numlights 1]) [result [
                vec4 diffuse = gfetch(tex0, gl_FragCoord.xy);
            ]])
            @(if $baselight [result [
                vec3 light = diffuse.rgb * lightscale.rgb;
                @(if (dlopt "a") [
                    if (&& (dlopt "M") [dlopt "R"]) [result [
                        light *= aoparams.x + ao*aoparams.y;
                    ]] [result [
                        float ao = texture2DRect(tex5, gl_FragCoord.xy*aoscale).r;
                        light *= aoparams.x + ao*aoparams.y;
                    ]]
                ]) 
                vec4 glow = gfetch(tex2, gl_FragCoord.xy);
                light += glow.rgb * lightscale.a;
            ]] [result [
                vec3 light = vec3(0.0);
            ]])

            @(if (|| (> $numlights 0) (dlopt "c")) [result [
                @(gdepthunpack depth tex3 gl_FragCoord.xy [
                    @(if (dlopt "m") [result [
                        vec3 pos = (worldmatrix * vec4(gl_FragCoord.xy, depth, 1.0)).xyz;
                    ]] [result [
                        vec3 pos = (worldmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).xyz;
                    ]])
                    #define fogcoord depth
                ] [
                    vec4 pos = worldmatrix * vec4(gl_FragCoord.xy, depth, 1.0);
                    pos.xyz /= pos.w;
                    #define fogcoord dot(fogdir, vec4(pos.xyz, 1.0))
                ])
                @(if (|| (dlopt "c") [> $numlights 1]) [result [
                    vec4 normal = gfetch(tex1, gl_FragCoord.xy);
                    normal.xyz = normal.xyz*2.0 - 1.0;
                ]])
                @(if (&& (> (+ $numlights (dlopt "c")) 1) [! (dlopt "m")]) [result [
                    vec3 camdir = normalize(camera - pos.xyz);
                    float facing = 2.0*dot(normal.xyz, camdir);
                ]])
            ]] [if (! (dlopt "m")) [result [
                @(gdepthunpack depth tex3 gl_FragCoord.xy)
                #define fogcoord depth
            ]]])

            @(if (dlopt "c") [result [
                @(if (dlopt "r") [result [
                    vec3 rhlight = diffuse.rgb * getrhlight(pos.xyz, normal.xyz) * giscale;
                ]])
                float sunfacing = dot(sunlightdir, normal.xyz);
                if(sunfacing > 0.0)
                {
                    vec3 csmtc = getcsmtc(pos.xyz);
                    float sunoccluded = sunfacing * filtershadow(csmtc);
                    @(if (dlopt "m") [result [
                        light += diffuse.rgb * sunlightcolor * sunoccluded;
                    ]] [result [
                        @(if (= (+ $numlights (dlopt "c")) 1) [result [
                            vec3 camdir = normalize(camera - pos.xyz);
                            float facing = 2.0*dot(normal.xyz, camdir);
                        ]])
                        float sunspec = pow(clamp(sunfacing*facing - dot(camdir, sunlightdir), 0.0, 1.0), 16.0) * diffuse.a;
                        @(if (dlopt "r") [result [
                            rhlight += (diffuse.rgb + sunspec) * sunoccluded;
                        ]] [result [
                            @(if (dlopt "A") [result [
                                sunoccluded *= aoparams.z + ao*aoparams.w;
                            ]])
                            light += (diffuse.rgb + sunspec) * sunoccluded * sunlightcolor;
                        ]])
                    ]])
                }
                @(if (dlopt "r") [result [
                    light += rhlight @(? (dlopt "A") [* (aoparams.z + ao*aoparams.w)]) * sunlightcolor;
                ]])
            ]])
            @(loopconcat j $numlights [result [
                vec3 light@[j]dir = (pos.xyz - lightpos[@@j].xyz) * lightpos[@@j].w;
                float light@[j]dist2 = dot(light@[j]dir, light@[j]dir);
                if(light@[j]dist2 < 1.0)
                {
                    @(if (&& (= $numlights 1) [! (dlopt "c")]) [result [
                        vec4 normal = gfetch(tex1, gl_FragCoord.xy);
                        normal.xyz = normal.xyz*2.0 - 1.0;
                    ]])
                    float light@[j]facing = dot(light@[j]dir, normal.xyz);
                    if(light@[j]facing < 0.0) 
                    {
                        float light@[j]invdist = inversesqrt(light@[j]dist2); 
                        @(if $spotlight [result [
                            float spot@[j]dist = dot(light@[j]dir, spotparams[@@j].xyz);
                            float spot@[j]atten = light@[j]invdist * spot@[j]dist - spotparams[@@j].w;
                            if(spot@[j]atten > 0.0)
                            {
                        ]])
                        float light@[j]atten = light@[j]facing * (1.0 - light@[j]invdist);
                        @(if $spotlight [
                            if (dlopt "p") [result [
                                vec3 spot@[j]tc = getspottc(light@[j]dir, spot@[j]dist, spotx[@@j], spoty[@@j], shadowparams[@@j], shadowoffset[@@j]);
                                light@[j]atten *= spot@[j]atten * filtershadow(spot@[j]tc);
                            ]] [result [
                                light@[j]atten *= spot@[j]atten;
                            ]]
                        ] [
                            if (dlopt "p") [result [
                                vec3 shadow@[j]tc = getshadowtc(light@[j]dir, shadowparams[@@j], shadowoffset[@@j]);
                                light@[j]atten *= filtershadow(shadow@[j]tc);
                            ]]
                        ])
                        @(if (&& (= $numlights 1) [! $baselight]) [result [
                            vec4 diffuse = gfetch(tex0, gl_FragCoord.xy);
                        ]])
                        @(if (dlopt "m") [result [
                            light += diffuse.rgb * lightcolor[@@j] * light@[j]atten;
                        ]] [result [
                            @(if (= (+ $numlights (dlopt "c")) 1) [result [
                                vec3 camdir = normalize(camera - pos.xyz);
                                float facing = 2.0*dot(normal.xyz, camdir);
                            ]])
                            float light@[j]spec = pow(clamp(light@[j]invdist*(dot(camdir, light@[j]dir) - light@[j]facing*facing), 0.0, 1.0), 16.0) * diffuse.a;
                            light += (diffuse.rgb + light@[j]spec) * lightcolor[@@j] * light@[j]atten;
                            @(if (= (+ $numlights $baselight) 1) [result [
                                float foglerp = clamp((fogparams.y + fogcoord)*fogparams.z, 0.0, 1.0);
                                light *= foglerp;
                            ]])
                        ]])
                        @(? $spotlight [}]) 
                    }
                }
            ]])
            @(if (dlopt "m") [if $baselight [result [
                accumlight(light);
                accumalpha(glow.a);
            ]] [result [
                accumlight(light);
                accumalpha(0.0);
            ]]] [if (|| $baselight [> $numlights 1]) [result [
                float foglerp = clamp((fogparams.y + fogcoord)*fogparams.z, 0.0, 1.0);
                @(? $baselight [
                    accumlight(mix(fogcolor*glow.a, light, foglerp));
                    accumalpha(glow.a);
                ] [
                    accumlight(light*foglerp);
                    accumalpha(0.0);
                ])
            ]] [result [
                accumlight(light);
                accumalpha(0.0);
            ]]])

            @(if (dlopt "R") [result [
                    @(? (dlopt "T") [if(!shouldresolve) break;])
                }

                @(? (dlopt "T") [if(shouldresolve)]) resolved *= @(divf 1 $msaasamples);
                gl_FragColor = resolved;
            ]])
        }
    ] 64
]

deferredlightshader = [
    shadername = (concatword "deferredlight" $arg1 $arg2 $arg3)
    deferredlightvariantshader $shadername -1 (concatword $arg1 $arg3) $arg4 $arg5 0 // base shader, no points lights, sunlight
    loop i 8 [
        deferredlightvariantshader $shadername 0 (concatword $arg1 $arg3) $arg4 $arg5 (+ $i 1) // row 0, point lights, sunlight
        deferredlightvariantshader $shadername 1 (concatword $arg1 $arg2 $arg3) $arg4 $arg5 (+ $i 1) // row 1, shadowed point lights, sunlight
        deferredlightvariantshader $shadername 2 $arg1 $arg4 $arg5 (+ $i 1) // row 2, point lights 
        deferredlightvariantshader $shadername 3 (concatword $arg1 $arg2) $arg4 $arg5 (+ $i 1) // row 3, shadowed point lights
        deferredlightvariantshader $shadername 4 (concatword $arg1 $arg3) $arg4 $arg5 (+ $i 1) // row 4, spot lights, sunlight
        deferredlightvariantshader $shadername 5 (concatword $arg1 $arg2 $arg3) $arg4 $arg5 (+ $i 1) // row 5, shadowed spot lights, sunlight
        deferredlightvariantshader $shadername 6 $arg1 $arg4 $arg5 (+ $i 1) // row 6, spot lights 
        deferredlightvariantshader $shadername 7 (concatword $arg1 $arg2) $arg4 $arg5 (+ $i 1) // row 7, shadowed spot lights
    ]
]

lazyshader 0 "modelpreview" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    @(gfetchdefs [tex0 tex1 tex2 tex3])
    uniform vec3 camera;
    uniform mat4 worldmatrix;
    uniform vec4 lightscale;
    uniform vec3 sunlightdir;
    uniform vec3 sunlightcolor;

    void main(void)
    {
        vec4 diffuse = gfetch(tex0, gl_TexCoord[0].xy);    
        vec3 light = diffuse.rgb * lightscale.rgb;
        vec4 glow = gfetch(tex2, gl_TexCoord[0].xy);
        light += glow.rgb * lightscale.a;

        vec4 normal = gfetch(tex1, gl_TexCoord[0].xy);
        normal.xyz = normal.xyz*2.0 - 1.0;

        float sunfacing = dot(sunlightdir, normal.xyz);
        if(sunfacing > 0.0)
        {
            @(gdepthunpack depth tex3 gl_TexCoord[0].xy [
                vec3 pos = (worldmatrix * vec4(depth*gl_TexCoord[0].xy, depth, 1.0)).xyz;
            ] [
                vec4 pos = worldmatrix * vec4(gl_TexCoord[0].xy, depth, 1.0);
                pos.xyz /= pos.w;
            ])
            vec3 camdir = normalize(camera - pos.xyz);
            float facing = 2.0*dot(normal.xyz, camdir);
            float sunspec = pow(clamp(sunfacing*facing - dot(camdir, sunlightdir), 0.0, 1.0), 8.0) * diffuse.a;
            light += (diffuse.rgb + sunspec) * sunfacing * sunlightcolor;
        }

        gl_FragColor.rgb = light;
        gl_FragColor.a = glow.a;
    }
]

shader 0 "hdrreduce" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    void main(void)
    {
        gl_FragColor.rgb = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
    }
]

shader 0 "hdrreduce2w" [
    varying vec2 tap0, tap1;
    void main(void)
    {
        gl_Position = gl_Vertex;
        tap0 = gl_MultiTexCoord0.xy + vec2(-1.0, 0.0);
        tap1 = gl_MultiTexCoord0.xy + vec2( 1.0, 0.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    varying vec2 tap0, tap1;
    void main(void)
    {
        gl_FragColor.rgb = 0.5*(texture2DRect(tex0, tap0).rgb + texture2DRect(tex0, tap1).rgb);
    }
]

shader 0 "hdrreduce2" [
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_Position = gl_Vertex;
        tap0 = gl_MultiTexCoord0.xy + vec2(-1.0, -1.0);
        tap1 = gl_MultiTexCoord0.xy + vec2( 1.0, -1.0);
        tap2 = gl_MultiTexCoord0.xy + vec2( 1.0,  1.0);
        tap3 = gl_MultiTexCoord0.xy + vec2(-1.0,  1.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_FragColor.rgb = 0.25*(texture2DRect(tex0, tap0).rgb + texture2DRect(tex0, tap1).rgb +
                                 texture2DRect(tex0, tap2).rgb + texture2DRect(tex0, tap3).rgb);
    }
]

lumweights = "0.2126, 0.7152, 0.0722"
//lumweights = "0.299, 0.587, 0.114"

hdrgammadecode = [
    if (=f $hdrgamma 2) [result [
        @arg1 *= @arg1;
    ]] [result [
        @arg1 = pow(@arg1, vec3(hdrgamma.x));
    ]]
]

hdrgammaencode = [
    if (=f $hdrgamma 2) [result [
        @arg1 = sqrt(@arg1);
    ]] [result [
        @arg1 = pow(@arg1, vec3(hdrgamma.y));
    ]]
]

shader 0 "hdrluminance" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    void main(void)
    {
        vec3 color = texture2DRect(tex0, gl_TexCoord[0].xy).rgb*2.0;
        @(hdrgammadecode color)
        float lum = dot(color, vec3(@lumweights));
        float loglum = sqrt(clamp(lum, 0.015625, 4.0)) * (1.0/2.0); // allow values as low as 2^-6, and as high 2^2
        gl_FragColor.rgb = vec3(loglum);
    }
]

shader 0 "hdrluminance2w" [
    varying vec2 tap0, tap1;
    void main(void)
    {
        gl_Position = gl_Vertex;
        tap0 = gl_MultiTexCoord0.xy + vec2(-1.0, 0.0);
        tap1 = gl_MultiTexCoord0.xy + vec2( 1.0, 0.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 tap0, tap1;
    void main(void)
    {
        @(loopconcat i 2 [result [
            vec3 color@[i] = texture2DRect(tex0, tap@[i]).rgb*2.0;
            @(hdrgammadecode [color@[i]])
            float lum@[i] = dot(color@[i], vec3(@lumweights));
            float loglum@[i] = sqrt(clamp(lum@[i], 0.015625, 4.0)) * (1.0/2.0);
        ]])
        gl_FragColor.rgb = vec3(0.5*(loglum0 + loglum1));
    }
]

shader 0 "hdrluminance2" [
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_Position = gl_Vertex;
        tap0 = gl_MultiTexCoord0.xy + vec2(-1.0, -1.0);
        tap1 = gl_MultiTexCoord0.xy + vec2( 1.0, -1.0);
        tap2 = gl_MultiTexCoord0.xy + vec2( 1.0,  1.0);
        tap3 = gl_MultiTexCoord0.xy + vec2(-1.0,  1.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        @(loopconcat i 4 [result [
            vec3 color@[i] = texture2DRect(tex0, tap@[i]).rgb*2.0;
            @(hdrgammadecode [color@[i]])
            float lum@[i] = dot(color@[i], vec3(@lumweights));
            float loglum@[i] = sqrt(clamp(lum@[i], 0.015625, 4.0)) * (1.0/2.0);
        ]])
        gl_FragColor.rgb = vec3(0.25*(loglum0 + loglum1 + loglum2 + loglum3));
    }
]

shader 0 "hdraccum" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    uniform float accumscale;
    void main(void)
    {
        float lum = texture2DRect(tex0, gl_TexCoord[0].xy).r * 2.0;
        lum *= lum;
        gl_FragColor = vec4(vec3(lum*0.25), accumscale);
    }
]

shader 0 "hdrbloom" [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex2; 
    uniform vec4 hdrparams;
    varying float lumscale, lumthreshold;
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        float avglum = 4.0*texture2DRect(tex2, vec2(0.5, 0.5)).r;
        lumscale = hdrparams.x * -log2(1.0 - clamp(avglum, 0.03, 0.3))/(avglum + 1e-4);
        lumthreshold = -log2(1.0 - hdrparams.z);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying float lumscale, lumthreshold;
    void main(void)
    {
        vec3 color = texture2DRect(tex0, gl_TexCoord[0].xy).rgb*2.0;
        @(hdrgammadecode color)
        float lum = dot(color, vec3(@lumweights));
        color *= max(lum*lumscale - lumthreshold, 0.0) / (lum + 1e-4);
        @(hdrgammaencode color)
        gl_FragColor.rgb = color;
    }
]

hdrtonemapvertexshader = [
  result [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex2; 
    uniform vec4 hdrparams;
    varying float lumscale, lumsaturate;
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        gl_TexCoord[1].xy = gl_MultiTexCoord1.xy;
        float avglum = 4.0*texture2DRect(tex2, vec2(0.5, 0.5)).r;
        lumscale = hdrparams.x * -log2(1.0 - clamp(avglum, 0.03, 0.3))/(avglum + 1e-4);
        lumsaturate = -log2(1.0 - hdrparams.y) / lumscale;
    }
  ]
]

hdrtonemapfrag = [
    result [{
        // color = 1.0 - exp2(-color*lumscale);
        float lum = dot(@arg1, vec3(@lumweights));
        @arg1 = min(@arg1, lumsaturate);
        @arg1 *= (1.0 - exp2(-lum*lumscale)) / (dot(@arg1, vec3(@lumweights)) + 1e-4);
    }]
]

hdrtonemapdefs = [
    result [
        uniform vec4 hdrparams;
        uniform vec2 hdrgamma;
        varying float lumscale, lumsaturate;
    ]
]

hdrtonemapshaders = [
  (? $arg1 lazyshader shader) 0 [hdrnop@arg1] [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
  ] [
    #extension GL_ARB_texture_rectangle : enable
    @arg2
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 color = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        gl_FragColor.rgb = color;
        @(? $arg3 $arg3 [gl_FragColor.a = 0.0;])
    }
  ]

  
  (? $arg1 lazyshader shader) 0 [hdrtonemap@arg1] (hdrtonemapvertexshader) [
    #extension GL_ARB_texture_rectangle : enable
    @arg2
    uniform sampler2DRect tex0, tex1;
    @(hdrtonemapdefs)
    void main(void)
    {
        vec3 color = texture2DRect(tex0, gl_TexCoord[0].xy).rgb*2.0;
        vec3 bloom = texture2DRect(tex1, gl_TexCoord[1].xy).rgb*hdrparams.w;
        color += bloom;
        @(hdrgammadecode color)
        @(hdrtonemapfrag color)
        @(hdrgammaencode color)
        gl_FragColor.rgb = color;
        @(? $arg3 $arg3 [gl_FragColor.a = 0.0;])
    }
  ]
  
  if $msaasamples [msaatonemapshaders $arg1 $arg2 $arg3]
  if (= $msaasamples 2) [msaasplitshaders $arg1 $arg2 $arg3]
]

msaatonemapshaders = [
  if (=s $arg1 "") [lazyshader 0 [msaatonemapsample] (hdrtonemapvertexshader) [
    #extension GL_ARB_texture_rectangle : enable
    #extension GL_ARB_texture_multisample : enable
    #extension GL_ARB_sample_shading : enable
    uniform sampler2DRect tex1;
    uniform sampler2DMS tex0;
    @(hdrtonemapdefs)
    void main(void)
    {
        vec3 bloom = texture2DRect(tex1, gl_TexCoord[1].xy).rgb*hdrparams.w;
        vec3 color = texelFetch(tex0, ivec2(gl_TexCoord[0].xy), gl_SampleID).rgb*2.0;
        color += bloom;
        @(hdrgammadecode color)
        @(hdrtonemapfrag color)
        @(hdrgammaencode color)
        gl_FragColor = vec4(color, 0.0);
    }
  ]]

  defershader 0 [msaatonemap@arg1] [
    loop i 2 [
      variantshader 0 [msaatonemap@@@arg1] (- $i 1) (hdrtonemapvertexshader) [
        #extension GL_ARB_texture_rectangle : enable
        #extension GL_ARB_texture_multisample : enable
        @@@arg2
        uniform sampler2DRect tex1;
        uniform sampler2DMS tex0;
        @(hdrtonemapdefs)
        void main(void)
        {
            vec3 bloom = texture2DRect(tex1, gl_TexCoord[1].xy).rgb*hdrparams.w;
            @(if $i [result [
                vec3 resolved = vec3(0.0);
                for(int sample = 0; sample < @msaasamples; sample++)
                {
            ]] [result [
                #define sample 0
            ]])
                    vec3 color = texelFetch(tex0, ivec2(gl_TexCoord[0].xy), sample).rgb*2.0;
                    color += bloom;
                    @(hdrgammadecode color)
                    @(hdrtonemapfrag color)
                    @(hdrgammaencode color)
            @(if $i [result [
                    resolved += color;
                }
                gl_FragColor.rgb = resolved * @(divf 1 $msaasamples);
            ]] [result [
                gl_FragColor.rgb = color;
            ]])
            @@@(? $arg3 $arg3 [gl_FragColor.a = 0.0;])
        }
      ]
    ]
  ]
]

msaasplitshaders = [
  lazyshader 0 [msaasplit@arg1] [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
  ] [
    #extension GL_ARB_texture_multisample : enable
    @arg2
    uniform sampler2DMS tex0;
    void main(void)
    {
        @(loopconcat i $msaasamples [result [
            gl_FragData[@@i].rgb = texelFetch(tex0, ivec2(gl_TexCoord[0].xy), @i).rgb;
            @(if $arg3 [result [
                { @(strreplace $arg3 [gl_FragColor] [gl_FragData[@@i]]) }
            ]] [result [
                gl_FragData[@@i].a = 0.0;
            ]])
        ]])
    }
  ]

  lazyshader 0 [msaatonemapsplit@arg1] (hdrtonemapvertexshader) [
    #extension GL_ARB_texture_rectangle : enable
    #extension GL_ARB_texture_multisample : enable
    @arg2
    uniform sampler2DRect tex1;
    uniform sampler2DMS tex0;
    @(hdrtonemapdefs)
    void main(void)
    {
        vec3 bloom = texture2DRect(tex1, gl_TexCoord[1].xy).rgb*hdrparams.w;
        @(loopconcat i $msaasamples [result [
            vec3 color@i = texelFetch(tex0, ivec2(gl_TexCoord[0].xy), @i).rgb*2.0 + bloom;
            @(hdrgammadecode [color@i])
            @(hdrtonemapfrag [color@i])
            @(hdrgammaencode [color@i])
            gl_FragData[@@i].rgb = color@i;
            @(if $arg3 [result [
                { @(strreplace $arg3 [gl_FragColor] [gl_FragData[@@i]]) }
            ]] [result [
                gl_FragData[@@i].a = 0.0;
            ]])
        ]])
    }
  ]
]

hdrtonemapshaders ""
hdrtonemapshaders "luma" [] [gl_FragColor.a = dot(gl_FragColor.rgb, vec3(@lumweights));]
hdrtonemapshaders "velocity" [
    @(gfetchdefs tex3)
    uniform mat4 reprojectmatrix;
    uniform vec2 maxvelocity;
] [
    @(gdepthunpack depth tex3 gl_TexCoord[0].xy [
        vec4 prevtc = reprojectmatrix * vec4(depth*gl_TexCoord[0].xy, depth, 1.0);
    ] [
        vec4 prevtc = reprojectmatrix * vec4(gl_TexCoord[0].xy, depth, 1.0);
    ])
    gl_FragColor.a = distance(prevtc.xy/prevtc.w, gl_TexCoord[0].xy)*maxvelocity.y;
]

lazyshader 0 "scalelinear" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;

    void main(void)
    {
        gl_FragColor = texture2DRect(tex0, gl_TexCoord[0].xy);
    }
]

loop i 2 [
  lazyshader 0 (? $i "scalecubicy" "scalecubicx") [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
  ] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;

    vec4 cubic(float s)
    {
        const float B = @gscalecubicsoft, C = @(divf (-f 1 $gscalecubicsoft) 2);
        float s2 = s*s, s3 = s2*s;
        return vec4((-1.0/6.0*B - C) * s3 + (0.5*B + 2.0*C) * s2 + (-0.5*B - C) * s + 1.0/6.0*B,
                    (2.0 - 1.5*B - C) * s3 + (-3.0 + 2.0*B + C) * s2 + (1.0 - 1.0/3.0*B),
                    (-2.0 + 1.5*B + C) * s3 + (3.0 - 2.5*B - 2.0*C) * s2 + (0.5*B + C)*s + 1.0/6.0*B,
                    (1.0/6.0*B + C) * s3 - C * s2);
    }

    void main(void)
    {
        vec2 center = gl_TexCoord[0].xy;
        @(if $i [result [
            float offset = fract(gl_TexCoord[0].y-0.5);
            center.y -= offset;
            #define texval(tap) texture2DRect(tex0, center + vec2(0.0, tap))
        ]] [result [
            float offset = fract(gl_TexCoord[0].x-0.5);
            center.x -= offset;
            #define texval(tap) texture2DRect(tex0, center + vec2(tap, 0.0))
        ]])
        vec4 weight = cubic(offset);
        weight.y += weight.z;
        weight.z /= weight.y;
        gl_FragColor = weight.x*texval(-1.0) + weight.y*texval(weight.z) + weight.w*texval(2.0);
    }
  ]
]

aotapoffsets = [
"-0.933103, 0.025116"
"-0.432784, -0.989868"
"0.432416, -0.413800"
"-0.117770, 0.970336"
"0.837276, 0.531114"
"-0.184912, 0.200232"
"-0.955748, 0.815118"
"0.946166, -0.998596"
"-0.897519, -0.581102"
"0.979248, -0.046602"
"-0.155736, -0.488204"
"0.460310, 0.982178"
]

ambientobscurancevariantshader = [
    lineardepth = (>= (strstr $arg2 "l") 0)
    packeddepth = (>= (strstr $arg2 "p") 0)
    derivnormal = (>= (strstr $arg2 "d") 0)
    maxaotaps = $arg3 
    shader 0 $arg1 [
        void main(void)
        {
            gl_Position = gl_Vertex;
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
            gl_TexCoord[1].xy = gl_MultiTexCoord1.xy;
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        @(? $msaasamples [#extension GL_ARB_texture_multisample : enable])
        @(gfetchdefs tex0 (&& $msaasamples [! $lineardepth]) gdepthfetch)
        @(gfetchdefs tex1 $msaasamples gnormfetch)
        @(gdepthunpackparams)
        uniform sampler2D tex2;
        uniform vec3 tapparams;
        uniform vec2 contrastparams;
        uniform vec4 offsetscale;
        uniform float prefilterdepth;
        @(? $lineardepth [
            #define depthtc gl_FragCoord.xy
        ] [
            #define depthtc gl_TexCoord[0].xy
        ])
        uniform vec3 gdepthpackparams;
        void main(void)
        {
            @(if (&& $derivnormal [= $aodepthformat 1]) [result [
                #define gfetch gnormfetch
                @(gdepthunpack depth tex1 gl_TexCoord[0].xy [
                    vec2 tapscale = tapparams.xy/depth;
                ] [
                    float w = depth*gdepthscale.y + gdepthscale.z;
                    depth = gdepthscale.x/w;
                    vec2 tapscale = tapparams.xy*w;
                ])
            ]] [result [
                #define gfetch gdepthfetch
                @(gdepthunpack depth tex0 depthtc [
                    vec2 tapscale = tapparams.xy/depth;
                ] [
                    float w = depth*gdepthscale.y + gdepthscale.z;
                    depth = gdepthscale.x/w;
                    vec2 tapscale = tapparams.xy*w;
                ] $lineardepth (? $lineardepth (! $aodepthformat) (= $gdepthformat 1)) packdepth)
            ]])
            #undef gfetch
            vec2 dpos = depthtc*offsetscale.xy + offsetscale.zw, pos = depth*dpos;
            @(if $derivnormal [result [
                vec2 ddepth = vec2(dFdx(depth), dFdy(depth)); 
                vec3 normal;
                normal.xy = (depth+ddepth.yx)*offsetscale.yx;
                normal.z = normal.x*normal.y;
                normal.xy *= -ddepth;
                normal.z -= dot(dpos, normal.xy);
                normal = normalize(normal);
            ]] [result [
                vec3 normal = gnormfetch(tex1, gl_TexCoord[0].xy).rgb*2.0 - 1.0;
                normal = (gl_ModelViewMatrix * vec4(normal, 0.0)).xyz;
            ]])
            vec2 noise = texture2D(tex2, gl_TexCoord[1].xy).rg*2.0-1.0;
            float obscure = 0.0;
            #define gfetch gdepthfetch
            @(loopconcat i $maxaotaps [result [
                vec2 offset@[i] = reflect(vec2(@(at $aotapoffsets $i)), noise);
                offset@[i] = depthtc + tapscale * offset@[i];
                @(gdepthunpack [depth@[i]] tex0 [offset@[i].xy] [] [] $lineardepth (&& $lineardepth (! $aodepthformat)))
                vec3 v@[i] = vec3(depth@[i]*(offset@[i].xy*offsetscale.xy + offsetscale.zw) - pos, depth@[i] - depth);
                float dist2@[i] = dot(v@[i], v@[i]);
                obscure += step(dist2@[i], tapparams.z) * max(0.0, dot(v@[i], normal) + depth*1.0e-2) / (dist2@[i] + 1.0e-5);
            ]])
            #undef gfetch
            obscure = pow(clamp(1.0 - contrastparams.x*obscure, 0.0, 1.0), contrastparams.y);
            @(if $derivnormal [result [
                vec2 weights = step(abs(ddepth), vec2(prefilterdepth)) * (2.0*fract((gl_FragCoord.xy - 0.5)*0.5) - 0.5);
            ]] [result [
                vec2 weights = step(fwidth(depth), prefilterdepth) * (2.0*fract((gl_FragCoord.xy - 0.5)*0.5) - 0.5);
            ]])
            obscure -= dFdx(obscure) * weights.x;
            obscure -= dFdy(obscure) * weights.y;
            @(if $packeddepth [
                if $aodepthformat [result [
                    gl_FragColor.rg = vec2(obscure, depth);
                ]] [result [
                    @(if (&& (! $lineardepth) (!= $gdepthformat 1)) [gpackdepth packdepth depth])
                    gl_FragColor = vec4(packdepth, obscure);
                ]]
            ] [result [
                gl_FragColor = vec4(obscure, 0.0, 0.0, 1.0);
            ]])
        }
    ]
]

ambientobscuranceshader = [
    ambientobscurancevariantshader (format "ambientobscurance%1%2" $arg1 $arg2) $arg1 $arg2
]

shader 0 "linearizedepth" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    @(gfetchdefs tex0)
    uniform vec3 gdepthpackparams;
    void main(void)
    {
        @(if (! $aodepthformat) [
            if (= $gdepthformat 1) [result [
                gl_FragColor = gfetch(tex0, gl_TexCoord[0].xy);
            ]] [result [
                @(gdepthunpack depth tex0 gl_TexCoord[0].xy)
                @(gpackdepth packdepth depth)
                gl_FragColor = vec4(packdepth, 1.0);
            ]]    
        ] [result [
            @(gdepthunpack depth tex0 gl_TexCoord[0].xy)
            gl_FragColor.r = depth;
        ]])
    }
] 

bilateralvariantshader = [
    reduced = (>= (strstr $arg2 "r") 0)
    linear = (>= (strstr $arg2 "l") 0)
    packed = (>= (strstr $arg2 "p") 0)
    upscaled = (>= (strstr $arg2 "u") 0)
    numtaps = $arg3
    filterdir = $arg4
    shader 0 $arg1 [
        void main(void)
        {
            gl_Position = gl_Vertex;
            @(? $reduced [gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;])
            @(? $upscaled [gl_TexCoord[1].xy = gl_MultiTexCoord1.xy;])
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        @(gfetchdefs tex1 (&& $msaasamples [! $linear]))
        uniform sampler2DRect tex0;
        uniform vec3 bilateralparams;
        uniform vec3 gdepthpackparams;
        void main(void)
        {
            #define tc @(? $upscaled [gl_TexCoord[1].xy] [gl_FragCoord.xy])
            #define depthtc @(? $reduced [gl_TexCoord[0].xy] [gl_FragCoord.xy])
            #define tapoffset(i) @(? (=s $filterdir "x") [vec2(i, 0.0)] [vec2(0.0, i)])
            #define depthoffset(i) tapoffset(@(? $reduced [i*bilateralparams.z] [i]))
            @(cond [$packed] [
                if $aodepthformat [result [
                    vec2 vals = texture2DRect(tex0, tc).rg;
                    #define color vals.x
                    @(if $upscaled [gdepthunpack depth tex1 depthtc] [result [
                        #define depth vals.y
                    ]])
                ]] [result [
                    vec4 vals = texture2DRect(tex0, tc);
                    #define color vals.a
                    @(if $upscaled [gdepthunpack depth tex1 depthtc] [result [
                        float depth = dot(vals.rgb, gdepthunpackparams);
                    ]])                 
                ]]
            ] [$linear] [result [
                float color = texture2DRect(tex0, tc).r;
                @(if $aodepthformat [result [
                    float depth = texture2DRect(tex1, depthtc).r;
                ]] [result [
                    float depth = dot(texture2DRect(tex1, depthtc).rgb, gdepthunpackparams);
                ]])
            ]] [result [
                float color = texture2DRect(tex0, tc).r;
                @(gdepthunpack depth tex1 depthtc)
            ]])
            float weights = 1.0;
            @(loopconcat i (* 2 $numtaps) [
                curtap = (- $i $numtaps)
                if (>= $curtap 0) [curtap = (+ $curtap 1)]
                curtapoffset = (*f $curtap 2)
                result [
                    @(cond [$packed] [
                        if $aodepthformat [result [
                            vec2 vals@[i] = texture2DRect(tex0, tc + tapoffset(@curtapoffset)).rg;
                            #define color@[i] vals@[i].x
                            #define depth@[i] vals@[i].y
                        ]] [result [
                            vec4 vals@[i] = texture2DRect(tex0, tc + tapoffset(@curtapoffset));
                            #define color@[i] vals@[i].a
                            float depth@[i] = dot(vals@[i].rgb, gdepthunpackparams);                 
                        ]]
                    ] [$linear] [
                        if $reduced [result [
                            float color@[i] = texture2DRect(tex0, tc + tapoffset(@curtapoffset)).r;
                            @(if $aodepthformat [result [
                                float depth@[i] = texture2DRect(tex1, depthtc + depthoffset(@curtapoffset)).r;
                            ]] [result [
                                float depth@[i] = dot(texture2DRect(tex1, depthtc + depthoffset(@curtapoffset)).rgb, gdepthunpackparams);
                            ]])
                        ]] [result [
                            vec2 tc@[i] = tc + tapoffset(@curtapoffset);
                            float color@[i] = texture2DRect(tex0, tc@[i]).r;
                            @(if $aodepthformat [result [
                                float depth@[i] = texture2DRect(tex1, tc@[i]).r;
                            ]] [result [
                                float depth@[i] = dot(texture2DRect(tex1, tc@[i]).rgb, gdepthunpackparams);
                            ]])
                        ]]
                    ] [
                        if $reduced [result [
                            float color@[i] = texture2DRect(tex0, tc + tapoffset(@curtapoffset)).r;
                            @(gdepthunpack [depth@[i]] tex1 [depthtc + depthoffset(@curtapoffset)])
                        ]] [result [
                            vec2 tc@[i] = tc + tapoffset(@curtapoffset);
                            float color@[i] = texture2DRect(tex0, tc@[i]).r;
                            @(gdepthunpack [depth@[i]] tex1 [tc@[i]])
                        ]]
                    ])
                    depth@[i] -= depth;
                    float weight@[i] = exp(@(-f 0 (* $curtap $curtap))*bilateralparams.x - depth@[i]*depth@[i]*bilateralparams.y); 
                    weights += weight@[i];
                    color += weight@[i] * color@[i];
                ]
            ])
            @(if (&& (=s $filterdir "x") $packed) [
                if $aodepthformat [result [
                    gl_FragColor.rg = vec2(color / weights, depth);
                ]] [result [
                    @(if $upscaled [gpackdepth packdepth depth] [result [
                        #define packdepth vals.rgb
                    ]])
                    gl_FragColor = vec4(packdepth, color / weights);
                ]]
            ] [result [
                gl_FragColor = vec4(color / weights, 0.0, 0.0, 1.0);
            ]])
        }
    ]
]

bilateralshader = [
    bilateralvariantshader (format "bilateralx%1%2" $arg1 $arg2) $arg1 $arg2 x
    bilateralvariantshader (format "bilateraly%1%2" $arg1 $arg2) $arg1 $arg2 y
]

////////////////////////////////////////////////
//
// separable blur with up to 7 taps
//
////////////////////////////////////////////////

blurshader = [
    shader 0 $arg1 [
        uniform float offsets[8];
        void main(void)
        {
            gl_Position = gl_Vertex;
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
            vec2 tc1 = gl_MultiTexCoord0.xy, tc2 = gl_MultiTexCoord0.xy;
            tc1.@arg3 += offsets[1];
            tc2.@arg3 -= offsets[1];
            gl_TexCoord[1].xy = tc1;
            gl_TexCoord[2].xy = tc2;
            @(loopconcat i (min (- $arg2 1) 2) [concatword [
                tc1.@arg3 = gl_MultiTexCoord0.@arg3 + offsets[@@(+ $i 2)];
                tc2.@arg3 = gl_MultiTexCoord0.@arg3 - offsets[@@(+ $i 2)];
                gl_TexCoord[@@(+ (* $i 2) 3)].xy = tc1;
                gl_TexCoord[@@(+ (* $i 2) 4)].xy = tc2;
            ]])
        } 
    ] [
        @(if (=s $arg4 "2DRect") [result [
            #extension GL_ARB_texture_rectangle : enable
        ]])
        uniform float weights[8];
        uniform float offsets[8];
        uniform sampler@[arg4] tex0;
        void main(void)
        {
            #define texval(coords) texture@[arg4](tex0, (coords))
            vec4 val = texval(gl_TexCoord[0].xy) * weights[0];
            @(loopconcat i $arg2 [
                if (< $i 3) [result [
                    val += weights[@@(+ $i 1)] * (texval(gl_TexCoord[@@(+ (* $i 2) 1)].xy) + texval(gl_TexCoord[@@(+ (* $i 2) 2)].xy));
                ]] [result [
                    val += weights[@@(+ $i 1)] * 
                    @(if (=s $arg3 "x") [result [
                        (texval(vec2(gl_TexCoord[0].x + offsets[@@(+ $i 1)], gl_TexCoord[0].y)) + texval(vec2(gl_TexCoord[0].x - offsets[@@(+ $i 1)], gl_TexCoord[0].y)));
                    ]] [result [
                        (texval(vec2(gl_TexCoord[0].x, gl_TexCoord[0].y + offsets[@@(+ $i 1)])) + texval(vec2(gl_TexCoord[0].x, gl_TexCoord[0].y - offsets[@@(+ $i 1)])));
                    ]])
                ]]
            ])
            gl_FragColor = val;
        }
    ]
]

loop i 7 [
    blurshader (format "blurx%1" (+ $i 1)) (+ $i 1) x 2D
    blurshader (format "blury%1" (+ $i 1)) (+ $i 1) y 2D
    if (> $i 0) [
        altshader (format "blurx%1" (+ $i 1)) (format "blurx%1" $i)
        altshader (format "blury%1" (+ $i 1)) (format "blury%1" $i)
    ]
    if $usetexrect [
        blurshader (format "blurx%1rect" (+ $i 1)) (+ $i 1) x 2DRect
        blurshader (format "blury%1rect" (+ $i 1)) (+ $i 1) y 2DRect
        if (> $i 0) [
            altshader (format "blurx%1rect" (+ $i 1)) (format "blurx%1rect" $i)
            altshader (format "blury%1rect" (+ $i 1)) (format "blury%1rect" $i)
        ]
    ]
]

////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////

fsvs = [
    void main(void)
    {
        gl_Position = gl_Vertex;   // woohoo, no mvp :) 
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
]

fsps = [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    void main(void)
    {
        vec4 sample = texture2DRect(tex0, gl_TexCoord[0].xy);
]

setup4corners = [
    gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(-1.5, -1.5);
    gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2( 1.5, -1.5);
    gl_TexCoord[3].xy = gl_MultiTexCoord0.xy + vec2(-1.5,  1.5);
    gl_TexCoord[4].xy = gl_MultiTexCoord0.xy + vec2( 1.5,  1.5);
]

sample4corners = [
    vec4 s00 = texture2DRect(tex0, gl_TexCoord[1].xy);
    vec4 s02 = texture2DRect(tex0, gl_TexCoord[2].xy);
    vec4 s20 = texture2DRect(tex0, gl_TexCoord[3].xy);
    vec4 s22 = texture2DRect(tex0, gl_TexCoord[4].xy);
]

// some simple ones that just do an effect on the RGB value...

lazyshader 0 "invert" [ @fsvs } ] [ @fsps gl_FragColor = 1.0 - sample; } ]
lazyshader 0 "gbr"    [ @fsvs } ] [ @fsps gl_FragColor = sample.yzxw; } ]
lazyshader 0 "bw"     [ @fsvs } ] [ @fsps gl_FragColor = vec4(dot(sample.xyz, vec3(0.333))); } ]

// sobel

lazyshader 0 "sobel" [ @fsvs @setup4corners } ] [
    @fsps
    @sample4corners

        vec4 t = s00 + s20 - s02 - s22;
        vec4 u = s00 + s02 - s20 - s22;
        gl_FragColor = sample + t*t + u*u;
    }
]

// rotoscope

lazyshader 0 "rotoscope" [
    uniform vec4 params;
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;

        // stuff two sets of texture coordinates into each one to get around hardware attribute limits
        gl_TexCoord[1] = vec4(-1.0, -1.0,  1.0, 0.0)*params.x + gl_MultiTexCoord0.xyyx;
        gl_TexCoord[2] = vec4(-1.0,  0.0, -1.0, 1.0)*params.x + gl_MultiTexCoord0.xyyx;
        gl_TexCoord[3] = vec4(-1.0,  1.0,  0.0, 1.0)*params.x + gl_MultiTexCoord0.xyyx;
        gl_TexCoord[4] = vec4( 0.0, -1.0,  1.0, 1.0)*params.x + gl_MultiTexCoord0.xyyx;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    void main(void)
    {
        #define t11 gl_TexCoord[0]
        #define t00_12 gl_TexCoord[1]
        #define t01_20 gl_TexCoord[2]
        #define t02_21 gl_TexCoord[3]
        #define t10_22 gl_TexCoord[4]
        vec4 c00 = texture2DRect(tex0, t00_12.xy);
        vec4 c01 = texture2DRect(tex0, t01_20.xy);
        vec4 c02 = texture2DRect(tex0, t02_21.xy);
        vec4 c10 = texture2DRect(tex0, t10_22.xy);
        vec4 c11 = texture2DRect(tex0, t11.xy);
        vec4 c12 = texture2DRect(tex0, t00_12.wz);
        vec4 c20 = texture2DRect(tex0, t01_20.wz);
        vec4 c21 = texture2DRect(tex0, t02_21.wz);
        vec4 c22 = texture2DRect(tex0, t10_22.wz);

        vec4 diag1 = c00 - c22;
        vec4 diag2 = c02 - c20;
        vec4 xedge = (c01 - c21)*2.0 + diag1 + diag2;
        vec4 yedge = (c10 - c12)*2.0 + diag1 - diag2;
        xedge *= xedge;
        yedge *= yedge;

        vec4 xyedge = xedge + yedge;
        float sobel = step(max(xyedge.x, max(xyedge.y, xyedge.z)), 0.1);

        float hue = dot(c11.xyz, vec3(1.0));
        c11 /= hue;
        vec3 cc = step(vec3(0.2, 0.8, 1.5), vec3(hue));
        c11 *= dot(cc, vec3(0.5, 0.5, 1.5)); 
        
        gl_FragColor = c11 * max(cc.z, sobel);
        
    }
]

blur3shader = [
    lazyshader 0 $arg1 [ 
        void main(void)
        {
            gl_Position = gl_Vertex;
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + vec2(@(if $arg2 -0.5 0.0), @(if $arg3 -0.5 0.0));
            gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(@(if $arg2  0.5 0.0), @(if $arg3  0.5 0.0));
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform sampler2DRect tex0; 
        void main(void)
        {
            gl_FragColor = 0.5*(texture2DRect(tex0, gl_TexCoord[0].xy) + texture2DRect(tex0, gl_TexCoord[1].xy));
        }
    ]
]
blur3shader hblur3 1 0
blur3shader vblur3 0 1

blur5shader = [
    lazyshader 0 $arg1 [ 
        @fsvs 
            gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(@(if $arg2 -1.333 0.0), @(if $arg3 -1.333 0.0));
            gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2(@(if $arg2  1.333 0.0), @(if $arg3  1.333 0.0));
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform sampler2DRect tex0; 
        void main(void)
        {
            gl_FragColor = 0.4*texture2DRect(tex0, gl_TexCoord[0].xy) + 0.3*(texture2DRect(tex0, gl_TexCoord[1].xy) + texture2DRect(tex0, gl_TexCoord[2].xy));
        }
    ]
]
blur5shader hblur5 1 0
blur5shader vblur5 0 1

rotoscope = [
    clearpostfx
    if (>= $numargs 1) [addpostfx rotoscope 0 0 0 $arg1]
    if (>= $numargs 2) [
        if (= $arg2 1) [addpostfx hblur3; addpostfx vblur3]
        if (= $arg2 2) [addpostfx hblur5; addpostfx vblur5]
    ]
]

////////////////////////////////////////////////
//
// miscellaneous effect shaders: 
//
////////////////////////////////////////////////

// wobbles the vertices of an explosion sphere
// and generates all texcoords 
// and blends the edge color
// and modulates the texture
explosionshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        uniform vec3 center;
        uniform vec4 animstate;
        @(if (>= (strstr $arg1 "3d") 0) [result [uniform vec4 texgenS, texgenT;]])
        @(if (>= (strstr $arg1 "soft") 0) [result [
            uniform vec3 softparams;
            varying float softdepth;
        ]]) 
        void main(void)
        {
            vec4 wobble = vec4(gl_Vertex.xyz*(1.0 + 0.5*abs(fract(dot(gl_Vertex.xyz, center) + animstate.w*2.0) - 0.5)), gl_Vertex.w);
            gl_Position = gl_ModelViewProjectionMatrix * wobble;
            @(if (>= (strstr $arg1 "soft") 0) [result [
                softdepth = softparams.y + (gl_ModelViewMatrix * wobble).z*softparams.x;
            ]])

            gl_FrontColor = gl_Color;
        
            @arg2 
        } 
    ] [ 
        @(if (>= (strstr $arg1 "soft") 0) [result [
            @(gfetchdefs tex2)
            uniform vec3 softparams;
            varying float softdepth;
        ]])
        uniform sampler2D tex0, tex1;
        void main(void)
        {
            vec2 dtc = gl_TexCoord[0].xy + texture2D(tex0, @arg3.xy).xy*0.1; // use color texture as noise to distort texcoords
            vec4 diffuse = texture2D(tex0, dtc);
            vec4 blend = texture2D(tex1, gl_TexCoord[1].xy); // get blend factors from modulation texture 
            diffuse *= blend.a*4.0; // dup alpha into RGB channels + intensify and over saturate
            diffuse.b += 0.5 - blend.a*0.5; // blue tint 

            @(if (>= (strstr $arg1 "soft") 0) [result [
                gl_FragColor.rgb = diffuse.rgb * gl_Color.rgb;

                @(gdepthunpack depth tex2 gl_FragCoord.xy)
                gl_FragColor.a = diffuse.a * max(clamp(depth*softparams.x - softdepth, 0.0, 1.0) * gl_Color.a, softparams.z);
            ]] [result [
                gl_FragColor = diffuse * gl_Color;
            ]])
        }
    ]
]

loop i 2 [
    explosionshader (concatword "explosion2d" (at ["" "soft"] $i)) [
        //blow up the tex coords
        float dtc = 1.768 - animstate.x*1.414; // -2, 2.5; -> -2*sqrt(0.5), 2.5*sqrt(0.5);
        dtc *= dtc;
        gl_TexCoord[0].xy = animstate.w*0.4 + dtc*gl_Vertex.xy;
        gl_TexCoord[1].xy = gl_Vertex.xy*0.5 + 0.5; //using wobble makes it look too spherical at a distance
    ] "gl_TexCoord[1]"
    explosionshader (concatword "explosion3d" (at ["" "soft"] $i)) [
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        vec2 texgen = vec2(dot(texgenS, gl_Vertex), dot(texgenT, gl_Vertex)); 
        gl_TexCoord[1].xy = texgen;
        gl_TexCoord[2].xy = texgen - animstate.w*0.5;
    ] "gl_TexCoord[2]"
]

shader 0 "particlenotexture" [
    #pragma CUBE2_fog
    uniform vec4 colorscale;
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_Color * colorscale;
    } 
] [
    void main(void)
    {
        gl_FragColor = gl_TexCoord[0];
    }
]

particleshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        uniform vec4 colorscale;
        @(if (>= (strstr $arg1 "soft") 0) [result [
            uniform vec3 softparams;
            varying float softdepth;
        ]])
        void main(void)
        {
            gl_Position = ftransform();
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
            gl_TexCoord[1] = gl_Color * colorscale; 

            @(if (>= (strstr $arg1 "soft") 0) [result [
                vec2 offset = gl_MultiTexCoord0.xy*2.82842712474619 - 1.4142135623731;
                gl_TexCoord[2].xyz = vec3(offset, 1.0);
                gl_TexCoord[3].xyz = vec3(offset, softparams.y + (gl_ModelViewMatrix * gl_Vertex).z*softparams.x);
            ]])
        }
    ] [
        @(if (>= (strstr $arg1 "soft") 0) [result [
            @(gfetchdefs tex2)
            uniform vec3 softparams;
            varying float softdepth;
        ]])
        uniform sampler2D tex0;
        void main(void)
        {
            vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);

            @(if (>= (strstr $arg1 "soft") 0) [result [
                @(gdepthunpack depth tex2 gl_FragCoord.xy)
                diffuse.a *= clamp(depth*softparams.x - dot(gl_TexCoord[2].xyz, gl_TexCoord[3].xyz), 0.0, 1.0);
            ]])

            gl_FragColor = diffuse * gl_TexCoord[1];
        }
    ]     
]

loop i 2 [
    particleshader (concatword "particle" (at ["" "soft"] $i))
]

shader 0 "blendbrush" [
    uniform vec4 texgenS, texgenT;
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = vec2(dot(texgenS, gl_Vertex), dot(texgenT, gl_Vertex));
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = texture2D(tex0, gl_TexCoord[0].xy) * gl_Color;
    }
]

lazyshader 0 "moviergb" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        gl_FragColor = texture2DRect(tex0, gl_TexCoord[0].xy);
    }
]

lazyshader 0 "movieyuv" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        gl_FragColor = vec4(dot(sample, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample, vec3(-0.148224, -0.290992, 0.439216)) + 0.501961,
                            dot(sample, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            0.0);
    }
]

lazyshader 0 "moviey" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + vec2(-1.5, 0.0);
        gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(-0.5, 0.0);
        gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2( 0.5, 0.0);
        gl_TexCoord[3].xy = gl_MultiTexCoord0.xy + vec2( 1.5, 0.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        vec3 sample2 = texture2DRect(tex0, gl_TexCoord[1].xy).rgb;
        vec3 sample3 = texture2DRect(tex0, gl_TexCoord[2].xy).rgb;
        vec3 sample4 = texture2DRect(tex0, gl_TexCoord[3].xy).rgb;
        gl_FragColor = vec4(dot(sample3, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            dot(sample2, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            dot(sample1, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            dot(sample4, vec3(0.256788, 0.504125, 0.097905)) + 0.062745);
    }
]

lazyshader 0 "movieu" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + vec2(-3.0, 0.0);
        gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(-1.0, 0.0);
        gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2( 1.0, 0.0);
        gl_TexCoord[3].xy = gl_MultiTexCoord0.xy + vec2( 3.0, 0.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        vec3 sample2 = texture2DRect(tex0, gl_TexCoord[1].xy).rgb;
        vec3 sample3 = texture2DRect(tex0, gl_TexCoord[2].xy).rgb;
        vec3 sample4 = texture2DRect(tex0, gl_TexCoord[3].xy).rgb;
        gl_FragColor = vec4(dot(sample3, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                            dot(sample2, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                            dot(sample1, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                            dot(sample4, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961);
    }
]

lazyshader 0 "moviev" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + vec2(-3.0, 0.0);
        gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(-1.0, 0.0);
        gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2( 1.0, 0.0);
        gl_TexCoord[3].xy = gl_MultiTexCoord0.xy + vec2( 3.0, 0.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        vec3 sample2 = texture2DRect(tex0, gl_TexCoord[1].xy).rgb;
        vec3 sample3 = texture2DRect(tex0, gl_TexCoord[2].xy).rgb;
        vec3 sample4 = texture2DRect(tex0, gl_TexCoord[3].xy).rgb;
        gl_FragColor = vec4(dot(sample3, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample2, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample1, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample4, vec3(0.439216, -0.367788, -0.071427)) + 0.501961);
    }
]

///////////////////////////////////////////////////
//
// reflective/refractive water shaders:
//
///////////////////////////////////////////////////

shader 0 "refractmask" [
    void main(void)
    {
        gl_Position = ftransform();
    }
] [
    @(gfetchdefs tex0)
    uniform vec3 gdepthpackparams;
    void main(void)
    {
        @(if (= $gdepthformat 1) [result [
            vec3 packdepth = gfetch(tex0, gl_FragCoord.xy).rgb;
            float depth = dot(packdepth, gdepthunpackparams);
        ]] [result [
            @(gdepthunpack depth tex0 gl_FragCoord.xy) 
            @(gpackdepth packdepth depth)
        ]])
        gl_FragColor = vec4(packdepth, 0.0);
    }
]

lazyshader 0 "waterminimap" [
    void main(void)
    {
        gl_Position = ftransform();
    }
] [
    uniform vec3 watercolor;
    void main(void)
    {
        gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);
        gl_FragData[1] = vec4(0.5, 0.5, 1.0, 0.0);
        gl_FragData[2] = vec4(watercolor, 1.0);
    }
]

watershader = [
  lazyshader 0 $arg1 [
    uniform vec3 camera;
    varying vec3 surface;
    @(? (>= (strstr $arg1 "reflect") 0) [
        uniform mat4 raymatrix;
        varying vec3 esurface;
    ])
    @(gdepthinterp 1)
    void main(void)
    {
        gl_Position = ftransform();
        surface = gl_Vertex.xyz;
        @(? (>= (strstr $arg1 "reflect") 0) [
            esurface = (raymatrix * gl_Vertex).xyz;
        ])
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy * 0.1;
        @(gdepthpackvert 1)
    }
  ] [
    @(gfetchdefs [tex7 tex8 tex9])
    uniform float millis;
    uniform vec3 camera;
    uniform mat4 linearworldmatrix;
    varying vec3 surface;
    uniform sampler2D tex0, tex1;
    uniform vec4 viewsize;
    uniform vec3 watercolor, waterdeepcolor, waterdeepfade;
    uniform float waterfog, waterspec;
    uniform vec4 waterreflect, waterrefract;
    uniform float refractdepth;
    @(? (>= (strstr $arg1 "caustics") 0) [
        uniform vec3 causticsS, causticsT;
        uniform vec3 causticsblend;
        uniform sampler2D tex2, tex3;
    ])
    @(? (>= (strstr $arg1 "env") 0) [
        uniform samplerCube tex4;
    ])
    @(? (>= (strstr $arg1 "reflect") 0) [
        uniform mat4 raymatrix;
        varying vec3 esurface;
    ])
    @(gdepthinterp 1)
    void main(void)
    {
        vec3 camdir = camera - surface, camvec = normalize(camdir);
        vec3 bump = texture2D(tex0, gl_TexCoord[0].xy + millis*0.05 + 0.23).rgb;
        vec3 bump2 = texture2D(tex0, gl_TexCoord[0].xy - millis*0.05 + 0.71).rgb;
        vec3 bump3 = texture2D(tex0, gl_TexCoord[0].xy + millis*vec2(0.05, -0.05) + 0.49).rgb;
        vec3 bump4 = texture2D(tex0, gl_TexCoord[0].xy + millis*vec2(-0.05, 0.05) + 0.67).rgb;
        bump = normalize(bump + bump2 + bump3 + bump4 - 2.0);
        vec2 rtc = bump.xy * waterrefract.w;

        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterrefract.xyz;
        float rdepth = dot(gfetch(tex7, rtc).rgb, gdepthunpackparams);
        vec3 rpos = (linearworldmatrix * vec4(rdepth*rtc, rdepth, 1.0)).xyz;

        @(if (>= (strstr $arg1 "under") 0) [result [
            float above = rpos.z - surface.z; 
            float alpha = clamp(above, 0.0, 1.0);
        ]] [result [
            vec3 rdir = rpos.xyz - camera;
            float raydepth = length(rdir)*(1.0 + camdir.z/rdir.z);
            float deep = surface.z - rpos.z;
            float alpha = clamp(deep*0.5, 0.0, 1.0);

            @(? (>= (strstr $arg1 "caustics") 0) [
                vec2 ctc = vec2(dot(causticsS, rpos.xyz), dot(causticsT, rpos.xyz));
                float caustics = causticsblend.x*texture2D(tex2, ctc).r + causticsblend.y*texture2D(tex3, ctc).r + causticsblend.z;
                rcolor *= caustics;
            ])

            rcolor = mix(rcolor, watercolor, clamp(raydepth * waterfog, 0.0, 1.0));
            rcolor = mix(rcolor, waterdeepcolor, clamp(deep * waterdeepfade, 0.0, 1.0));
        ]])

        vec3 reflectdir = -reflect(camvec, bump);
        reflectdir.z = abs(reflectdir.z);
        @(if (>= (strstr $arg1 "reflect") 0) [result [
            reflectdir.z += 0.125;
            vec3 edir = (raymatrix * vec4(waterreflect.w*reflectdir, 0.0)).xyz;
            vec3 epos = esurface + edir;
            @(loopconcat i 4 [result [
                @(gdepthunpackproj [edepth@[i]] tex9 epos [
                    if(edepth@[i] < epos.z || edepth@[i] > esurface.z) epos += edir;
                ] [
                    edepth@[i] = edepth@[i]*gdepthscale.y + gdepthscale.z;
                    if(gdepthscale.x < epos.z*edepth@[i] || gdepthscale.x > esurface.z*edepth@[i]) epos += edir;
                ])
            ]])
            vec2 etc = epos.xy/epos.z;
            vec3 reflect = gfetchclamp(tex8, etc).rgb * waterreflect.xyz;
            float edgefade = clamp(4.0*(0.5 - max(abs(etc.x*viewsize.z - 0.5)*0.75 + 0.25/4.0, abs(etc.y*viewsize.w - 0.5))), 0.0, 1.0);
            float fresnel = 0.25 + 0.75*pow(clamp(1.0 - dot(camvec, bump), 0.0, 1.0), 4.0);
            rcolor = mix(rcolor, reflect, fresnel*edgefade);
        ]] [if (>= (strstr $arg1 "env") 0) [result [
            vec3 reflect = textureCube(tex4, reflectdir).rgb*0.5;
            float fresnel = 0.5*pow(clamp(1.0 - dot(camvec, bump), 0.0, 1.0), 4.0);
            rcolor = mix(rcolor, reflect, fresnel);
        ]]])

        gl_FragData[0] = vec4(0.0, 0.0, 0.0, waterspec*alpha);
        gl_FragData[1] = vec4(bump*0.5+0.5, 0.0);
        gl_FragData[2] = vec4(rcolor*alpha, alpha);
        @(gdepthpackfrag)
    }
  ]  
]

watershader "water"
watershader "watercaustics"
watershader "waterenv"
watershader "waterenvcaustics"
watershader "waterreflect"
watershader "waterreflectcaustics"
watershader "underwater"

causticshader = [
    lazyshader 0 $arg1 [
        void main(void)
        {
            gl_Position = gl_Vertex;
        }
    ] [
        @(gfetchdefs tex9)
        uniform mat4 causticsmatrix;
        uniform vec3 causticsblend;
        uniform sampler2D tex0, tex1;
        uniform vec4 waterdeepfade;
        void main(void)
        {
            @(gdepthunpack depth tex9 gl_FragCoord.xy [
                vec3 ctc = (causticsmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).xyz;
            ] [
                vec4 ctc = causticsmatrix * vec4(gl_FragCoord.xy, depth, 1.0);
                ctc.xyz /= ctc.w;
            ])
            float caustics = causticsblend.x*texture2D(tex0, ctc.xy).r + causticsblend.y*texture2D(tex1, ctc.xy).r + causticsblend.z;
            caustics *= clamp(ctc.z, 0.0, 1.0) * clamp(1.0 - ctc.z*waterdeepfade.w, 0.0, 1.0);
            gl_FragColor.rgb = vec3(0.5 + caustics);
        }
    ]
]
causticshader caustics

waterfogshader = [
    lazyshader 0 $arg1 [
        void main(void)
        {
            gl_Position = gl_Vertex;
        }
    ] [
        @(gfetchdefs tex9)
        uniform mat4 waterfogmatrix;
        uniform vec3 fogcolor, fogparams;
        uniform float waterdeep;
        uniform vec3 waterdeepcolor, waterdeepfade;
        void main(void)
        {
            @(gdepthunpack depth tex9 gl_FragCoord.xy [
                float fogbelow = (waterfogmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).z;
                #define fogcoord depth 
            ] [
                vec3 pos = (waterfogmatrix * vec4(gl_FragCoord.xy, depth, 1.0)).xzw;
                pos.xy /= pos.z;
                #define fogbelow pos.y
                #define fogcoord pos.x
            ])
            float foglerp = clamp((fogparams.x - fogcoord) * fogparams.z, 0.0, 1.0);
            foglerp *= clamp(2.0*fogbelow + 0.5, 0.0, 1.0);
            vec3 fogcolor = mix(fogcolor, waterdeepcolor, clamp(fogbelow*waterdeepfade, 0.0, 1.0));
            gl_FragColor.rgb = fogcolor;
            gl_FragColor.a = foglerp;
        }
    ]
]
waterfogshader waterfog

lazyshader 0 "lava" [
    varying mat3 world;
    @(gdepthinterp)
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.z));
        world = mat3(tangent, bitangent, gl_Normal);
        @(gdepthpackvert)
    }
] [
    uniform sampler2D tex0, tex1;
    uniform float lavaglow, lavaspec;
    varying mat3 world;
    @(gdepthinterp)
    void main(void)
    {
        vec3 diffuse = texture2D(tex0, gl_TexCoord[0].xy).rgb;
        vec3 bump = texture2D(tex1, gl_TexCoord[0].xy).rgb*2.0-1.0;
        vec3 bumpw = world * bump;
        gl_FragData[0] = vec4(diffuse, lavaspec);
        gl_FragData[1] = vec4(bumpw*0.5+0.5, 0.0);
        gl_FragData[2] = vec4(diffuse*lavaglow, 1.0);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "waterfallenv" [
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world;
    @(gdepthinterp 1)
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        camdir = camera.xyz - gl_Vertex.xyz;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.z));
        world = mat3(tangent, bitangent, gl_Normal);
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform samplerCube tex3;
    uniform sampler2D tex0, tex1;
    uniform vec3 waterfallcolor;
    uniform float waterfallspec;
    uniform vec4 waterfallrefract;
    uniform float refractdepth;
    varying vec3 camdir;
    varying mat3 world;
    @(gdepthinterp 1)
    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 diffuse = texture2D(tex0, gl_TexCoord[0].xy).rgb;
        vec3 bump = texture2D(tex1, gl_TexCoord[0].xy).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * waterfallrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterfallrefract.xyz;

        float invfresnel = dot(camvec, bumpw);
        vec3 env = textureCube(tex3, 2.0*bumpw*invfresnel - camvec).rgb;
        env *= 0.1 + 0.4*pow(clamp(1.0 - invfresnel, 0.0, 1.0), 2.0);

        gl_FragData[0] = vec4(0.0, 0.0, 0.0, waterfallspec*(1.0 - dot(diffuse, vec3(0.33))));
        gl_FragData[1] = vec4(bumpw*0.5+0.5, 0.0);
        gl_FragData[2] = vec4(mix(rcolor, waterfallcolor, diffuse) + env, 1.0);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "waterfall" [
    varying mat3 world;
    @(gdepthinterp 1)
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.z));
        world = mat3(tangent, bitangent, gl_Normal);
        @(gdepthpackvert 1)
    }
] [ 
    @(gfetchdefs [tex7 tex8])
    uniform sampler2D tex0, tex1;
    uniform vec3 waterfallcolor;
    uniform float waterfallspec;
    uniform vec4 waterfallrefract;
    uniform float refractdepth;
    varying mat3 world;
    @(gdepthinterp 1)
    void main(void)
    {
        vec3 diffuse = texture2D(tex0, gl_TexCoord[0].xy).rgb;
        vec3 bump = texture2D(tex1, gl_TexCoord[0].xy).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * waterfallrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterfallrefract.xyz;

        gl_FragData[0] = vec4(0.0, 0.0, 0.0, waterfallspec*(1.0 - dot(diffuse, vec3(0.33))));
        gl_FragData[1] = vec4(bumpw*0.5+0.5, 0.0);
        gl_FragData[2] = vec4(mix(rcolor, waterfallcolor, diffuse), 1.0);
        @(gdepthpackfrag)
    }
]
altshader waterfallenv waterfall

lazyshader 0 "glassenv" [
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world;
    @(gdepthinterp 1)
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        camdir = camera.xyz - gl_Vertex.xyz;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.z));
        world = mat3(tangent, bitangent, gl_Normal);
        @(gdepthpackvert 1)
    }
] [ 
    @(gfetchdefs [tex7 tex8])
    uniform samplerCube tex0;
    uniform sampler2D tex1;
    uniform float glassspec;
    uniform vec4 glassrefract;
    uniform float refractdepth;
    varying vec3 camdir;
    varying mat3 world;
    @(gdepthinterp 1)
    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 bump = texture2D(tex1, gl_TexCoord[0].xy).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * glassrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb;
        rcolor *= glassrefract.xyz;
      
        float invfresnel = dot(camvec, bumpw);
        vec3 env = textureCube(tex0, 2.0*bumpw*invfresnel - camvec).rgb;
        env *= 0.1 + 0.4*pow(clamp(1.0 - invfresnel, 0.0, 1.0), 2.0);
  
        gl_FragData[0] = vec4(0.0, 0.0, 0.0, glassspec);
        gl_FragData[1] = vec4(bumpw*0.5+0.5, 0.0);
        gl_FragData[2] = vec4(rcolor + env, 1.0);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "glass" [
    varying mat3 world;
    @(gdepthinterp 1)
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(gl_Normal.z));
        world = mat3(tangent, bitangent, gl_Normal);
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform sampler2D tex1;
    uniform float glassspec;
    uniform vec4 glassrefract;
    uniform float refractdepth;
    varying mat3 world;
    @(gdepthinterp 1)
    void main(void)
    {
        vec3 bump = texture2D(tex1, gl_TexCoord[0].xy).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * glassrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb;
        rcolor *= glassrefract.xyz;
        
        gl_FragData[0] = vec4(0.0, 0.0, 0.0, glassspec);
        gl_FragData[1] = vec4(bumpw*0.5+0.5, 0.0);
        gl_FragData[2] = vec4(rcolor, 1.0); 
        @(gdepthpackfrag)
    }
]
altshader glassenv glass

defershader 0 "grass" [
  loop i 2 [
    variantshader 0 "grass" (? $i 0 -1) [
        @(gdepthinterp)
        @(if $i [result [uniform vec4 blendmapparams;]])
        void main(void)
        {
            gl_Position = ftransform();
            gl_FrontColor = gl_Color;
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
            @(if $i [result [
                gl_TexCoord[1].xy = (gl_Vertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ]])
            @(gdepthpackvert)
        }
    ] [
        uniform sampler2D tex0;
        uniform float grasstest;
        @(gdepthinterp)
        @(if $i [result [uniform sampler2D tex1;]])
        void main(void)
        {
            vec4 color = texture2D(tex0, gl_TexCoord[0].xy) * gl_Color;
            @(if $i [result [
                color.a *= texture2D(tex1, gl_TexCoord[1].xy).r;
            ]])
            if(color.a <= grasstest)
                discard;
            gl_FragData[0] = vec4(color.rgb, 0.0);
            gl_FragData[1] = vec4(0.5, 0.5, 1.0, 0.0); 
            gl_FragData[2] = vec4(0.0, 0.0, 0.0, 1.0);
            @(gdepthpackfrag)
        }
    ]
  ]
]

shader 0 "overbrightdecal" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);
        gl_FragColor = mix(gl_Color, diffuse, gl_Color.a);
    }
]

shader 0 "saturatedecal" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);
        diffuse.rgb *= 2.0;
        gl_FragColor = diffuse * gl_Color;
    }
]

shader 0 "decal" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture2D(tex0, gl_TexCoord[0].xy);
    }
]

shader 0 "skyboxoverbright" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform sampler2D tex0;
    uniform vec2 overbrightparams;
    void main(void)
    {
        vec3 color = texture2D(tex0, gl_TexCoord[0].xy).rgb;
        float lum = dot(vec3(@lumweights), color);
        float scale = 1.0 + overbrightparams.x*clamp(lum - overbrightparams.y, 0.0, 1.0);
        gl_FragColor.rgb = gl_Color.rgb * color * scale;
    }
]

lazyshader 0 "tqaamaskmovement" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    @(gfetchdefs tex0)
    void main(void)
    {
        float mask = gfetch(tex0, gl_TexCoord[0].xy).a;
        @(? $msaasamples [mask = step(0.75, mask);])
        gl_FragColor = vec4(mask, 0.0, 0.0, 0.25);
    }
]

lazyshader 0 "tqaaresolve" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    @(gfetchdefs tex2)
    uniform sampler2DRect tex0, tex1;
    uniform mat4 reprojectmatrix;
    uniform vec3 maxvelocity;
    uniform vec4 quincunx;
    void main(void)
    {
        @(gdepthunpack depth tex2 gl_TexCoord[0].xy [
            vec4 prevtc = reprojectmatrix * vec4(depth*gl_TexCoord[0].xy, depth, 1.0);
        ] [
            vec4 prevtc = reprojectmatrix * vec4(gl_TexCoord[0].xy, depth, 1.0);
        ])
        prevtc.xy /= prevtc.w;
        vec2 vel = prevtc.xy - gl_TexCoord[0].xy;

        vec4 color = texture2DRect(tex0, gl_TexCoord[0].xy + quincunx.xy);
        float vscale = color.a*maxvelocity.x*inversesqrt(dot(vel, vel) + 1e-6);
        vec4 prevcolor = texture2DRect(tex1, gl_TexCoord[0].xy + quincunx.zw + vel*vscale);

        float weight = 0.5 - 0.5*color.a;
        weight *= clamp(1.0 - maxvelocity.z*abs(color.a - prevcolor.a), 0.0, 1.0);
        gl_FragColor = mix(color, prevcolor, weight);
    }
]

lazyshader 0 "tqaaresolvemasked" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    @(gfetchdefs tex2)
    uniform sampler2DRect tex0, tex1, tex3;
    uniform mat4 reprojectmatrix;
    uniform vec3 maxvelocity;
    uniform vec4 quincunx;
    uniform float movemaskscale;
    void main(void)
    {
        @(gdepthunpack depth tex2 gl_TexCoord[0].xy [
            vec4 prevtc = reprojectmatrix * vec4(depth*gl_TexCoord[0].xy, depth, 1.0);
        ] [
            vec4 prevtc = reprojectmatrix * vec4(gl_TexCoord[0].xy, depth, 1.0);
        ])
        prevtc.xy /= prevtc.w;
        vec2 vel = prevtc.xy - gl_TexCoord[0].xy;

        float mask = clamp(2.0*texture2DRect(tex3, (gl_TexCoord[0].xy + quincunx.xy)*movemaskscale).r, 0.0, 1.0);
        vec4 color = texture2DRect(tex0, gl_TexCoord[0].xy + quincunx.xy*(1.0 - mask));
        float vscale = color.a*maxvelocity.x*inversesqrt(dot(vel, vel) + 1e-6);
        vec4 prevcolor = texture2DRect(tex1, gl_TexCoord[0].xy + quincunx.zw + vel*vscale);
        float prevmask = clamp(4.0*texture2DRect(tex3, (gl_TexCoord[0].xy + quincunx.zw + vel*vscale)*movemaskscale).r, 0.0, 1.0);

        float weight = 0.5 - 0.5*color.a;
        weight *= clamp(1.0 - maxvelocity.z*abs(color.a - prevcolor.a), 0.0, 1.0);
        weight *= 1.0 - max(mask, prevmask);
        gl_FragColor = mix(color, prevcolor, weight);
    }
]

smaaopt = [ >= (strstr $smaaopts $arg1) 0 ]
smaashaders = [
    smaapreset = $arg1   
    smaaopts = $arg2
    exec "data/smaa.cfg"
]

fxaaopt = [ >= (strstr $fxaaopts $arg1) 0 ]
fxaashaders = [
    fxaapreset = $arg1
    fxaaopts = $arg2
    exec "data/fxaa.cfg"
]

