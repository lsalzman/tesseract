// standard shader definitions

lazyshader = [
    defershader $arg1 $arg2 [
        shader @arg1 @arg2 [@@arg3] [@@arg4]
    ]
]

ginterpvert = [
    if (|| $gdepthformat $arg1) [result [
        uniform vec2 lineardepthscale;
        uniform vec3 gdepthpackparams;
        varying float lineardepth;
    ]]
]
msaainterpvert = [ginterpvert $msaasamples]

ginterpfrag = [
    result [
        fragdata(0, gcolor, vec4)
        fragdata(1, gnormal, vec4)
        fragdata(2, gglow, vec4)
        @(? $gdepthformat [fragdata(3, gdepth, vec4)])
        @(? (|| $gdepthformat $arg1) [
            uniform vec2 lineardepthscale;
            uniform vec3 gdepthpackparams;
            varying float lineardepth;
        ])
    ]
]
msaainterpfrag = [ginterpfrag $msaasamples]

gdepthpackvert = [
    if (|| $gdepthformat $arg1) [result [
        lineardepth = dot(lineardepthscale, gl_Position.zw);
    ]]
]
msaapackvert = [gdepthpackvert $msaasamples]

gpackdepth = [
    result [
        vec3 @arg1 = @arg2 * gdepthpackparams;
        @arg1 = vec3(@arg1.x, fract(@arg1.yz));
        @arg1.xy -= @arg1.yz * (1.0/255.0);
    ]
]

ghashdepth = [
    if $arg3 [
        arg1 = [(@arg1 + 5.0*@arg3)]
    ] 
    if $arg2 [result [
        @arg2*0.76 + mix(0.75, 0.25, @arg2)*fract(@arg1*mix(-1.0/192.0, -1.0/64.0, @arg2))
    ]] [result [
        0.75*fract(@arg1*(-1.0/192.0))
    ]]
]
        
gdepthpackfrag = [
    result [
        @(if $gdepthformat [
            if (> $gdepthformat 1) [result [
                gdepth.r = lineardepth;
            ]] [result [
                @(gpackdepth packdepth lineardepth)
                gdepth.rgb = packdepth;
            ]]
        ])
        gnormal.a = @(if $arg1 [ghashdepth lineardepth $arg2 $arg3] [? $arg2 $arg2 [0.0]]);
    ]
]
msaapackfrag = [gdepthpackfrag $msaasamples $arg1 $arg2]

gdepthunpackparams = [
    result [
        uniform vec3 gdepthscale;
        uniform vec3 gdepthunpackparams;
    ]
]

gdepthunpack = [
    if $arg7 [
        if $arg8 [result [
            vec3 @[arg8] = gfetch(@[arg2], @[arg3]).rgb;
            float @[arg1] = dot(@[arg8], gdepthunpackparams); 
            @arg4
        ]] [result [
            float @[arg1] = dot(gfetch(@[arg2], @[arg3]).rgb, gdepthunpackparams); 
            @arg4
        ]]
    ] [if (|| $gdepthformat $arg6) [
        if (|| (> $gdepthformat 1) $arg6) [result [
            float @[arg1] = gfetch(@[arg2], @[arg3]).r;
            @arg4
        ]] [result [
            float @[arg1] = dot(gfetch(@[arg2], @[arg3]).rgb, gdepthunpackparams); 
            @arg4
        ]]
    ] [if (=s $arg5 []) [result [
        float @[arg1] = gdepthscale.x / (gfetch(@[arg2], @[arg3]).r*gdepthscale.y + gdepthscale.z);
    ]] [result [
        float @[arg1] = gfetch(@[arg2], @[arg3]).r;
        @arg5
    ]]]]
]

gdepthunpackproj = [
    if (|| $gdepthformat $arg6) [
        if (|| (> $gdepthformat 1) $arg6) [result [
            float @[arg1] = gfetchproj(@[arg2], @[arg3]).r;
            @arg4
        ]] [result [
            float @[arg1] = dot(gfetchproj(@[arg2], @[arg3]).rgb, gdepthunpackparams); 
            @arg4
        ]]
    ] [if (=s $arg5 []) [result [
        float @[arg1] = gdepthscale.x / (gfetchproj(@[arg2], @[arg3]).r*gdepthscale.y + gdepthscale.z);
    ]] [result [
        float @[arg1] = gfetchproj(@[arg2], @[arg3]).r;
        @arg5
    ]]]
]

gfetchdefs = [
    gfetchprefix = (? $arg3 $arg3 "gfetch")
    if (? (>= $numargs 2) $arg2 $msaasamples) [result [
        uniform sampler2DMS @(prettylist $arg1);
        #define @[gfetchprefix](sampler, coords) texelFetch(sampler, ivec2(coords), 0)
        #define @[gfetchprefix]proj(sampler, coords) texelFetch(sampler, ivec2(coords.xy / coords.z), 0)
        #if __VERSION__ >= 130 || defined(GL_EXT_gpu_shader4)
            #define @[gfetchprefix]clamp(sampler, coords) texelFetch(sampler, clamp(ivec2(coords), ivec2(0), textureSize(sampler)-1), 0)
        #else
            #define @[gfetchprefix]clamp(sampler, coords) texelFetch(sampler, ivec2(clamp(coords, vec2(0), vec2(textureSize(sampler)-1))), 0)
        #endif
        @(if (! $arg3) [gdepthunpackparams])
    ]] [result [
        uniform sampler2DRect @(prettylist $arg1);
        #define @[gfetchprefix](sampler, coords) texture2DRect(sampler, coords)
        #define @[gfetchprefix]proj(sampler, coords) texture2DRectProj(sampler, coords)
        #define @[gfetchprefix]clamp(sampler, coords) texture2DRect(sampler, coords)
        @(if (! $arg3) [gdepthunpackparams])
    ]]
]

shader 0 "null" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = vec4(1.0, 0.0, 1.0, 1.0);
    }
]

///////////////////////////////////////////////////
//
// used for rendering to the HUD
//
///////////////////////////////////////////////////

shader 0 "hud" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        #pragma CUBE2_variantoverride vec4 color = texture2D(tex0, texcoord0).rrrg;
        vec4 color = texture2D(tex0, texcoord0);
        fragcolor = colorscale * color;
    }
]

shader 0 "hudrgb" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor.rgb = colorscale.rgb * texture2D(tex0, texcoord0).rgb;
        fragcolor.a   = colorscale.a;
    }
]

shader 0 "hudnotexture" [
    attribute vec4 vvertex, vcolor;
    uniform mat4 hudmatrix;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        color = vcolor;
    }
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

shader 0 "hudrect" [ 
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = colorscale * texture2DRect(tex0, texcoord0);
    }
]

shader 0 "hud3d" [
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        color = vcolor;
    }
] [
    uniform sampler3D tex0;
    varying vec3 texcoord0;
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color * texture3D(tex0, texcoord0);
    }
]

shader 0 "hudcubemap" [ 
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform samplerCube tex0;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = colorscale * textureCube(tex0, texcoord0);
    }
]

shader 0 "forcecubemap" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    uniform samplerCube tex0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = vec4(textureCube(tex0, vec3(0.0, 0.0, 1.0)).rgb, 0.0);
    }
]

//////////////////////////////////////////////////////////////////////
//
// fogged variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "fogged" [
    #pragma CUBE2_fog
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying vec2 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        color = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color * texture2D(tex0, texcoord0);
    }
]

shader 0 "foggednotexture" [
    #pragma CUBE2_fog
    attribute vec4 vvertex, vcolor;
    uniform mat4 camprojmatrix;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vcolor;
    }
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// LDR variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "ldr" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform float ldrscale;
    varying vec2 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        color = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color * texture2D(tex0, texcoord0);
    }
]

shader 0 "ldrnotexture" [
    attribute vec4 vvertex, vcolor;
    uniform mat4 camprojmatrix;
    uniform float ldrscale;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// for filling the z-buffer only (i.e. multi-pass rendering, OQ)
//
//////////////////////////////////////////////////////////////////////

shader 0 "nocolor" [
    attribute vec4 vvertex;
    uniform mat4 camprojmatrix;
    void main() { gl_Position = camprojmatrix * vvertex; } 
] [
    void main() {}
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

// worldtype:
//    e -> reserve envmap texture slot
//    r -> envmap reflection
//    g -> glow
//    G -> pulse glow
//    b -> blendmap
//    a -> refractive

wtopt = [ >= (strstr $worldtype $arg1) 0 ]

worldvariantshader = [
    worldtype = $arg2
    stype = (? (wtopt "e") 3 1)
    srow = -1
    if (wtopt "G") [
        stype = (+ $stype 0x10)
        defuniformparam "glowcolor" 1 1 1 // glow color
        defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
        defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
    ] [if (wtopt "g") [
        defuniformparam "glowcolor" 1 1 1  // glow color
    ]]
    if (wtopt "r") [
        defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
    ]
    if (wtopt "b") [
        srow = 0
    ]
    if (wtopt "a") [
        stype = (+ $stype 4)
        srow = 1
    ]
    variantshader $stype $arg1 $srow [
        attribute vec4 vvertex;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        uniform vec2 texgenscroll;
        varying vec3 normal;
        @(msaainterpvert)
        varying vec2 texcoord0;
        @(? (wtopt "r") [uniform vec3 camera; varying vec3 camvecw;])
        @(? (wtopt "G") [uniform float millis; varying float pulse;])
        @(? (wtopt "b") [
            uniform vec4 blendmapparams;
            varying vec2 texcoord1;
        ])

        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;
            texcoord0 = vtexcoord0 + texgenscroll;
            @(? (wtopt "b") [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ])
            normal = vnormal;
    
            @(msaapackvert)

            @(? (wtopt "r") [camvecw = camera - vvertex.xyz;])

            @(? (wtopt "G") [
                pulse = abs(fract(millis*pulseglowspeed.x)*2.0 - 1.0);
            ])
        }
    ] [
        @(if (wtopt "a") [result [
            @(gfetchdefs refractlight)
            uniform vec4 refractparams;
        ]])
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        @(? $msaasamples [uniform float hashid;])
        varying vec3 normal;
        @(msaainterpfrag)
        varying vec2 texcoord0;
        @(? (wtopt "g") [uniform sampler2D glowmap;])
        @(? (wtopt "G") [varying float pulse;])
        @(? (wtopt "r") [uniform samplerCube envmap; varying vec3 camvecw;])
        @(? (wtopt "b") [
            uniform float blendlayer;
            uniform sampler2D blendmap;
            varying vec2 texcoord1;
        ])

        void main(void)
        {
            vec4 diffuse = texture2D(diffusemap, texcoord0);   

            gcolor.rgb = diffuse.rgb*colorparams.rgb;
            gcolor.a = 0.0;
            gnormal.rgb = normal*0.5+0.5;

            @(if (wtopt "g") [result [
                vec3 glow = texture2D(glowmap, texcoord0).rgb;
                @(if (wtopt "G") [result [
                    vec3 pulsecol = mix(glowcolor.xyz, pulseglowcolor.xyz, pulse);
                ]])
                glow *= @(? (wtopt "G") "pulsecol" "glowcolor.xyz"); 
                gglow.rgb = glow;
            ]] [result [
                gglow.rgb = vec3(0.0);
            ]])

            @(? (wtopt "r") [
                vec3 reflect = textureCube(envmap, 2.0*normal*dot(camvecw, normal) - camvecw).rgb;
                gcolor.rgb *= 1.0 - envscale.xyz;
                gglow.rgb += reflect*(0.5*envscale.xyz);
            ])

            @(? (wtopt "a") [
                #define alpha 1.0
                vec3 rlight = gfetch(refractlight, gl_FragCoord.xy).rgb;
                gglow.rgb += rlight * refractparams.xyz;
            ] [
                #define alpha colorparams.a
            ])

            @(msaapackfrag "" hashid)

            @(? (wtopt "b") [
                float blend = abs(texture2D(blendmap, texcoord1).r - blendlayer);
                gcolor.rgb *= blend;
                gnormal.rgb *= blend;
                gnormal.a *= blendlayer;
                gglow.rgb *= blend;
                gglow.a = blendlayer;
            ] [
                gglow.a = alpha;
            ])
        }
    ]
]

worldshader = [
    defershader (? (>= (strstr $arg2 "e") 0) 3 1) $arg1 [
        worldvariantshader @arg1 @arg2
        worldvariantshader @arg1 @(concatword $arg2 "b")
        worldvariantshader @arg1 @(concatword $arg2 "a")
    ]
]

worldvariantshader "stdworld" ""
worldvariantshader "stdworld" "b"
worldvariantshader "stdworld" "a"

worldshader "glowworld" "g"
worldshader "pulseglowworld" "gG"

worldshader "envworldalt" "e"
worldshader "envworld" "er"
altshader envworld envworldalt 
fastshader envworld envworldalt 1

worldshader "envglowworldalt" "eg"
worldshader "envglowworld" "erg"
altshader envglowworld envglowworldalt
fastshader envglowworld envglowworldalt 1

worldshader "envpulseglowworldalt" "egG"
worldshader "envpulseglowworld "ergG"
altshader envpulseglowworld envpulseglowworldalt
fastshader envpulseglowworld envpulseglowworldalt 1

// bumptype:
//    e -> reserve envmap texture slot
//    o -> orthonormalize
//    t -> tangent space cam
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    p -> parallax
//    P -> steep parallax (7 steps)
//    g -> glow
//    G -> pulse glow
//    b -> blendmap
//    a -> refractive

btopt = [ >= (strstr $bumptype $arg1) 0 ]

bumpvariantshader = [
    bumptype = $arg2
    stype = (? (btopt "e") 3 1)
    srow = -1
    if (btopt "G") [
        stype = (+ $stype 0x10)
        defuniformparam "glowcolor" 1 1 1 // glow color
        defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
        defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
    ] [if (btopt "g") [
        defuniformparam "glowcolor" 1 1 1  // glow color
    ]]
    if (btopt "S") [
        defuniformparam "specscale" 6 6 6 // spec map multiplier
    ] [if (btopt "s") [
        defuniformparam "specscale" 1 1 1 // spec multiplier
    ]]
    if (|| (btopt "p") (btopt "P")) [
        defuniformparam "parallaxscale" 0.06 -0.03 // parallax scaling
    ]
    if (btopt "R") [
        defuniformparam "envscale" 1 1 1 // reflectivity map multiplier
    ] [if (btopt "r") [
        defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
    ]]
    if (btopt "b") [
        srow = 0
    ]
    if (btopt "a") [
        stype = (+ $stype 4)
        srow = 1
    ]
    variantshader $stype $arg1 $srow [
        attribute vec4 vvertex, vtangent;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        uniform vec2 texgenscroll;
        varying mat3 world;
        @(ginterpvert (|| $msaasamples [btopt "a"]))
        varying vec2 texcoord0;
        @(? (|| (btopt "t") (btopt "r")) [uniform vec3 camera;])
        @(? (btopt "t") [varying vec3 camvects;])
        @(? (btopt "r") [varying vec3 camvecw;])
        @(? (btopt "G") [uniform float millis; varying float pulse;])
        @(? (btopt "b") [
            uniform vec4 blendmapparams;
            varying vec2 texcoord1;
        ])

        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;
            texcoord0 = vtexcoord0 + texgenscroll;

            @(gdepthpackvert (|| $msaasamples [btopt "a"]))

            @(? (btopt "b") [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ])

            vec3 binormal = cross(vnormal, vtangent.xyz) * vtangent.w;
            // calculate tangent -> world transform
            world = mat3(vtangent.xyz, binormal, vnormal);
       
            @(? (btopt "t") [camvects = (camera - vvertex.xyz) * world;])
            @(? (btopt "r") [camvecw = camera - vvertex.xyz;])

            @(? (btopt "G") [
                pulse = abs(fract(millis*pulseglowspeed.x)*2.0 - 1.0);
            ])
        }
    ] [
        @(if (btopt "a") [result [
            @(gfetchdefs [refractlight refractmask])
            uniform vec4 refractparams;
            uniform float refractdepth;
        ]])
        uniform vec4 colorparams;
        uniform sampler2D diffusemap, normalmap;
        @(? $msaasamples [uniform float hashid;])
        varying mat3 world;
        @(ginterpfrag (|| $msaasamples [btopt "a"]))
        varying vec2 texcoord0;
        @(? (btopt "t") [varying vec3 camvects;])
        @(? (btopt "g") [uniform sampler2D glowmap;])
        @(? (btopt "G") [varying float pulse;])
        @(? (btopt "r") [uniform samplerCube envmap; varying vec3 camvecw;])
        @(? (btopt "b") [
            uniform float blendlayer;
            uniform sampler2D blendmap;
            varying vec2 texcoord1;
        ])

        void main(void)
        {
            @(? (btopt "t") [vec3 camdirts = normalize(camvects);])
            @(cond [btopt "p"] [result [
                float height = texture2D(normalmap, texcoord0).a;
                vec2 dtc = texcoord0 + camdirts.xy*(height*parallaxscale.x + parallaxscale.y);
            ]] [btopt "P"] [result [
                const float step = -1.0/7.0;
                vec3 duv = vec3((step*parallaxscale.x/camdirts.z)*camdirts.xy, step);
                vec3 htc = vec3(texcoord0 + duv.xy*parallaxscale.y, 1.0);
                vec4 height = texture2D(normalmap, htc.xy);
                @@(loopconcat i 7 [concatword [
                    htc += height.w < htc.z ? duv : vec3(0.0);
                    height = texture2D(normalmap, htc.xy);
                ]])
                #define dtc htc.xy
                #define bump height.xyz    
            ]] [result [
                #define dtc texcoord0
            ]])

            vec4 diffuse = texture2D(diffusemap, dtc);

            gcolor.rgb = diffuse.rgb*colorparams.rgb;
            @(if (btopt "s") [
                if (btopt "S") [result [
                    gcolor.a = diffuse.a*specscale.x * 0.5;
                ]] [result [
                    gcolor.a = specscale.x * 0.5;
                ]]
            ] [result [
                gcolor.a = 0.0;
            ]])

            @(? (! (btopt "P")) [vec3 bump = texture2D(normalmap, dtc).rgb;])

            bump = bump*2.0 - 1.0;
            vec3 bumpw = world * bump;
            gnormal.rgb = bumpw*0.5 + 0.5;

            @(if (btopt "g") [result [
                vec3 glow = texture2D(glowmap, dtc).rgb;
                @(if (btopt "G") [result [
                    vec3 pulsecol = mix(glowcolor.xyz, pulseglowcolor.xyz, pulse);
                ]])
                glow *= @(? (btopt "G") "pulsecol" "glowcolor.xyz"); 
                gglow.rgb = glow;
            ]] [result [
                gglow.rgb = vec3(0.0);
            ]])
 
            @(if (btopt "r") [result [
                vec3 camvecwn = normalize(camvecw);
                float invfresnel = dot(camvecwn, bumpw);
                vec3 rvec = 2.0*bumpw*invfresnel - camvecwn;
                vec3 reflect = textureCube(envmap, rvec).rgb;
                @(if (btopt "R") [result [
                    float rmod = envscale.xyz*diffuse.a;
                ]] [result [
                    #define rmod envscale.xyz
                ]])
                gcolor.rgb = mix(gcolor.rgb, reflect, rmod*clamp(1.0 - invfresnel, 0.0, 1.0));
            ]])

            @(? (btopt "a") [
                #define alpha 1.0
                vec2 rtc = bump.xy*refractparams.w;
                float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(refractmask, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
                vec3 rlight = gfetch(refractlight, gl_FragCoord.xy + rtc*rmask).rgb;
                gglow.rgb += rlight * refractparams.xyz;
            ] [
                #define alpha colorparams.a
            ])

            @(gdepthpackfrag $msaasamples "" hashid)

            @(? (btopt "b") [
                float blend = abs(texture2D(blendmap, texcoord1).r - blendlayer);
                gcolor *= blend;
                gnormal.rgb *= blend;
                gnormal.a *= blendlayer;
                gglow.rgb *= blend;
                gglow.a = blendlayer;
            ] [
                gglow.a = alpha;
            ])
        }
    ]
]

bumpshader = [
    defershader (? (>= (strstr $arg2 "e") 0) 3 1) $arg1 [
        bumpvariantshader @arg1 @arg2
        bumpvariantshader @arg1 @(concatword $arg2 "b")
        bumpvariantshader @arg1 @(concatword $arg2 "a")
    ]
]

bumpshader "bumpworld" ""
bumpshader "bumpspecworld" "ots"
fastshader bumpspecworld bumpworld 2
altshader bumpspecworld bumpworld
bumpshader "bumpspecmapworld" "otsS"
fastshader bumpspecmapworld bumpworld 2
altshader bumpspecmapworld bumpworld

bumpshader "bumpglowworld" "g"
bumpshader "bumpspecglowworld" "otsg"
altshader bumpspecglowworld bumpglowworld
bumpshader "bumpspecmapglowworld" "otsSg"
fastshader bumpspecmapglowworld bumpglowworld 2
altshader bumpspecmapglowworld bumpglowworld

bumpshader "bumppulseglowworld" "gG"
bumpshader "bumpspecpulseglowworld" "otsgG"
altshader bumpspecpulseglowworld bumppulseglowworld
bumpshader "bumpspecmappulseglowworld" "otsSgG"
fastshader bumpspecmappulseglowworld bumppulseglowworld 2
altshader bumpspecmappulseglowworld bumppulseglowworld

bumpshader "bumpparallaxworld" "pot"
fastshader bumpparallaxworld bumpworld 1
altshader bumpparallaxworld bumpworld
bumpshader "bumpspecparallaxworld" "pots"
fastshader bumpspecparallaxworld bumpparallaxworld 2
fastshader bumpspecparallaxworld bumpworld 1
altshader bumpspecparallaxworld bumpworld
bumpshader "bumpspecmapparallaxworld" "potsS"
fastshader bumpspecmapparallaxworld bumpparallaxworld 2
fastshader bumpspecmapparallaxworld bumpworld 1
altshader bumpspecmapparallaxworld bumpworld

bumpshader "bumpparallaxglowworld" "potg"
fastshader bumpparallaxglowworld bumpglowworld 1
altshader bumpparallaxglowworld bumpglowworld
bumpshader "bumpspecparallaxglowworld" "potsg"
fastshader bumpspecparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecparallaxglowworld bumpglowworld 1
altshader bumpspecparallaxglowworld bumpglowworld
bumpshader "bumpspecmapparallaxglowworld" "potsSg"
fastshader bumpspecmapparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecmapparallaxglowworld bumpglowworld 1
altshader bumpspecmapparallaxglowworld bumpglowworld

bumpshader "bumpparallaxpulseglowworld" "potgG"
fastshader bumpparallaxpulseglowworld bumppulseglowworld 1
altshader bumpparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecparallaxpulseglowworld" "potsgG"
fastshader bumpspecparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecmapparallaxpulseglowworld" "potsSgG"
fastshader bumpspecmapparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecmapparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecmapparallaxpulseglowworld bumppulseglowworld

bumpshader "bumpenvworldalt" "e"
bumpshader "bumpenvworld" "eor"
altshader bumpenvworld bumpenvworldalt
fastshader bumpenvworld bumpenvworldalt 2
bumpshader "bumpenvspecworld" "eotsr"
altshader bumpenvspecworld bumpenvworldalt
fastshader bumpenvspecworld bumpenvworldalt 2
bumpshader "bumpenvspecmapworld" "eotsSrR"
altshader bumpenvspecmapworld bumpenvworldalt
fastshader bumpenvspecmapworld bumpenvworldalt 2

bumpshader "bumpenvglowworldalt" "eg"
bumpshader "bumpenvglowworld" "eorg"
altshader bumpenvglowworld bumpenvglowworldalt
fastshader bumpenvglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecglowworld" "eotsrg"
altshader bumpenvspecglowworld bumpenvglowworldalt
fastshader bumpenvspecglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecmapglowworld" "eotsSrRg"
altshader bumpenvspecmapglowworld bumpenvglowworldalt
fastshader bumpenvspecmapglowworld bumpenvglowworldalt 2

bumpshader "bumpenvpulseglowworldalt" "egG"
bumpshader "bumpenvpulseglowworld" "eorgG"
altshader bumpenvpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecpulseglowworld" "eotsrgG"
altshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecmappulseglowworld" "eotsSrRgG"
altshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt 2

bumpshader "bumpenvparallaxworldalt" "epot"
altshader bumpenvparallaxworldalt bumpenvworldalt
bumpshader "bumpenvparallaxworld" "epotr"
altshader bumpenvparallaxworld bumpenvparallaxworldalt
fastshader bumpenvparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecparallaxworld" "epotsr"
altshader bumpenvspecparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecmapparallaxworld" "epotsSrR"
altshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecmapparallaxworld bumpenvworldalt 1

bumpshader "bumpenvparallaxglowworldalt" "epotg"
altshader bumpenvparallaxglowworldalt bumpenvglowworldalt
bumpshader "bumpenvparallaxglowworld" "epotrg"
altshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecparallaxglowworld" "epotsrg"
altshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecmapparallaxglowworld" "epotsSrRg"
altshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecmapparallaxglowworld bumpenvglowworldalt 1

bumpshader "bumpenvparallaxpulseglowworldalt" "epotgG"
altshader bumpenvparallaxpulseglowworldalt bumpenvpulseglowworldalt
bumpshader "bumpenvparallaxpulseglowworld" "epotrgG"
altshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt
fastshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt 2
fastshader bumpenvparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecparallaxpulseglowworld" "epotsrgG"
altshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecmapparallaxpulseglowworld" "epotsSrRgG"
altshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvpulseglowworldalt 1

//bumpshader "steepworld" "Pot"

shader 0 shadowmapworld [
    attribute vec4 vvertex;
    uniform mat4 shadowmatrix;
    void main(void)
    {
        gl_Position = shadowmatrix * vvertex;
    }
] [
    void main(void)
    {
    }
]

loop i 2 [
    variantshader 1 "rsmworld" (- $i 1) [
        attribute vec4 vvertex;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        uniform mat4 rsmmatrix;
        uniform vec2 texgenscroll;
        uniform vec4 colorparams;
        uniform vec3 rsmdir;
        varying vec4 normal;
        varying vec2 texcoord0;
        @(? (= $i 1) [
            uniform vec4 blendmapparams;
            varying vec2 texcoord1;
        ])
        void main(void)
        {
            gl_Position = rsmmatrix * vvertex;
            texcoord0 = vtexcoord0 + texgenscroll;
            @(if (= $i 1) [result [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ]])
            normal = vec4(vnormal, dot(vnormal, rsmdir));
        }
    ] [
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        varying vec4 normal;
        varying vec2 texcoord0;
        @(? (= $i 1) [
            uniform float blendlayer;
            uniform sampler2D blendmap;
            varying vec2 texcoord1;
        ])
        fragdata(0, gcolor, vec4)
        fragdata(1, gnormal, vec4)
        void main(void)
        {
            vec4 diffuse = texture2D(diffusemap, texcoord0);   

            @(if (= $i 2) [result [
                #define alpha 1.0
            ]] [result [
                #define alpha colorparams.a
            ]])

            gcolor.rgb = normal.w*diffuse.rgb*colorparams.rgb;
            gnormal = vec4(normal.xyz*0.5+0.5, 0.0);

            @(if (= $i 1) [result [
                float blend = abs(texture2D(blendmap, texcoord1).r - blendlayer);
                gcolor.rgb *= blend;
                gcolor.a = blendlayer;
                gnormal *= blend;
            ]] [result [
                gcolor.a = alpha;
            ]])
        }
    ]
]

shader 0 "rsmsky" [
    attribute vec4 vvertex;
    uniform mat4 rsmmatrix;
    void main(void)
    {
        gl_Position = rsmmatrix * vvertex;
    }
] [
    fragdata(0, gcolor, vec4)
    fragdata(1, gnormal, vec4)
    void main(void)
    {
        gcolor = vec4(0.0, 0.0, 0.0, 1.0);
        gnormal = vec4(0.5, 0.5, 0.5, 0.0);
    }
]

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

// skeletal animation for matrices and dual quaternions

skelanimdefs = [
    result [
        attribute vec4 vboneweight, vboneindex; 
        #pragma CUBE2_uniform animdata
        uniform vec4 animdata[@@(min $maxvsuniforms $maxskelanimdata)];
    ]
]

skelmatanim = [
    result [
        int index = int(vboneindex.x);
        @(if (= $arg1 1) [result [
            vec4 mx = animdata[index];
            vec4 my = animdata[index+1];
            vec4 mz = animdata[index+2];
        ]] [result [
            vec4 mx = animdata[index] * vboneweight.x;
            vec4 my = animdata[index+1] * vboneweight.x;
            vec4 mz = animdata[index+2] * vboneweight.x;
            index = int(vboneindex.y);
            mx += animdata[index] * vboneweight.y;
            my += animdata[index+1] * vboneweight.y;
            mz += animdata[index+2] * vboneweight.y;
        ]])
        @(if (>= $arg1 3) [result [
            index = int(vboneindex.z);
            mx += animdata[index] * vboneweight.z;
            my += animdata[index+1] * vboneweight.z;
            mz += animdata[index+2] * vboneweight.z;
        ]])
        @(if (>= $arg1 4) [result [
            index = int(vboneindex.w);
            mx += animdata[index] * vboneweight.w;
            my += animdata[index+1] * vboneweight.w;
            mz += animdata[index+2] * vboneweight.w;
        ]])

        vec4 opos = vec4(dot(mx, vvertex), dot(my, vvertex), dot(mz, vvertex), vvertex.w);

        @(if $arg2 [result [
            vec3 onormal = vec3(dot(mx.xyz, vnormal), dot(my.xyz, vnormal), dot(mz.xyz, vnormal));
        ]])

        @(if $arg3 [result [
            vec3 otangent = vec3(dot(mx.xyz, vtangent.xyz), dot(my.xyz, vtangent.xyz), dot(mz.xyz, vtangent.xyz));
        ]])
    ]
]

skelquatanim = [
    result [
        int index = int(vboneindex.x);
        @(if (= $arg1 1) [result [
            vec4 dqreal = animdata[index];
            vec4 dqdual = animdata[index+1];
        ]] [result [ 
            vec4 dqreal = animdata[index] * vboneweight.x;
            vec4 dqdual = animdata[index+1] * vboneweight.x;
            index = int(vboneindex.y);
            dqreal += animdata[index] * vboneweight.y;
            dqdual += animdata[index+1] * vboneweight.y;
            @(if (>= $arg1 3) [result [
                index = int(vboneindex.z);
                dqreal += animdata[index] * vboneweight.z;
                dqdual += animdata[index+1] * vboneweight.z;
            ]])
            @(if (>= $arg1 4) [result [
                index = int(vboneindex.w);
                dqreal += animdata[index] * vboneweight.w;
                dqdual += animdata[index+1] * vboneweight.w;
            ]])
            float len = length(dqreal);
            dqreal /= len;
            dqdual /= len;
        ]])

        vec4 opos = vec4((cross(dqreal.xyz, cross(dqreal.xyz, vvertex.xyz) + vvertex.xyz*dqreal.w + dqdual.xyz) + dqdual.xyz*dqreal.w - dqreal.xyz*dqdual.w)*2.0 + vvertex.xyz, vvertex.w);

        @(if $arg2 [result [
            vec3 onormal = cross(dqreal.xyz, cross(dqreal.xyz, vnormal) + vnormal*dqreal.w)*2.0 + vnormal;
        ]])

        @(if $arg3 [result [
            vec3 otangent = cross(dqreal.xyz, cross(dqreal.xyz, vtangent.xyz) + vtangent.xyz*dqreal.w)*2.0 + vtangent.xyz;
        ]])
    ]
]

// mdltype:
//    a -> alpha test
//    B -> matrix skeletal animation
//    b -> dual-quat skeletal animation

mdlopt = [ >= (strstr $modeltype $arg1) 0 ]

shadowmodelvertexshader = [
    modeltype = $arg1
    result [
        attribute vec4 vvertex;
        @(if (|| (mdlopt "b") (mdlopt "B")) [skelanimdefs $arg2 0 0])
        uniform mat4 modelmatrix;
        @(? (mdlopt "a") [
            attribute vec2 vtexcoord0;
            uniform vec2 texscroll;
            varying vec2 texcoord0;
        ])
        void main(void)
        {
            @(cond [mdlopt "B"] [
                skelmatanim $arg2 0 0
            ] [mdlopt "b"] [
                skelquatanim $arg2 0 0
            ] [result [
                #define opos vvertex
            ]])
            
            gl_Position = modelmatrix * opos;

            @(? (mdlopt "a") [
                texcoord0 = vtexcoord0 + texscroll;
            ])
        }
    ]
]

shadowmodelfragmentshader = [
    modeltype = $arg1
    result [
        @(? (mdlopt "a") [
            uniform sampler2D tex0;
            uniform float alphatest;
            varying vec2 texcoord0;
        ])
        void main(void)
        {
            @(? (mdlopt "a") [
                vec4 color = texture2D(tex0, texcoord0);
                if(color.a <= alphatest)    
                    discard;
            ])
        }
    ]
]

shadowmodelshader = [
    shader 0 $arg1 (shadowmodelvertexshader $arg2) (shadowmodelfragmentshader $arg2)
    loop i 4 [
        variantshader 0 $arg1 0 (shadowmodelvertexshader (concatword $arg2 "B") (+ $i 1)) []
        variantshader 1 $arg1 1 (shadowmodelvertexshader (concatword $arg2 "b") (+ $i 1)) []
    ]
]

shadowmodelshader "shadowmodel" ""
shadowmodelshader "alphashadowmodel" "a"

// mdltype:
//    a -> alpha test
//    e -> envmap
//    n -> normalmap
//    m -> masks
//    d -> decal
//    B -> matrix skeletal animation
//    b -> dual-quat skeletal animation

modelvertexshader = [
    modeltype = $arg1
    result [
        attribute vec4 vvertex;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        @(if (|| (mdlopt "b") (mdlopt "B")) [skelanimdefs $arg2 1 (mdlopt "n")])
        @(? (mdlopt "n") [attribute vec4 vtangent;])
        uniform mat4 modelmatrix;
        uniform mat3 oworld;
        uniform vec3 ocamera;
        uniform vec2 texscroll;
        @(if (mdlopt "n") [result [
            varying mat3 world;
            @(if (mdlopt "e") [result [
                varying vec3 camvec;
            ]])
        ]] [result [
            varying vec3 nvec;
            @(if (mdlopt "e") [result [
                uniform vec2 envmapscale;
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        @(msaainterpvert)
        varying vec2 texcoord0;

        void main(void)
        {
            @(cond [mdlopt "B"] [
                skelmatanim $arg2 1 (mdlopt "n")
            ] [mdlopt "b"] [
                skelquatanim $arg2 1 (mdlopt "n")
            ] [result [
                #define opos vvertex
                #define onormal vnormal
                #define otangent vtangent.xyz
            ]])

            gl_Position = modelmatrix * opos;

            texcoord0 = vtexcoord0 + texscroll;
    
            @(msaapackvert)
 
            @(? (mdlopt "e") [
                vec3 camdir = normalize(ocamera - opos.xyz);
            ])

            @(if (mdlopt "n") [result [
                @(if (mdlopt "e") [result [
                    camvec = oworld * camdir;
                ]])
                // composition of tangent -> object and object -> world transforms
                //   becomes tangent -> world
                vec3 wnormal = oworld * onormal;
                vec3 wtangent = oworld * otangent;
                vec3 wbitangent = cross(wnormal, wtangent) * vtangent.w;
                world = mat3(wtangent, wbitangent, wnormal);
            ]] [result [
                nvec = oworld * onormal; 
                @(if (mdlopt "e") [result [
                    float invfresnel = dot(camdir, onormal);
                    rvec = oworld * (2.0*invfresnel*onormal - camdir);
                    rmod = envmapscale.x*max(invfresnel, 0.0) + envmapscale.y;    
                ]])
            ]])
        }
    ] 
]

modelfragmentshader = [
    modeltype = $arg1
    result [
        @(if (mdlopt "n") [result [
            varying mat3 world; 
            @(if (mdlopt "e") [result [
                uniform vec2 envmapscale;
                varying vec3 camvec;
            ]])
        ]] [result [
            varying vec3 nvec;
            @(if (mdlopt "e") [result [
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        uniform vec2 fullbright;
        uniform vec2 maskscale;
        @(? (mdlopt "a") [uniform float alphatest;])
        uniform sampler2D tex0;
        @(? (mdlopt "m") [uniform sampler2D tex1;])
        @(? (mdlopt "e") [uniform samplerCube tex2;])
        @(? (mdlopt "n") [uniform sampler2D tex3;])
        @(? (mdlopt "d") [uniform sampler2D tex4;])
        @(msaainterpfrag)
        varying vec2 texcoord0;
        uniform float aamask;

        void main(void)
        {
            vec4 diffuse = texture2D(tex0, texcoord0);

            @(? (mdlopt "a") [
                if(diffuse.a <= alphatest)
                    discard;
            ])
            
            gcolor.rgb = diffuse.rgb;

            @(? (mdlopt "d") [
                vec4 decal = texture2D(tex4, texcoord0);
                gcolor.rgb = mix(gcolor.rgb, decal.rgb, decal.a);
            ])

            @(? (mdlopt "m") [
                vec3 masks = texture2D(tex1, texcoord0).rgb;
            ])

            float spec = maskscale.x;
            @(? (mdlopt "m") [spec *= masks.r;])   // specmap in red channel
            gcolor.a = 0.5*spec;

            @(? (mdlopt "n") [
                vec3 normal = texture2D(tex3, texcoord0).rgb - 0.5;
                normal = normalize(world * normal);
            ] [
                vec3 normal = normalize(nvec);
            ])

            gnormal.rgb = 0.5*normal+0.5;

            @(if (mdlopt "m") [result [
                float gmask = max(maskscale.y*masks.g, fullbright.y); // glow mask in green channel
                gglow.rgb = diffuse.rgb*gmask;
                gcolor.rgb *= fullbright.x-gmask;
                @(if (mdlopt "e") [result [
                    @(if (mdlopt "n") [result [
                        vec3 camn = normalize(camvec);
                        float invfresnel = dot(camn, normal);
                        vec3 rvec = 2.0*invfresnel*normal - camn;
                        float rmod = envmapscale.x*clamp(invfresnel, 0.0, 1.0) + envmapscale.y;
                    ]])
                    float rmask = rmod*masks.b; // envmap mask in blue channel
                    vec3 reflect = textureCube(tex2, rvec).rgb;
                    gcolor.rgb = mix(gcolor.rgb, reflect, rmask);
                ]])
            ]] [result [
                gglow.rgb = diffuse.rgb*fullbright.y;
                gcolor.rgb *= fullbright.x-fullbright.y;
            ]])

            gglow.a = 1.0;
 
            @(msaapackfrag aamask)
        }
    ]
]

modelshader = [
    defershader 0 $arg1 [
        basemodeltype = [@@arg2]
        shader 0 @arg1 (modelvertexshader $basemodeltype) (modelfragmentshader $basemodeltype)
        loop i 4 [
            variantshader 0 @@arg1 0 (modelvertexshader (concatword "B" $basemodeltype) (+ $i 1)) []
            variantshader 0 @@arg1 1 (modelvertexshader (concatword "b" $basemodeltype) (+ $i 1)) []
        ]
    ]
]

modelshader "stdmodel" ""
modelshader "masksmodel" "m"
modelshader "envmapmodel" "me"
altshader envmapmodel masksmodel

modelshader "bumpmodel" "n"
modelshader "bumpmasksmodel" "nm"
modelshader "bumpenvmapmodel" "nme"
altshader bumpenvmapmodel bumpmasksmodel

modelshader "alphamodel" "a"
modelshader "masksalphamodel" "am"
modelshader "envmapalphamodel" "ame"
altshader envmapalphamodel masksalphamodel

modelshader "bumpalphamodel" "an"
modelshader "bumpmasksalphamodel" "anm"
modelshader "bumpenvmapalphamodel" "anme"
altshader bumpenvmapalphamodel bumpmasksalphamodel

modelshader "decalmodel" "d"
modelshader "decalmasksmodel" "dm"
modelshader "decalenvmapmodel" "dme"
altshader decalenvmapmodel decalmasksmodel

modelshader "decalbumpmodel" "dn"
modelshader "decalbumpmasksmodel" "dnm"
modelshader "decalbumpenvmapmodel" "dnme"
altshader decalbumpenvmapmodel decalbumpmasksmodel

modelshader "decalalphamodel" "da"
modelshader "decalmasksalphamodel" "dam"
modelshader "decalenvmapalphamodel" "dame"
altshader decalenvmapalphamodel decalmasksalphamodel

modelshader "decalbumpalphamodel" "dan"
modelshader "decalbumpmasksalphamodel" "danm"
modelshader "decalbumpenvmapalphamodel" "danme"
altshader decalbumpenvmapalphamodel decalbumpmasksalphamodel

rsmmodelvertexshader = [
    modeltype = $arg1
    result [
        attribute vec4 vvertex;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        @(if (|| (mdlopt "b") (mdlopt "B")) [skelanimdefs $arg2 1 0])
        uniform mat4 modelmatrix;
        uniform mat3 oworld;
        uniform vec2 texscroll;
        uniform vec3 rsmdir;
        varying vec2 texcoord0;
        varying vec4 normal;
        void main(void)
        {
            @(cond [mdlopt "B"] [
                skelmatanim $arg2 1 (mdlopt "n")
            ] [mdlopt "b"] [
                skelquatanim $arg2 1 (mdlopt "n")
            ] [result [
                #define opos vvertex
                #define onormal vnormal
            ]])

            gl_Position = modelmatrix * opos;

            texcoord0 = vtexcoord0 + texscroll;

            normal.xyz = oworld * onormal;
            normal.w = dot(normal.xyz, rsmdir);
        }
    ]
]

rsmmodelfragmentshader = [
    modeltype = $arg1
    result [
        varying vec2 texcoord0;
        varying vec4 normal;
        uniform vec2 fullbright;
        @(? (mdlopt "a") [uniform float alphatest;])
        uniform sampler2D tex0;
        fragdata(0, gcolor, vec4)
        fragdata(1, gnormal, vec4)
        void main(void)
        {
            vec4 diffuse = texture2D(tex0, texcoord0);
            @(? (mdlopt "a") [
                if(diffuse.a <= alphatest)
                    discard;
            ])
            gcolor = vec4(normal.w*diffuse.rgb, 1.0);
            gnormal = vec4(normal.xyz*0.5+0.5, 0.0);
        }
    ]
]

rsmmodelshader = [
    shader 0 $arg1 (rsmmodelvertexshader $arg2) (rsmmodelfragmentshader $arg2)
    loop i 4 [
        variantshader 0 $arg1 0 (rsmmodelvertexshader (concatword "B" $arg2) (+ $i 1)) []
        variantshader 0 $arg1 1 (rsmmodelvertexshader (concatword "b" $arg2) (+ $i 1)) []
    ]
]

rsmmodelshader "rsmmodel" ""
rsmmodelshader "rsmalphamodel "a"

rhtapoffsets12 = [
"0.0565813, 0.61211, 0.763359"
"0.375225, 0.285592, 0.987915"
"0.615192, 0.668996, 0.604938"
"0.963195, 0.355937, 0.175787"
"0.0295724, 0.484268, 0.265694"
"0.917783, 0.88702, 0.201972"
"0.408948, 0.0675985, 0.427564"
"0.19071, 0.923612, 0.0553606"
"0.968078, 0.403943, 0.847224"
"0.384503, 0.922269, 0.990844"
"0.480605, 0.342418, 0.00195318"
"0.956664, 0.923643, 0.915799"
]

rhtapoffsets20 = [
"0.0540788, 0.411725, 0.134068"
"0.0163579, 0.416211, 0.992035"
"0.692068, 0.549272, 0.886502"
"0.305795, 0.781854, 0.571337"
"0.791681, 0.139042, 0.247047"
"0.83929, 0.973663, 0.460982"
"0.0336314, 0.0867641, 0.582324"
"0.148198, 0.961974, 0.0378124"
"0.948729, 0.0713828, 0.916379"
"0.586413, 0.591845, 0.031251"
"0.00189215, 0.973968, 0.932981"
"0.435865, 0.0853603, 0.995148"
"0.36848, 0.820612, 0.942717"
"0.500107, 0.0658284, 0.623005"
"0.580187, 0.4485, 0.379223"
"0.258614, 0.0201422, 0.241005"
"0.987152, 0.441664, 0.43318"
"0.925108, 0.917203, 0.921506"
"0.988372, 0.822047, 0.12479"
"0.330393, 0.43611, 0.762566"
]

rhtapoffsets32 = [
"0.0553911, 0.675924, 0.22129"
"0.562975, 0.508286, 0.549883"
"0.574816, 0.703452, 0.0513016"
"0.981017, 0.930479, 0.243873"
"0.889309, 0.133091, 0.319071"
"0.329112, 0.00759911, 0.472213"
"0.314463, 0.985839, 0.54442"
"0.407697, 0.202643, 0.985748"
"0.998169, 0.760369, 0.792932"
"0.0917692, 0.0666829, 0.0169683"
"0.0157781, 0.632954, 0.740806"
"0.938139, 0.235878, 0.87936"
"0.442305, 0.184942, 0.0901212"
"0.578051, 0.863948, 0.799554"
"0.0698569, 0.259194, 0.667592"
"0.872494, 0.576312, 0.344157"
"0.10123, 0.930082, 0.959929"
"0.178594, 0.991302, 0.046205"
"0.690176, 0.527543, 0.930509"
"0.982025, 0.389447, 0.0344554"
"0.033845, 0.0156865, 0.963866"
"0.655293, 0.154271, 0.640553"
"0.317881, 0.598621, 0.97998"
"0.247261, 0.398206, 0.121586"
"0.822626, 0.985076, 0.655232"
"0.00201422, 0.434278, 0.388348"
"0.511399, 0.977416, 0.278695"
"0.32371, 0.540147, 0.361187"
"0.365856, 0.41493, 0.758232"
"0.792871, 0.979217, 0.0309763"
"0.0509049, 0.459151, 0.996277"
"0.0305185, 0.13422, 0.306009"
]

rsmtapoffsets12 = [
"0.031084, 0.572114"
"0.040671, 0.95653"
"0.160921, 0.367819"
"0.230518, 0.134321"
"0.247078, 0.819415"
"0.428665, 0.440522"
"0.49846, 0.80717"
"0.604285, 0.0307766"
"0.684075, 0.283001"
"0.688304, 0.624171"
"0.833995, 0.832414"
"0.975397, 0.189911"
]

rsmtapoffsets20 = [
"0.00240055, 0.643992"
"0.0356464, 0.851616"
"0.101733, 0.21876"
"0.166119, 0.0278085"
"0.166438, 0.474999"
"0.24991, 0.766405"
"0.333714, 0.130407"
"0.400681, 0.374781"
"0.424067, 0.888211"
"0.448511, 0.678962"
"0.529383, 0.213568"
"0.608569, 0.47715"
"0.617996, 0.862528"
"0.631784, 0.0515881"
"0.740969, 0.20753"
"0.788203, 0.41923"
"0.794066, 0.615141"
"0.834504, 0.836612"
"0.89446, 0.0677863"
"0.975609, 0.446056"
]

rsmtapoffsets32 = [
"0.0262032, 0.215221"
"0.0359769, 0.0467256"
"0.0760799, 0.713481"
"0.115087, 0.461431"
"0.119488, 0.927444"
"0.22346, 0.319747"
"0.225964, 0.679227"
"0.238626, 0.0618425"
"0.243326, 0.535066"
"0.29832, 0.90826"
"0.335208, 0.212103"
"0.356438, 0.751969"
"0.401021, 0.478664"
"0.412027, 0.0245297"
"0.48477, 0.320659"
"0.494311, 0.834621"
"0.515007, 0.165552"
"0.534574, 0.675536"
"0.585357, 0.432483"
"0.600102, 0.94139"
"0.650182, 0.563571"
"0.672336, 0.771816"
"0.701811, 0.187078"
"0.734207, 0.359024"
"0.744775, 0.924466"
"0.763628, 0.659075"
"0.80735, 0.521281"
"0.880585, 0.107684"
"0.898505, 0.904047"
"0.902536, 0.718989"
"0.928022, 0.347802"
"0.971243, 0.504885"
]

radiancehintsshader = [
  numtaps = (cond [> $arg1 20] 32 [> $arg1 12] 20 12)
  shader 0 [radiancehints@arg1] [
    attribute vec4 vvertex;
    attribute vec3 vtexcoord0;
    uniform mat4 rsmtcmatrix;
    varying vec3 rhcenter;
    varying vec2 rsmcenter;
    void main(void)
    {
        gl_Position = vvertex;
        rhcenter = vtexcoord0;
        rsmcenter = (rsmtcmatrix * vec4(vtexcoord0, 1.0)).xy;
    }
  ] [
    uniform sampler2DRect tex0, tex1, tex2; 
    uniform mat4 rsmworldmatrix;
    uniform vec2 rsmspread;
    uniform float rhatten, rhspread;
    varying vec3 rhcenter;
    varying vec2 rsmcenter;
    fragdata(0, rhr, vec4)
    fragdata(1, rhg, vec4)
    fragdata(2, rhb, vec4)

    void calcrhsample(vec3 rhtap, vec2 rsmtap, inout vec4 shr, inout vec4 shg, inout vec4 shb)
    {
        vec3 rhpos = rhcenter + rhtap*rhspread;
        vec2 rsmtc = rsmcenter + rsmtap*rsmspread;
        float rsmdepth = texture2DRect(tex0, rsmtc).x;
        vec3 rsmcolor = texture2DRect(tex1, rsmtc).rgb;
        vec3 rsmnormal = texture2DRect(tex2, rsmtc).xyz*2.0 - 1.0;
        vec3 rsmpos = (rsmworldmatrix * vec4(rsmtc, rsmdepth, 1.0)).xyz;

        vec3 dir = rhpos - rsmpos;
        float dist = dot(dir, dir);
        if(dist > 0.000049) dir = normalize(dir);
        float atten = clamp(dot(dir, rsmnormal), 0.0, 1.0) / (0.1 + dist*rhatten);
        rsmcolor *= atten;

        shr += vec4(rsmcolor.r*dir, rsmcolor.r);
        shg += vec4(rsmcolor.g*dir, rsmcolor.g);
        shb += vec4(rsmcolor.b*dir, rsmcolor.b);
    }

    void main(void)
    {
        vec4 shr = vec4(0.0), shg = vec4(0.0), shb = vec4(0.0);

        @(loopconcat i $numtaps [result [
            calcrhsample(vec3(@(at $[rhtapoffsets@numtaps] $i))*2.0 - 1.0, vec2(@(at $[rsmtapoffsets@numtaps] $i))*2.0 - 1.0, shr, shg, shb);
        ]])

        rhr = shr * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
        rhg = shg * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
        rhb = shb * (vec4(0.5, 0.5, 0.5, 1.0)/@(+f $numtaps)) + vec4(0.5, 0.5, 0.5, 0.0);
    }
  ]
]

lazyshader 0 radiancehintsborder [
    attribute vec4 vvertex;
    attribute vec3 vtexcoord0;
    varying vec3 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler3D tex3, tex4, tex5;
    uniform vec3 bordercenter, borderrange, borderscale;
    varying vec3 texcoord0;
    fragdata(0, rhr, vec4)
    fragdata(1, rhg, vec4)
    fragdata(2, rhb, vec4)

    void main(void)
    {
        float outside = clamp(borderscale.z*(abs(texcoord0.z - bordercenter.z) - borderrange.z), 0.0, 1.0);
        vec3 tc = vec3(texcoord0.xy, clamp(texcoord0.z, bordercenter.z - borderrange.z, bordercenter.z + borderrange.z));
        rhr = texture3D(tex3, tc);
        rhg = texture3D(tex4, tc);
        rhb = mix(texture3D(tex5, tc), vec4(0.5, 0.5, 0.5, 0.0), outside);
    }
]

lazyshader 0 radiancehintscached [
    attribute vec4 vvertex;
    attribute vec3 vtexcoord0;
    varying vec3 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0;
    }
] [
    uniform sampler3D tex6, tex7, tex8;
    varying vec3 texcoord0;
    fragdata(0, rhr, vec4)
    fragdata(1, rhg, vec4)
    fragdata(2, rhb, vec4)

    void main(void)
    {
        rhr = texture3D(tex6, texcoord0);
        rhg = texture3D(tex7, texcoord0);
        rhb = texture3D(tex8, texcoord0);
    }
]

////////////////////////////////////////////////
//
// deferred shading
//
////////////////////////////////////////////////

lazyshader 0 msaaresolve [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    uniform sampler2DMS tex0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = texelFetch(tex0, ivec2(gl_FragCoord.xy), 0);
    }
]

lazyshader 0 "msaareducew" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 tap0, tap1;
    void main(void)
    {
        gl_Position = vvertex;
        tap0 = vtexcoord0; 
        tap1 = vtexcoord0 + vec2(-1.0, 0.0);
    }
] [
    uniform sampler2DMS tex0; 
    varying vec2 tap0, tap1;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = 0.5*(texelFetch(tex0, ivec2(tap0), 0) + texelFetch(tex0, ivec2(tap1), 0));
    }
]

lazyshader 0 "msaareduce" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_Position = vvertex;
        tap0 = vtexcoord0; 
        tap1 = vtexcoord0 + vec2(-1.0,  0.0);
        tap2 = vtexcoord0 + vec2( 0.0, -1.0);
        tap3 = vtexcoord0 + vec2(-1.0, -1.0);
    }
] [
    uniform sampler2DMS tex0; 
    varying vec2 tap0, tap1, tap2, tap3;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = 0.25*(texelFetch(tex0, ivec2(tap0), 0) + texelFetch(tex0, ivec2(tap1), 0) +
                             texelFetch(tex0, ivec2(tap2), 0) + texelFetch(tex0, ivec2(tap3), 0));
    }
]

lazyshader 0 msaaedgedetect [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    uniform sampler2DMS tex0, tex1, tex2, tex3;

    void main(void)
    {
        vec4 e = texelFetch(tex1, ivec2(gl_FragCoord.xy), 0);
        e.xyz -= 0.5;
        float maxdiff = 0.98*0.98*dot(e.xyz, e.xyz); 
        @(loopconcat i (- $msaasamples 1) [result [
            vec4 e@i = texelFetch(tex1, ivec2(gl_FragCoord.xy), @(+ $i 1));
            e@i.xyz -= 0.5;
            if(abs(e.w-e@i.w) <= 4.0/255.0 && pow(dot(e@i.xyz, e.xyz), 2.0) >= maxdiff*dot(e@i.xyz, e@i.xyz))
            {
        ]])
                discard;
        @(loopconcat i (- $msaasamples 1) [result [
            }
        ]])
    }
]
    
// deferredlighttype:
//    p -> point-light shadow (default cubemap)
//    c -> CSM
//    a -> AO
//    A -> AO sun
//    r -> radiance hints
//    G -> 5x5 weighted gather filter
//    g -> 3x3 weighted gather filter
//    E -> 5x5 weighted bilinear filter
//    F -> 3x3 weighted bilinear filter
//    f -> 4x rotated grid filter
//    m -> minimap
//    M -> multisampled
//    R -> manual resolve
//    S -> sample shading
//    T -> manual resolve with edge detection
dlopt = [ >= (strstr $deferredlighttype $arg1) 0 ]

deferredlightvariantshader = [
    deferredlighttype = $arg3
    numsplits = (+ $arg4 0)
    numrh = (+ $arg5 0)
    numlights = (+ $arg6 0)
    baselight = (< (mod $arg2 4) 2)
    spotlight = (>= $arg2 4) 
    variantshader 0 $arg1 $arg2 (? (< $arg2 0) [
        attribute vec4 vvertex;
        uniform mat4 lightmatrix;
        void main(void)
        {
            gl_Position = lightmatrix * vvertex;
        }
    ]) [
        @(if (dlopt "S") [result [
            #extension GL_ARB_sample_shading : enable
        ]])
        @(if (|| (dlopt "g") (dlopt "G")) [result [
            @(if (> $usetexgather 1) [result [
                #ifdef GL_ARB_gpu_shader5
                #  extension GL_ARB_gpu_shader5 : enable
                #endif
            ]])
            #ifdef GL_ARB_texture_gather
            #  extension GL_ARB_texture_gather : enable
            #else
            #  ifdef GL_AMD_texture_texture4
            #    extension GL_AMD_texture_texture4 : enable
            #  endif
            #endif
        ]])
        @(if (dlopt "M") [result [
            uniform sampler2DMS tex0, tex1, tex2, tex3;
        ]] [result [
            uniform sampler2DRect tex0, tex1, tex2, tex3;
        ]])
        @(if (|| (dlopt "p") (dlopt "c")) [
            if (|| (dlopt "g") (dlopt "G")) [if (> $usetexgather 1) [result [
                #if defined(GL_ARB_texture_gather) && defined(GL_ARB_gpu_shader5)
                    uniform sampler2DShadow tex4;
                #else
                    uniform sampler2D tex4;
                #endif
            ]] [result [
                uniform sampler2D tex4;
            ]]] [result [
                uniform sampler2DRectShadow tex4;
            ]]
        ])
        @(if $numlights [result [
            uniform vec4 lightpos[@@numlights];
            uniform vec3 lightcolor[@@numlights];
            @(if $spotlight [result [
                uniform vec4 spotparams[@@numlights];
            ]])
            @(if (dlopt "p") [result [
                @(if $spotlight [result [
                    uniform vec3 spotx[@@numlights];
                    uniform vec3 spoty[@@numlights];
                ]])
                uniform vec4 shadowparams[@@numlights];
                uniform vec2 shadowoffset[@@numlights];
            ]])
        ]])
        @(if $numsplits [result [
            uniform vec3 splitcenter[@@numsplits];
            uniform vec3 splitbounds[@@numsplits];
            uniform vec3 splitscale[@@numsplits];
            uniform vec3 splitoffset[@@numsplits];
        ]])
        @(if (dlopt "c") [result [
            uniform mat3 csmmatrix;
            uniform vec3 sunlightdir;
            uniform vec3 sunlightcolor;
            @(if (dlopt "r") [result [
                uniform float giscale, rhnudge;
                uniform vec4 rhbb[@@numrh];
                uniform vec3 rhscale[@@numrh];
                uniform vec3 rhoffset[@@numrh];
                uniform sampler3D tex6, tex7, tex8;
            ]])  
        ]])
        uniform vec3 camera;
        uniform mat4 worldmatrix;
        uniform vec4 fogdir;
        uniform vec3 fogcolor, fogparams;
        uniform vec2 shadowatlasscale;
        uniform vec4 lightscale;
        @(? (dlopt "a") [uniform sampler2DRect tex5; uniform vec2 aoscale; uniform vec4 aoparams;])
        @(gdepthunpackparams)
        fragdata(0, fragcolor, vec4)

        @(if (dlopt "p") [
            if $spotlight [result [
                vec3 getspottc(vec3 dir, float spotdist, vec3 spotx, vec3 spoty, vec4 shadowparams, vec2 shadowoffset)
                {
                    vec2 mparams = shadowparams.xy / spotdist;
                    return vec3(vec2(dot(dir, spotx), dot(dir, spoty))*mparams.x + shadowoffset, mparams.y + shadowparams.w);
                }
            ]] [result [
                vec3 getshadowtc(vec3 dir, vec4 shadowparams, vec2 shadowoffset)
                {
                    vec3 adir = abs(dir);
                    float m = max(adir.x, adir.y);
                    vec2 mparams = shadowparams.xy / max(adir.z, m);
                    vec4 proj;
                    if(adir.x > adir.y) proj = vec4(dir.zyx, 0.0); else proj = vec4(dir.xzy, 1.0);
                    if(adir.z > m) proj = vec4(dir, 2.0);
                    return vec3(proj.xy * mparams.x + vec2(proj.w, step(proj.z, 0.0)) * shadowparams.z + shadowoffset, mparams.y + shadowparams.w);
                }
            ]]
        ])

        @(if (|| (dlopt "p") (dlopt "c")) [
            cond [dlopt "G"] [result [
                #ifdef GL_ARB_texture_gather
                @(if (> $usetexgather 1) [result [
                #  ifdef GL_ARB_gpu_shader5
                #      define shadowgather(center, xoff, yoff) textureGatherOffset(tex4, center, shadowtc.z, ivec2(xoff, yoff))
                #    else
                #      define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                #  endif
                ]] [result [
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                ]])
                #else
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, texture4(tex4, center + vec2(xoff, yoff)*shadowatlasscale))
                #endif
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5), center = (shadowtc.xy - offset)*shadowatlasscale;
                    vec4 group1 = shadowgather(center, -2.0, -2.0);
                    vec4 group2 = shadowgather(center,  0.0, -2.0);
                    vec4 group3 = shadowgather(center,  2.0, -2.0);
                    vec4 group4 = shadowgather(center, -2.0,  0.0);
                    vec4 group5 = shadowgather(center,  0.0,  0.0);
                    vec4 group6 = shadowgather(center,  2.0,  0.0);
                    vec4 group7 = shadowgather(center, -2.0,  2.0);
                    vec4 group8 = shadowgather(center,  0.0,  2.0);
                    vec4 group9 = shadowgather(center,  2.0,  2.0);
                    vec4 locols = vec4(group1.ab, group3.ab);
                    vec4 hicols = vec4(group7.rg, group9.rg);
                    locols.yz += group2.ab;
                    hicols.yz += group8.rg;
                    vec4 midcols = vec4(group1.rg, group3.rg) + vec4(group7.ab, group9.ab) +
                                   vec4(group4.rg, group6.rg) + vec4(group4.ab, group6.ab) +
                                   mix(locols, hicols, offset.y);
                    vec4 cols = group5 + vec4(group2.rg, group8.ab);
                    cols.xyz += mix(midcols.xyz, midcols.yzw, offset.x);
                    return dot(cols, vec4(1.0/25.0));
                }
            ]] [dlopt "g"] [result [
                #ifdef GL_ARB_texture_gather
                @(if (> $usetexgather 1) [result [
                #  ifdef GL_ARB_gpu_shader5
                #      define shadowgather(center, xoff, yoff) textureGatherOffset(tex4, center, shadowtc.z, ivec2(xoff, yoff))
                #    else
                #      define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                #  endif
                ]] [result [
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
                ]])
                #else
                #  define shadowgather(center, xoff, yoff) step(shadowtc.z, texture4(tex4, center + vec2(xoff, yoff)*shadowatlasscale))
                #endif
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5), center = (shadowtc.xy - offset)*shadowatlasscale;
                    vec4 group1 = shadowgather(center, -1.0, -1.0);
                    vec4 group2 = shadowgather(center,  1.0, -1.0);
                    vec4 group3 = shadowgather(center, -1.0,  1.0);
                    vec4 group4 = shadowgather(center,  1.0,  1.0);
                    vec4 cols = vec4(group1.rg, group2.rg) + vec4(group3.ab, group4.ab) + mix(vec4(group1.ab, group2.ab), vec4(group3.rg, group4.rg), offset.y);
                    return dot(mix(cols.xyz, cols.yzw, offset.x), vec3(1.0/9.0));
                }
            ]] [dlopt "E"] [result [
                #define shadowval(xy) float(shadow2DRect(tex4, vec3(xy, shadowtc.z)))
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5);
                    vec4 center = vec4(shadowtc.xy - offset + 0.5, shadowtc.xy - offset*0.5);
                    vec4 size = vec4(offset + 1.0, 2.0 - offset);
                    return (1.0/25.0)*dot(size.zxzx*size.wwyy, 
                            vec4(shadowval(center.zw - 1.5), 
                                 shadowval(center.zw + vec2(2.0, -1.5)), 
                                 shadowval(center.zw + vec2(-1.5, 2.0)), 
                                 shadowval(center.zw + 2.0))) + 
                           (2.0/25.0)*dot(size, 
                            vec4(shadowval(center.zy + vec2(2.0, 0.0)), 
                                 shadowval(center.xw + vec2(0.0, 2.0)),
                                 shadowval(center.zy + vec2(-1.5, 0.0)),
                                 shadowval(center.xw + vec2(0.0, -1.5)))) +
                           (4.0/25.0)*shadowval(center.xy);
                }   
            ]] [dlopt "F"] [result [
                #define shadowval(center, xyoff) float(shadow2DRect(tex4, vec3(center.xy + xyoff, center.z)))
                float filtershadow(vec3 shadowtc)
                {
                    vec2 offset = fract(shadowtc.xy - 0.5);
                    vec3 center = shadowtc;
                    //center.xy -= offset;
                    //vec4 size = vec4(offset + 1.0, 2.0 - offset), weight = vec4(2.0 - 1.0 / size.xy, 1.0 / size.zw - 1.0);
                    //return (1.0/9.0)*dot(size.zxzx*size.wwyy,
                    //    vec4(shadowval(center, weight.zw),
                    //         shadowval(center, weight.xw),
                    //         shadowval(center, weight.zy),
                    //         shadowval(center, weight.xy)));
                    center.xy -= offset*0.5;
                    vec4 size = vec4(offset + 1.0, 2.0 - offset);
                    return (1.0/9.0)*dot(size.zxzx*size.wwyy,
                        vec4(shadowval(center, -0.5),
                             shadowval(center, vec2(1.0, -0.5)),
                             shadowval(center, vec2(-0.5, 1.0)),
                             shadowval(center, 1.0)));
                }
            ]] [dlopt "f"] [result [
                #define shadowval(center, xoff, yoff) float(shadow2DRect(tex4, center + vec3(xoff, yoff, 0.0)))
                float filtershadow(vec3 shadowtc)
                {
                    return dot(vec4(0.25),
                                vec4(shadowval(shadowtc, -0.4, 1.0),
                                    shadowval(shadowtc, -1.0, -0.4),
                                    shadowval(shadowtc, 0.4, -1.0),
                                    shadowval(shadowtc, 1.0, 0.4))); 
                }
            ]] [result [
                #define filtershadow(shadowtc) float(shadow2DRect(tex4, shadowtc))
            ]]
        ])

        @(if (dlopt "c") [result [
            vec3 getcsmtc(vec3 pos)
            {
                pos = csmmatrix * pos;
                @(loopconcat j (- $numsplits 1) [result [
                    if(all(lessThan(abs(pos - splitcenter[@@j]), splitbounds[@@j])))
                        pos = pos*splitscale[@@j] + splitoffset[@@j];
                    else
                ]])
                if(all(lessThan(abs(pos.xy - splitcenter[@@(- $numsplits 1)].xy), splitbounds[@@(- $numsplits 1)].xy)))
                    pos = pos*splitscale[@@(- $numsplits 1)] + splitoffset[@@(- $numsplits 1)];
                else pos = vec3(-1.0);
                return pos;
            }
            
            @(if (dlopt "r") [result [
                vec3 getrhlight(vec3 pos, vec3 norm)
                {
                    vec3 tc;
                    pos += norm*rhnudge;
                    @(loopconcat j (- $numrh 1) [result [
                        if(all(lessThan(abs(pos - rhbb[@@j].xyz), vec3(rhbb[@@j].w))))
                            tc = pos*rhscale[@@j] + rhoffset[@@j];
                        else
                    ]])
                    if(all(lessThan(abs(pos - rhbb[@@(- $numrh 1)].xyz), vec3(rhbb[@@(- $numrh 1)].w))))
                        tc = pos*rhscale[@@(- $numrh 1)] + rhoffset[@@(- $numrh 1)];
                    else tc = vec3(-1.0);
                    vec4 shr = texture3D(tex6, tc), shg = texture3D(tex7, tc), shb = texture3D(tex8, tc);
                    shr.rgb -= 0.5;
                    shg.rgb -= 0.5;
                    shb.rgb -= 0.5;
                    vec4 basis = vec4(norm*-(1.023326*0.488603/3.14159*2.0), (0.886226*0.282095/3.14159));
                    return clamp(vec3(dot(basis, shr), dot(basis, shg), dot(basis, shb)), 0.0, 1.0);
                }
            ]])
        ]])
            
        void main(void)
        {
            @(if (dlopt "M") [
                if (dlopt "R") [result [
                    @(if (dlopt "T") [result [
                        bool shouldresolve = true;
                        {
                            vec4 e = texelFetch(tex1, ivec2(gl_FragCoord.xy), 0);
                            e.xyz -= 0.5;
                            float maxdiff = 0.98*0.98*dot(e.xyz, e.xyz); 
                            @(loopconcat i (- $msaasamples 1) [result [
                                vec4 e@i = texelFetch(tex1, ivec2(gl_FragCoord.xy), @(+ $i 1));
                                e@i.xyz -= 0.5;
                                if(abs(e.w-e@i.w) <= 4.0/255.0 && pow(dot(e@i.xyz, e.xyz), 2.0) >= maxdiff*dot(e@i.xyz, e@i.xyz))
                                {
                            ]])
                                    shouldresolve = false;
                            @(loopconcat i (- $msaasamples 1) [result [
                                }
                            ]])
                        }
                    ]])

                    #define gfetch(sampler, coords) texelFetch(sampler, ivec2(coords), sample)

                    vec4 resolved = vec4(0.0);
                    #define accumlight(light) resolved.rgb += light
                    #define accumalpha(alpha) resolved.a += alpha

                    @(if (&& $baselight [dlopt "a"]) [result [
                        float ao = texture2DRect(tex5, gl_FragCoord.xy*aoscale).r;
                    ]])

                    for(int sample = 0; sample < @msaasamples; sample++) 
                    {
                ]] [result [
                    #define gfetch(sampler, coords) texelFetch(sampler, ivec2(coords), @(? (dlopt "S") [gl_SampleID] [0]))

                    #define accumlight(light) fragcolor.rgb = light
                    #define accumalpha(alpha) fragcolor.a = alpha
                ]]
            ] [result [
                #define gfetch(sampler, coords) texture2DRect(sampler, coords)

                #define accumlight(light) fragcolor.rgb = light
                #define accumalpha(alpha) fragcolor.a = alpha
            ]])

            @(if (|| $baselight [> $numlights 1]) [result [
                vec4 diffuse = gfetch(tex0, gl_FragCoord.xy);
            ]])
            @(if $baselight [result [
                vec3 light = diffuse.rgb * lightscale.rgb;
                @(if (dlopt "a") [
                    if (&& (dlopt "M") [dlopt "R"]) [result [
                        light *= aoparams.x + ao*aoparams.y;
                    ]] [result [
                        float ao = texture2DRect(tex5, gl_FragCoord.xy*aoscale).r;
                        light *= aoparams.x + ao*aoparams.y;
                    ]]
                ]) 
                vec4 glow = gfetch(tex2, gl_FragCoord.xy);
                light += glow.rgb * lightscale.a;
            ]] [result [
                vec3 light = vec3(0.0);
            ]])

            @(if (|| (> $numlights 0) (dlopt "c")) [result [
                @(gdepthunpack depth tex3 gl_FragCoord.xy [
                    @(if (dlopt "m") [result [
                        vec3 pos = (worldmatrix * vec4(gl_FragCoord.xy, depth, 1.0)).xyz;
                    ]] [result [
                        vec3 pos = (worldmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).xyz;
                    ]])
                    #define fogcoord depth
                ] [
                    vec4 pos = worldmatrix * vec4(gl_FragCoord.xy, depth, 1.0);
                    pos.xyz /= pos.w;
                    #define fogcoord dot(fogdir, vec4(pos.xyz, 1.0))
                ])
                @(if (|| (dlopt "c") [> $numlights 1]) [result [
                    vec4 normal = gfetch(tex1, gl_FragCoord.xy);
                    normal.xyz = normal.xyz*2.0 - 1.0;
                ]])
                @(if (&& (> (+ $numlights (dlopt "c")) 1) [! (dlopt "m")]) [result [
                    vec3 camdir = normalize(camera - pos.xyz);
                    float facing = 2.0*dot(normal.xyz, camdir);
                ]])
            ]] [if (! (dlopt "m")) [result [
                @(gdepthunpack depth tex3 gl_FragCoord.xy)
                #define fogcoord depth
            ]]])

            @(if (dlopt "c") [result [
                @(if (dlopt "r") [result [
                    vec3 rhlight = diffuse.rgb * getrhlight(pos.xyz, normal.xyz) * giscale;
                ]])
                float sunfacing = dot(sunlightdir, normal.xyz);
                if(sunfacing > 0.0)
                {
                    vec3 csmtc = getcsmtc(pos.xyz);
                    float sunoccluded = sunfacing * filtershadow(csmtc);
                    @(if (dlopt "m") [result [
                        light += diffuse.rgb * sunlightcolor * sunoccluded;
                    ]] [result [
                        @(if (= (+ $numlights (dlopt "c")) 1) [result [
                            vec3 camdir = normalize(camera - pos.xyz);
                            float facing = 2.0*dot(normal.xyz, camdir);
                        ]])
                        float sunspec = pow(clamp(sunfacing*facing - dot(camdir, sunlightdir), 0.0, 1.0), 16.0) * diffuse.a;
                        @(if (dlopt "r") [result [
                            rhlight += (diffuse.rgb + sunspec) * sunoccluded;
                        ]] [result [
                            @(if (dlopt "A") [result [
                                sunoccluded *= aoparams.z + ao*aoparams.w;
                            ]])
                            light += (diffuse.rgb + sunspec) * sunoccluded * sunlightcolor;
                        ]])
                    ]])
                }
                @(if (dlopt "r") [result [
                    light += rhlight @(? (dlopt "A") [* (aoparams.z + ao*aoparams.w)]) * sunlightcolor;
                ]])
            ]])
            @(loopconcat j $numlights [result [
                vec3 light@[j]dir = (pos.xyz - lightpos[@@j].xyz) * lightpos[@@j].w;
                float light@[j]dist2 = dot(light@[j]dir, light@[j]dir);
                if(light@[j]dist2 < 1.0)
                {
                    @(if (&& (= $numlights 1) [! (dlopt "c")]) [result [
                        vec4 normal = gfetch(tex1, gl_FragCoord.xy);
                        normal.xyz = normal.xyz*2.0 - 1.0;
                    ]])
                    float light@[j]facing = dot(light@[j]dir, normal.xyz);
                    if(light@[j]facing < 0.0) 
                    {
                        float light@[j]invdist = inversesqrt(light@[j]dist2); 
                        @(if $spotlight [result [
                            float spot@[j]dist = dot(light@[j]dir, spotparams[@@j].xyz);
                            float spot@[j]atten = light@[j]invdist * spot@[j]dist - spotparams[@@j].w;
                            if(spot@[j]atten > 0.0)
                            {
                        ]])
                        float light@[j]atten = light@[j]facing * (1.0 - light@[j]invdist);
                        @(if $spotlight [
                            if (dlopt "p") [result [
                                vec3 spot@[j]tc = getspottc(light@[j]dir, spot@[j]dist, spotx[@@j], spoty[@@j], shadowparams[@@j], shadowoffset[@@j]);
                                light@[j]atten *= spot@[j]atten * filtershadow(spot@[j]tc);
                            ]] [result [
                                light@[j]atten *= spot@[j]atten;
                            ]]
                        ] [
                            if (dlopt "p") [result [
                                vec3 shadow@[j]tc = getshadowtc(light@[j]dir, shadowparams[@@j], shadowoffset[@@j]);
                                light@[j]atten *= filtershadow(shadow@[j]tc);
                            ]]
                        ])
                        @(if (&& (= $numlights 1) [! $baselight]) [result [
                            vec4 diffuse = gfetch(tex0, gl_FragCoord.xy);
                        ]])
                        @(if (dlopt "m") [result [
                            light += diffuse.rgb * lightcolor[@@j] * light@[j]atten;
                        ]] [result [
                            @(if (= (+ $numlights (dlopt "c")) 1) [result [
                                vec3 camdir = normalize(camera - pos.xyz);
                                float facing = 2.0*dot(normal.xyz, camdir);
                            ]])
                            float light@[j]spec = pow(clamp(light@[j]invdist*(dot(camdir, light@[j]dir) - light@[j]facing*facing), 0.0, 1.0), 16.0) * diffuse.a;
                            light += (diffuse.rgb + light@[j]spec) * lightcolor[@@j] * light@[j]atten;
                            @(if (= (+ $numlights $baselight) 1) [result [
                                float foglerp = clamp((fogparams.y + fogcoord)*fogparams.z, 0.0, 1.0);
                                light *= foglerp;
                            ]])
                        ]])
                        @(? $spotlight [}]) 
                    }
                }
            ]])
            @(if (dlopt "m") [if $baselight [result [
                accumlight(light);
                accumalpha(glow.a);
            ]] [result [
                accumlight(light);
                accumalpha(0.0);
            ]]] [if (|| $baselight [> $numlights 1]) [result [
                float foglerp = clamp((fogparams.y + fogcoord)*fogparams.z, 0.0, 1.0);
                @(? $baselight [
                    accumlight(mix(fogcolor*glow.a, light, foglerp));
                    accumalpha(glow.a);
                ] [
                    accumlight(light*foglerp);
                    accumalpha(0.0);
                ])
            ]] [result [
                accumlight(light);
                accumalpha(0.0);
            ]]])

            @(if (dlopt "R") [result [
                    @(? (dlopt "T") [if(!shouldresolve) break;])
                }

                @(? (dlopt "T") [if(shouldresolve)]) resolved *= @(divf 1 $msaasamples);
                fragcolor = resolved;
            ]])
        }
    ] 64
]

deferredlightshader = [
    shadername = (concatword "deferredlight" $arg1 $arg2 $arg3)
    deferredlightvariantshader $shadername -1 (concatword $arg1 $arg3) $arg4 $arg5 0 // base shader, no points lights, sunlight
    loop i 8 [
        deferredlightvariantshader $shadername 0 (concatword $arg1 $arg3) $arg4 $arg5 (+ $i 1) // row 0, point lights, sunlight
        deferredlightvariantshader $shadername 1 (concatword $arg1 $arg2 $arg3) $arg4 $arg5 (+ $i 1) // row 1, shadowed point lights, sunlight
        deferredlightvariantshader $shadername 2 $arg1 $arg4 $arg5 (+ $i 1) // row 2, point lights 
        deferredlightvariantshader $shadername 3 (concatword $arg1 $arg2) $arg4 $arg5 (+ $i 1) // row 3, shadowed point lights
        deferredlightvariantshader $shadername 4 (concatword $arg1 $arg3) $arg4 $arg5 (+ $i 1) // row 4, spot lights, sunlight
        deferredlightvariantshader $shadername 5 (concatword $arg1 $arg2 $arg3) $arg4 $arg5 (+ $i 1) // row 5, shadowed spot lights, sunlight
        deferredlightvariantshader $shadername 6 $arg1 $arg4 $arg5 (+ $i 1) // row 6, spot lights 
        deferredlightvariantshader $shadername 7 (concatword $arg1 $arg2) $arg4 $arg5 (+ $i 1) // row 7, shadowed spot lights
    ]
]

lazyshader 0 "modelpreview" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;

    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    @(gfetchdefs [tex0 tex1 tex2 tex3])
    uniform vec3 camera;
    uniform mat4 worldmatrix;
    uniform vec4 lightscale;
    uniform vec3 sunlightdir;
    uniform vec3 sunlightcolor;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)

    void main(void)
    {
        vec4 diffuse = gfetch(tex0, texcoord0);    
        vec3 light = diffuse.rgb * lightscale.rgb;
        vec4 glow = gfetch(tex2, texcoord0);
        light += glow.rgb * lightscale.a;

        vec4 normal = gfetch(tex1, texcoord0);
        normal.xyz = normal.xyz*2.0 - 1.0;

        float sunfacing = dot(sunlightdir, normal.xyz);
        if(sunfacing > 0.0)
        {
            @(gdepthunpack depth tex3 texcoord0 [
                vec3 pos = (worldmatrix * vec4(depth*texcoord0, depth, 1.0)).xyz;
            ] [
                vec4 pos = worldmatrix * vec4(texcoord0, depth, 1.0);
                pos.xyz /= pos.w;
            ])
            vec3 camdir = normalize(camera - pos.xyz);
            float facing = 2.0*dot(normal.xyz, camdir);
            float sunspec = pow(clamp(sunfacing*facing - dot(camdir, sunlightdir), 0.0, 1.0), 8.0) * diffuse.a;
            light += (diffuse.rgb + sunspec) * sunfacing * sunlightcolor;
        }

        fragcolor.rgb = light;
        fragcolor.a = glow.a;
    }
]

shader 0 "hdrreduce" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor.rgb = texture2DRect(tex0, texcoord0).rgb;
    }
]

shader 0 "hdrreduce2w" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 tap0, tap1;
    void main(void)
    {
        gl_Position = vvertex;
        tap0 = vtexcoord0 + vec2(-1.0, 0.0);
        tap1 = vtexcoord0 + vec2( 1.0, 0.0);
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 tap0, tap1;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor.rgb = 0.5*(texture2DRect(tex0, tap0).rgb + texture2DRect(tex0, tap1).rgb);
    }
]

shader 0 "hdrreduce2" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_Position = vvertex;
        tap0 = vtexcoord0 + vec2(-1.0, -1.0);
        tap1 = vtexcoord0 + vec2( 1.0, -1.0);
        tap2 = vtexcoord0 + vec2( 1.0,  1.0);
        tap3 = vtexcoord0 + vec2(-1.0,  1.0);
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 tap0, tap1, tap2, tap3;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor.rgb = 0.25*(texture2DRect(tex0, tap0).rgb + texture2DRect(tex0, tap1).rgb +
                                 texture2DRect(tex0, tap2).rgb + texture2DRect(tex0, tap3).rgb);
    }
]

lumweights = "0.2126, 0.7152, 0.0722"
//lumweights = "0.299, 0.587, 0.114"

hdrgammadecode = [
    if (=f $hdrgamma 2) [result [
        @arg1 *= @arg1;
    ]] [result [
        @arg1 = pow(@arg1, vec3(hdrgamma.x));
    ]]
]

hdrgammaencode = [
    if (=f $hdrgamma 2) [result [
        @arg1 = sqrt(@arg1);
    ]] [result [
        @arg1 = pow(@arg1, vec3(hdrgamma.y));
    ]]
]

shader 0 "hdrluminance" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color = texture2DRect(tex0, texcoord0).rgb*2.0;
        @(hdrgammadecode color)
        float lum = dot(color, vec3(@lumweights));
        float loglum = sqrt(clamp(lum, 0.015625, 4.0)) * (1.0/2.0); // allow values as low as 2^-6, and as high 2^2
        fragcolor.rgb = vec3(loglum);
    }
]

shader 0 "hdrluminance2w" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 tap0, tap1;
    void main(void)
    {
        gl_Position = vvertex;
        tap0 = vtexcoord0 + vec2(-1.0, 0.0);
        tap1 = vtexcoord0 + vec2( 1.0, 0.0);
    }
] [
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 tap0, tap1;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(loopconcat i 2 [result [
            vec3 color@[i] = texture2DRect(tex0, tap@[i]).rgb*2.0;
            @(hdrgammadecode [color@[i]])
            float lum@[i] = dot(color@[i], vec3(@lumweights));
            float loglum@[i] = sqrt(clamp(lum@[i], 0.015625, 4.0)) * (1.0/2.0);
        ]])
        fragcolor.rgb = vec3(0.5*(loglum0 + loglum1));
    }
]

shader 0 "hdrluminance2" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_Position = vvertex;
        tap0 = vtexcoord0 + vec2(-1.0, -1.0);
        tap1 = vtexcoord0 + vec2( 1.0, -1.0);
        tap2 = vtexcoord0 + vec2( 1.0,  1.0);
        tap3 = vtexcoord0 + vec2(-1.0,  1.0);
    }
] [
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 tap0, tap1, tap2, tap3;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(loopconcat i 4 [result [
            vec3 color@[i] = texture2DRect(tex0, tap@[i]).rgb*2.0;
            @(hdrgammadecode [color@[i]])
            float lum@[i] = dot(color@[i], vec3(@lumweights));
            float loglum@[i] = sqrt(clamp(lum@[i], 0.015625, 4.0)) * (1.0/2.0);
        ]])
        fragcolor.rgb = vec3(0.25*(loglum0 + loglum1 + loglum2 + loglum3));
    }
]

shader 0 "hdraccum" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0;
    uniform float accumscale;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        float lum = texture2DRect(tex0, texcoord0).r * 2.0;
        lum *= lum;
        fragcolor = vec4(vec3(lum*0.25), accumscale);
    }
]

shader 0 "hdrbloom" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    uniform sampler2D tex2; 
    uniform vec4 hdrparams;
    varying vec2 texcoord0;
    varying float lumscale, lumthreshold;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
        float avglum = 4.0*texture2D(tex2, vec2(0.5, 0.5)).r;
        lumscale = hdrparams.x * -log2(1.0 - clamp(avglum, 0.03, 0.3))/(avglum + 1e-4);
        lumthreshold = -log2(1.0 - hdrparams.z);
    }
] [
    uniform sampler2DRect tex0; 
    uniform vec2 hdrgamma;
    varying vec2 texcoord0;
    varying float lumscale, lumthreshold;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color = texture2DRect(tex0, texcoord0).rgb*2.0;
        @(hdrgammadecode color)
        float lum = dot(color, vec3(@lumweights));
        color *= max(lum*lumscale - lumthreshold, 0.0) / (lum + 1e-4);
        @(hdrgammaencode color)
        fragcolor.rgb = color;
    }
]

hdrtonemapvertexshader = [
  result [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0, vtexcoord1;
    uniform sampler2D tex2; 
    uniform vec4 hdrparams;
    varying vec2 texcoord0, texcoord1;
    varying float lumscale, lumsaturate;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
        texcoord1 = vtexcoord1;
        float avglum = 4.0*texture2D(tex2, vec2(0.5, 0.5)).r;
        lumscale = hdrparams.x * -log2(1.0 - clamp(avglum, 0.03, 0.3))/(avglum + 1e-4);
        lumsaturate = -log2(1.0 - hdrparams.y) / lumscale;
    }
  ]
]

hdrtonemapfrag = [
    result [{
        // color = 1.0 - exp2(-color*lumscale);
        float lum = dot(@arg1, vec3(@lumweights));
        @arg1 = min(@arg1, lumsaturate);
        @arg1 *= (1.0 - exp2(-lum*lumscale)) / (dot(@arg1, vec3(@lumweights)) + 1e-4);
    }]
]

hdrtonemapdefs = [
    result [
        uniform vec4 hdrparams;
        uniform vec2 hdrgamma;
        varying vec2 texcoord0, texcoord1;
        varying float lumscale, lumsaturate;
    ]
]

hdrtonemapshaders = [
  (? $arg1 lazyshader shader) 0 [hdrnop@arg1] [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
  ] [
    @arg2
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color = texture2DRect(tex0, texcoord0).rgb;
        fragcolor.rgb = color;
        @(? $arg3 $arg3 [fragcolor.a = 0.0;])
    }
  ]

  
  (? $arg1 lazyshader shader) 0 [hdrtonemap@arg1] (hdrtonemapvertexshader) [
    @arg2
    uniform sampler2DRect tex0, tex1;
    @(hdrtonemapdefs)
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 color = texture2DRect(tex0, texcoord0).rgb*2.0;
        vec3 bloom = texture2DRect(tex1, texcoord1).rgb*hdrparams.w;
        color += bloom;
        @(hdrgammadecode color)
        @(hdrtonemapfrag color)
        @(hdrgammaencode color)
        fragcolor.rgb = color;
        @(? $arg3 $arg3 [fragcolor.a = 0.0;])
    }
  ]
  
  if $msaasamples [msaatonemapshaders $arg1 $arg2 $arg3]
  if (= $msaasamples 2) [msaasplitshaders $arg1 $arg2 $arg3]
]

msaatonemapshaders = [
  if (=s $arg1 "") [lazyshader 0 [msaatonemapsample] (hdrtonemapvertexshader) [
    #extension GL_ARB_sample_shading : enable
    uniform sampler2DRect tex1;
    uniform sampler2DMS tex0;
    @(hdrtonemapdefs)
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 bloom = texture2DRect(tex1, texcoord1).rgb*hdrparams.w;
        vec3 color = texelFetch(tex0, ivec2(texcoord0), gl_SampleID).rgb*2.0;
        color += bloom;
        @(hdrgammadecode color)
        @(hdrtonemapfrag color)
        @(hdrgammaencode color)
        fragcolor = vec4(color, 0.0);
    }
  ]]

  defershader 0 [msaatonemap@arg1] [
    loop i 2 [
      variantshader 0 [msaatonemap@@@arg1] (- $i 1) (hdrtonemapvertexshader) [
        @@@arg2
        uniform sampler2DRect tex1;
        uniform sampler2DMS tex0;
        @(hdrtonemapdefs)
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            vec3 bloom = texture2DRect(tex1, texcoord1).rgb*hdrparams.w;
            @(if $i [result [
                vec3 resolved = vec3(0.0);
                for(int sample = 0; sample < @msaasamples; sample++)
                {
            ]] [result [
                #define sample 0
            ]])
                    vec3 color = texelFetch(tex0, ivec2(texcoord0), sample).rgb*2.0;
                    color += bloom;
                    @(hdrgammadecode color)
                    @(hdrtonemapfrag color)
                    @(hdrgammaencode color)
            @(if $i [result [
                    resolved += color;
                }
                fragcolor.rgb = resolved * @(divf 1 $msaasamples);
            ]] [result [
                fragcolor.rgb = color;
            ]])
            @@@(? $arg3 $arg3 [fragcolor.a = 0.0;])
        }
      ]
    ]
  ]
]

msaasplitshaders = [
  lazyshader 0 [msaasplit@arg1] [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
  ] [
    @arg2
    uniform sampler2DMS tex0;
    varying vec2 texcoord0;
    @(loopconcat i $msaasamples [result [
        fragdata(@i, fragdata@i, vec4)
    ]])
    void main(void)
    {
        @(loopconcat i $msaasamples [result [
            fragdata@i.rgb = texelFetch(tex0, ivec2(texcoord0), @i).rgb;
            @(if $arg3 [result [
                { @(strreplace $arg3 [fragcolor] [fragdata@i]) }
            ]] [result [
                fragdata@i.a = 0.0;
            ]])
        ]])
    }
  ]

  lazyshader 0 [msaatonemapsplit@arg1] (hdrtonemapvertexshader) [
    @arg2
    uniform sampler2DRect tex1;
    uniform sampler2DMS tex0;
    @(hdrtonemapdefs)
    @(loopconcat i $msaasamples [result [
        fragdata(@i, fragdata@i, vec4)
    ]])
    void main(void)
    {
        vec3 bloom = texture2DRect(tex1, texcoord1).rgb*hdrparams.w;
        @(loopconcat i $msaasamples [result [
            vec3 color@i = texelFetch(tex0, ivec2(texcoord0), @i).rgb*2.0 + bloom;
            @(hdrgammadecode [color@i])
            @(hdrtonemapfrag [color@i])
            @(hdrgammaencode [color@i])
            fragdata@i.rgb = color@i;
            @(if $arg3 [result [
                { @(strreplace $arg3 [fragcolor] [fragdata@i]) }
            ]] [result [
                fragdata@i.a = 0.0;
            ]])
        ]])
    }
  ]
]

hdrtonemapshaders ""
hdrtonemapshaders "luma" [] [fragcolor.a = dot(fragcolor.rgb, vec3(@lumweights));]
hdrtonemapshaders "velocity" [
    @(gfetchdefs tex3)
    uniform mat4 reprojectmatrix;
    uniform vec2 maxvelocity;
] [
    @(gdepthunpack depth tex3 texcoord0 [
        vec4 prevtc = reprojectmatrix * vec4(depth*texcoord0, depth, 1.0);
    ] [
        vec4 prevtc = reprojectmatrix * vec4(texcoord0, depth, 1.0);
    ])
    fragcolor.a = distance(prevtc.xy/prevtc.w, texcoord0)*maxvelocity.y;
]

lazyshader 0 "scalelinear" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;

    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)

    void main(void)
    {
        fragcolor = texture2DRect(tex0, texcoord0);
    }
]

loop i 2 [
  lazyshader 0 (? $i "scalecubicy" "scalecubicx") [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;

    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
  ] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)

    vec4 cubic(float s)
    {
        const float B = @gscalecubicsoft, C = @(divf (-f 1 $gscalecubicsoft) 2);
        float s2 = s*s, s3 = s2*s;
        return vec4((-1.0/6.0*B - C) * s3 + (0.5*B + 2.0*C) * s2 + (-0.5*B - C) * s + 1.0/6.0*B,
                    (2.0 - 1.5*B - C) * s3 + (-3.0 + 2.0*B + C) * s2 + (1.0 - 1.0/3.0*B),
                    (-2.0 + 1.5*B + C) * s3 + (3.0 - 2.5*B - 2.0*C) * s2 + (0.5*B + C)*s + 1.0/6.0*B,
                    (1.0/6.0*B + C) * s3 - C * s2);
    }

    void main(void)
    {
        vec2 center = texcoord0;
        @(if $i [result [
            float offset = fract(texcoord0.y-0.5);
            center.y -= offset;
            #define texval(tap) texture2DRect(tex0, center + vec2(0.0, tap))
        ]] [result [
            float offset = fract(texcoord0.x-0.5);
            center.x -= offset;
            #define texval(tap) texture2DRect(tex0, center + vec2(tap, 0.0))
        ]])
        vec4 weight = cubic(offset);
        weight.y += weight.z;
        weight.z /= weight.y;
        fragcolor = weight.x*texval(-1.0) + weight.y*texval(weight.z) + weight.w*texval(2.0);
    }
  ]
]

aotapoffsets = [
"-0.933103, 0.025116"
"-0.432784, -0.989868"
"0.432416, -0.413800"
"-0.117770, 0.970336"
"0.837276, 0.531114"
"-0.184912, 0.200232"
"-0.955748, 0.815118"
"0.946166, -0.998596"
"-0.897519, -0.581102"
"0.979248, -0.046602"
"-0.155736, -0.488204"
"0.460310, 0.982178"
]

ambientobscurancevariantshader = [
    lineardepth = (>= (strstr $arg2 "l") 0)
    packeddepth = (>= (strstr $arg2 "p") 0)
    derivnormal = (>= (strstr $arg2 "d") 0)
    maxaotaps = $arg3 
    shader 0 $arg1 [
        attribute vec4 vvertex;
        attribute vec2 vtexcoord0, vtexcoord1;
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0; 
            texcoord1 = vtexcoord1.xy;
        }
    ] [
        @(gfetchdefs tex0 (&& $msaasamples [! $lineardepth]) gdepthfetch)
        @(gfetchdefs tex1 $msaasamples gnormfetch)
        @(gdepthunpackparams)
        uniform sampler2D tex2;
        uniform vec3 tapparams;
        uniform vec2 contrastparams;
        uniform vec4 offsetscale;
        uniform float prefilterdepth;
        @(? (! $derivnormal) [
            uniform mat3 normalmatrix;
        ])
        @(? $lineardepth [
            #define depthtc gl_FragCoord.xy
        ] [
            #define depthtc texcoord0
        ])
        uniform vec3 gdepthpackparams;
        varying vec2 texcoord0, texcoord1;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            @(if (&& $derivnormal [= $aodepthformat 1]) [result [
                #define gfetch gnormfetch
                @(gdepthunpack depth tex1 texcoord0 [
                    vec2 tapscale = tapparams.xy/depth;
                ] [
                    float w = depth*gdepthscale.y + gdepthscale.z;
                    depth = gdepthscale.x/w;
                    vec2 tapscale = tapparams.xy*w;
                ])
            ]] [result [
                #define gfetch gdepthfetch
                @(gdepthunpack depth tex0 depthtc [
                    vec2 tapscale = tapparams.xy/depth;
                ] [
                    float w = depth*gdepthscale.y + gdepthscale.z;
                    depth = gdepthscale.x/w;
                    vec2 tapscale = tapparams.xy*w;
                ] $lineardepth (? $lineardepth (! $aodepthformat) (= $gdepthformat 1)) packdepth)
            ]])
            #undef gfetch
            vec2 dpos = depthtc*offsetscale.xy + offsetscale.zw, pos = depth*dpos;
            @(if $derivnormal [result [
                vec2 ddepth = vec2(dFdx(depth), dFdy(depth)); 
                vec3 normal;
                normal.xy = (depth+ddepth.yx)*offsetscale.yx;
                normal.z = normal.x*normal.y;
                normal.xy *= -ddepth;
                normal.z -= dot(dpos, normal.xy);
                normal = normalize(normal);
            ]] [result [
                vec3 normal = gnormfetch(tex1, texcoord0).rgb*2.0 - 1.0;
                normal = normalmatrix * normal;
            ]])
            vec2 noise = texture2D(tex2, texcoord1).rg*2.0-1.0;
            float obscure = 0.0;
            #define gfetch gdepthfetch
            @(loopconcat i $maxaotaps [result [
                vec2 offset@[i] = reflect(vec2(@(at $aotapoffsets $i)), noise);
                offset@[i] = depthtc + tapscale * offset@[i];
                @(gdepthunpack [depth@[i]] tex0 [offset@[i].xy] [] [] $lineardepth (&& $lineardepth (! $aodepthformat)))
                vec3 v@[i] = vec3(depth@[i]*(offset@[i].xy*offsetscale.xy + offsetscale.zw) - pos, depth@[i] - depth);
                float dist2@[i] = dot(v@[i], v@[i]);
                obscure += step(dist2@[i], tapparams.z) * max(0.0, dot(v@[i], normal) + depth*1.0e-2) / (dist2@[i] + 1.0e-5);
            ]])
            #undef gfetch
            obscure = pow(clamp(1.0 - contrastparams.x*obscure, 0.0, 1.0), contrastparams.y);
            @(if $derivnormal [result [
                vec2 weights = step(abs(ddepth), vec2(prefilterdepth)) * (2.0*fract((gl_FragCoord.xy - 0.5)*0.5) - 0.5);
            ]] [result [
                vec2 weights = step(fwidth(depth), prefilterdepth) * (2.0*fract((gl_FragCoord.xy - 0.5)*0.5) - 0.5);
            ]])
            obscure -= dFdx(obscure) * weights.x;
            obscure -= dFdy(obscure) * weights.y;
            @(if $packeddepth [
                if $aodepthformat [result [
                    fragcolor.rg = vec2(obscure, depth);
                ]] [result [
                    @(if (&& (! $lineardepth) (!= $gdepthformat 1)) [gpackdepth packdepth depth])
                    fragcolor = vec4(packdepth, obscure);
                ]]
            ] [result [
                fragcolor = vec4(obscure, 0.0, 0.0, 1.0);
            ]])
        }
    ]
]

ambientobscuranceshader = [
    ambientobscurancevariantshader (format "ambientobscurance%1%2" $arg1 $arg2) $arg1 $arg2
]

shader 0 "linearizedepth" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    @(gfetchdefs tex0)
    uniform vec3 gdepthpackparams;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(if (! $aodepthformat) [
            if (= $gdepthformat 1) [result [
                fragcolor = gfetch(tex0, texcoord0);
            ]] [result [
                @(gdepthunpack depth tex0 texcoord0)
                @(gpackdepth packdepth depth)
                fragcolor = vec4(packdepth, 1.0);
            ]]    
        ] [result [
            @(gdepthunpack depth tex0 texcoord0)
            fragcolor.r = depth;
        ]])
    }
] 

bilateralvariantshader = [
    reduced = (>= (strstr $arg2 "r") 0)
    linear = (>= (strstr $arg2 "l") 0)
    packed = (>= (strstr $arg2 "p") 0)
    upscaled = (>= (strstr $arg2 "u") 0)
    numtaps = $arg3
    filterdir = $arg4
    shader 0 $arg1 [
        attribute vec4 vvertex;
        @(? $reduced [attribute vec2 vtexcoord0; varying vec2 texcoord0;])
        @(? $upscaled [attribute vec2 vtexcoord1; varying vec2 texcoord1;])
        void main(void)
        {
            gl_Position = vvertex;
            @(? $reduced [texcoord0 = vtexcoord0;])
            @(? $upscaled [texcoord1 = vtexcoord1.xy;])
        }
    ] [
        @(gfetchdefs tex1 (&& $msaasamples [! $linear]))
        uniform sampler2DRect tex0;
        uniform vec3 bilateralparams;
        uniform vec3 gdepthpackparams;
        @(? $reduced [varying vec2 texcoord0;])
        @(? $upscaled [varying vec2 texcoord1;])
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            #define tc @(? $upscaled [texcoord1] [gl_FragCoord.xy])
            #define depthtc @(? $reduced [texcoord0] [gl_FragCoord.xy])
            #define tapoffset(i) @(? (=s $filterdir "x") [vec2(i, 0.0)] [vec2(0.0, i)])
            #define depthoffset(i) tapoffset(@(? $reduced [i*bilateralparams.z] [i]))
            @(cond [$packed] [
                if $aodepthformat [result [
                    vec2 vals = texture2DRect(tex0, tc).rg;
                    #define color vals.x
                    @(if $upscaled [gdepthunpack depth tex1 depthtc] [result [
                        #define depth vals.y
                    ]])
                ]] [result [
                    vec4 vals = texture2DRect(tex0, tc);
                    #define color vals.a
                    @(if $upscaled [gdepthunpack depth tex1 depthtc] [result [
                        float depth = dot(vals.rgb, gdepthunpackparams);
                    ]])                 
                ]]
            ] [$linear] [result [
                float color = texture2DRect(tex0, tc).r;
                @(if $aodepthformat [result [
                    float depth = texture2DRect(tex1, depthtc).r;
                ]] [result [
                    float depth = dot(texture2DRect(tex1, depthtc).rgb, gdepthunpackparams);
                ]])
            ]] [result [
                float color = texture2DRect(tex0, tc).r;
                @(gdepthunpack depth tex1 depthtc)
            ]])
            float weights = 1.0;
            @(loopconcat i (* 2 $numtaps) [
                curtap = (- $i $numtaps)
                if (>= $curtap 0) [curtap = (+ $curtap 1)]
                curtapoffset = (*f $curtap 2)
                result [
                    @(cond [$packed] [
                        if $aodepthformat [result [
                            vec2 vals@[i] = texture2DRect(tex0, tc + tapoffset(@curtapoffset)).rg;
                            #define color@[i] vals@[i].x
                            #define depth@[i] vals@[i].y
                        ]] [result [
                            vec4 vals@[i] = texture2DRect(tex0, tc + tapoffset(@curtapoffset));
                            #define color@[i] vals@[i].a
                            float depth@[i] = dot(vals@[i].rgb, gdepthunpackparams);                 
                        ]]
                    ] [$linear] [
                        if $reduced [result [
                            float color@[i] = texture2DRect(tex0, tc + tapoffset(@curtapoffset)).r;
                            @(if $aodepthformat [result [
                                float depth@[i] = texture2DRect(tex1, depthtc + depthoffset(@curtapoffset)).r;
                            ]] [result [
                                float depth@[i] = dot(texture2DRect(tex1, depthtc + depthoffset(@curtapoffset)).rgb, gdepthunpackparams);
                            ]])
                        ]] [result [
                            vec2 tc@[i] = tc + tapoffset(@curtapoffset);
                            float color@[i] = texture2DRect(tex0, tc@[i]).r;
                            @(if $aodepthformat [result [
                                float depth@[i] = texture2DRect(tex1, tc@[i]).r;
                            ]] [result [
                                float depth@[i] = dot(texture2DRect(tex1, tc@[i]).rgb, gdepthunpackparams);
                            ]])
                        ]]
                    ] [
                        if $reduced [result [
                            float color@[i] = texture2DRect(tex0, tc + tapoffset(@curtapoffset)).r;
                            @(gdepthunpack [depth@[i]] tex1 [depthtc + depthoffset(@curtapoffset)])
                        ]] [result [
                            vec2 tc@[i] = tc + tapoffset(@curtapoffset);
                            float color@[i] = texture2DRect(tex0, tc@[i]).r;
                            @(gdepthunpack [depth@[i]] tex1 [tc@[i]])
                        ]]
                    ])
                    depth@[i] -= depth;
                    float weight@[i] = exp(@(-f 0 (* $curtap $curtap))*bilateralparams.x - depth@[i]*depth@[i]*bilateralparams.y); 
                    weights += weight@[i];
                    color += weight@[i] * color@[i];
                ]
            ])
            @(if (&& (=s $filterdir "x") $packed) [
                if $aodepthformat [result [
                    fragcolor.rg = vec2(color / weights, depth);
                ]] [result [
                    @(if $upscaled [gpackdepth packdepth depth] [result [
                        #define packdepth vals.rgb
                    ]])
                    fragcolor = vec4(packdepth, color / weights);
                ]]
            ] [result [
                fragcolor = vec4(color / weights, 0.0, 0.0, 1.0);
            ]])
        }
    ]
]

bilateralshader = [
    bilateralvariantshader (format "bilateralx%1%2" $arg1 $arg2) $arg1 $arg2 x
    bilateralvariantshader (format "bilateraly%1%2" $arg1 $arg2) $arg1 $arg2 y
]

////////////////////////////////////////////////
//
// separable blur with up to 7 taps
//
////////////////////////////////////////////////

blurshader = [
    shader 0 $arg1 [
        attribute vec4 vvertex;
        attribute vec2 vtexcoord0;
        uniform float offsets[8];
        varying vec2 texcoord0, texcoord1, texcoord2;
        @(loopconcat i (min (- $arg2 1) 2) [result [
            varying vec2 texcoord@(+ (* $i 2) 3), texcoord@(+ (* $i 2) 4);
        ]])
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0; 
            vec2 tc1 = vtexcoord0.xy, tc2 = vtexcoord0; 
            tc1.@arg3 += offsets[1];
            tc2.@arg3 -= offsets[1];
            texcoord1 = tc1;
            texcoord2 = tc2;
            @(loopconcat i (min (- $arg2 1) 2) [result [
                tc1.@arg3 = vtexcoord0.@arg3 + offsets[@@(+ $i 2)];
                tc2.@arg3 = vtexcoord0.@arg3 - offsets[@@(+ $i 2)];
                texcoord@(+ (* $i 2) 3) = tc1;
                texcoord@(+ (* $i 2) 4) = tc2;
            ]])
        } 
    ] [
        uniform float weights[8];
        uniform float offsets[8];
        uniform sampler@[arg4] tex0;
        varying vec2 texcoord0, texcoord1, texcoord2;
        @(loopconcat i (min (- $arg2 1) 2) [result [
            varying vec2 texcoord@(+ (* $i 2) 3), texcoord@(+ (* $i 2) 4);
        ]])
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            #define texval(coords) texture@[arg4](tex0, (coords))
            vec4 val = texval(texcoord0) * weights[0];
            @(loopconcat i $arg2 [
                if (< $i 3) [result [
                    val += weights[@@(+ $i 1)] * (texval(texcoord@(+ (* $i 2) 1)) + texval(texcoord@(+ (* $i 2) 2)));
                ]] [result [
                    val += weights[@@(+ $i 1)] * 
                    @(if (=s $arg3 "x") [result [
                        (texval(vec2(texcoord0.x + offsets[@@(+ $i 1)], texcoord0.y)) + texval(vec2(texcoord0.x - offsets[@@(+ $i 1)], texcoord0.y)));
                    ]] [result [
                        (texval(vec2(texcoord0.x, texcoord0.y + offsets[@@(+ $i 1)])) + texval(vec2(texcoord0.x, texcoord0.y - offsets[@@(+ $i 1)])));
                    ]])
                ]]
            ])
            fragcolor = val;
        }
    ]
]

loop i 7 [
    blurshader (format "blurx%1" (+ $i 1)) (+ $i 1) x 2D
    blurshader (format "blury%1" (+ $i 1)) (+ $i 1) y 2D
    if (> $i 0) [
        altshader (format "blurx%1" (+ $i 1)) (format "blurx%1" $i)
        altshader (format "blury%1" (+ $i 1)) (format "blury%1" $i)
    ]
    blurshader (format "blurx%1rect" (+ $i 1)) (+ $i 1) x 2DRect
    blurshader (format "blury%1rect" (+ $i 1)) (+ $i 1) y 2DRect
    if (> $i 0) [
        altshader (format "blurx%1rect" (+ $i 1)) (format "blurx%1rect" $i)
        altshader (format "blury%1rect" (+ $i 1)) (format "blury%1rect" $i)
    ]
]

////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////

fsvs = [result [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    @arg2
    void main(void)
    {
        gl_Position = vvertex;   // woohoo, no mvp :) 
        texcoord0 = vtexcoord0; 
        @arg1
    }
]]

fsps = [result [
    uniform sampler2DRect tex0; 
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    @arg2
    void main(void)
    {
        vec4 sample = texture2DRect(tex0, texcoord0);
        @arg1
    }
]]

fsvs4 = [
    fsvs [ 
        texcoord1 = vtexcoord0 + vec2(-1.5, -1.5);
        texcoord2 = vtexcoord0 + vec2( 1.5, -1.5);
        texcoord3 = vtexcoord0 + vec2(-1.5,  1.5);
        texcoord4 = vtexcoord0 + vec2( 1.5,  1.5);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

fsps4 = [
    fsps [
        vec4 s00 = texture2DRect(tex0, texcoord1);
        vec4 s02 = texture2DRect(tex0, texcoord2);
        vec4 s20 = texture2DRect(tex0, texcoord3);
        vec4 s22 = texture2DRect(tex0, texcoord4);
        @arg1
    ] [
        varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
    ]
]

// some simple ones that just do an effect on the RGB value...

lazyshader 0 "invert" (fsvs) (fsps [fragcolor = 1.0 - sample;])
lazyshader 0 "gbr"    (fsvs) (fsps [fragcolor = sample.yzxw;])
lazyshader 0 "bw"     (fsvs) (fsps [fragcolor = vec4(dot(sample.xyz, vec3(0.333)));])

// sobel

lazyshader 0 "sobel" (fsvs4) (fsps4 [
    vec4 t = s00 + s20 - s02 - s22;
    vec4 u = s00 + s02 - s20 - s22;
    fragcolor = sample + t*t + u*u;
])

// rotoscope

lazyshader 0 "rotoscope" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    uniform vec4 params;
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    void main(void)
    {
        gl_Position = vvertex;
        t11 = vtexcoord0;
        t00 = vec2(-1.0, -1.0)*params.x + vtexcoord0;
        t12 = vec2( 0.0,  1.0)*params.x + vtexcoord0;
        t01 = vec2(-1.0,  0.0)*params.x + vtexcoord0;
        t20 = vec2( 1.0, -1.0)*params.x + vtexcoord0;
        t02 = vec2(-1.0,  1.0)*params.x + vtexcoord0;
        t21 = vec2( 1.0,  0.0)*params.x + vtexcoord0;
        t10 = vec2( 0.0, -1.0)*params.x + vtexcoord0;
        t22 = vec2( 1.0,  1.0)*params.x + vtexcoord0;
    }
] [
    uniform sampler2DRect tex0; 
    varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec4 c00 = texture2DRect(tex0, t00);
        vec4 c01 = texture2DRect(tex0, t01);
        vec4 c02 = texture2DRect(tex0, t02);
        vec4 c10 = texture2DRect(tex0, t10);
        vec4 c11 = texture2DRect(tex0, t11);
        vec4 c12 = texture2DRect(tex0, t12);
        vec4 c20 = texture2DRect(tex0, t20);
        vec4 c21 = texture2DRect(tex0, t21);
        vec4 c22 = texture2DRect(tex0, t22);

        vec4 diag1 = c00 - c22;
        vec4 diag2 = c02 - c20;
        vec4 xedge = (c01 - c21)*2.0 + diag1 + diag2;
        vec4 yedge = (c10 - c12)*2.0 + diag1 - diag2;
        xedge *= xedge;
        yedge *= yedge;

        vec4 xyedge = xedge + yedge;
        float sobel = step(max(xyedge.x, max(xyedge.y, xyedge.z)), 0.1);

        float hue = dot(c11.xyz, vec3(1.0));
        c11 /= hue;
        vec3 cc = step(vec3(0.2, 0.8, 1.5), vec3(hue));
        c11 *= dot(cc, vec3(0.5, 0.5, 1.5)); 
        
        fragcolor = c11 * max(cc.z, sobel);
        
    }
]

blur3shader = [
    lazyshader 0 $arg1 [ 
        attribute vec4 vvertex;
        attribute vec2 vtexcoord0;
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0 + vec2(@(if $arg2 -0.5 0.0), @(if $arg3 -0.5 0.0));
            texcoord1 = vtexcoord0 + vec2(@(if $arg2  0.5 0.0), @(if $arg3  0.5 0.0));
        }
    ] [
        uniform sampler2DRect tex0; 
        varying vec2 texcoord0, texcoord1;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            fragcolor = 0.5*(texture2DRect(tex0, texcoord0) + texture2DRect(tex0, texcoord1));
        }
    ]
]
blur3shader hblur3 1 0
blur3shader vblur3 0 1

blur5shader = [
    lazyshader 0 $arg1 [ 
        attribute vec4 vvertex;
        attribute vec2 vtexcoord0;
        varying vec2 texcoord0, texcoord1, texcoord2;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0;
            texcoord1 = vtexcoord0 + vec2(@(if $arg2 -1.333 0.0), @(if $arg3 -1.333 0.0));
            texcoord2 = vtexcoord0 + vec2(@(if $arg2  1.333 0.0), @(if $arg3  1.333 0.0));
        }
    ] [
        uniform sampler2DRect tex0; 
        varying vec2 texcoord0, texcoord1, texcoord2;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            fragcolor = 0.4*texture2DRect(tex0, texcoord0) + 0.3*(texture2DRect(tex0, texcoord1) + texture2DRect(tex0, texcoord2));
        }
    ]
]
blur5shader hblur5 1 0
blur5shader vblur5 0 1

rotoscope = [
    clearpostfx
    if (>= $numargs 1) [addpostfx rotoscope 0 0 0 $arg1]
    if (>= $numargs 2) [
        if (= $arg2 1) [addpostfx hblur3; addpostfx vblur3]
        if (= $arg2 2) [addpostfx hblur5; addpostfx vblur5]
    ]
]

////////////////////////////////////////////////
//
// miscellaneous effect shaders: 
//
////////////////////////////////////////////////

// wobbles the vertices of an explosion sphere
// and generates all texcoords 
// and blends the edge color
// and modulates the texture
explosionshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        attribute vec4 vvertex, vcolor;
        uniform mat4 explosionmatrix;
        uniform vec3 center;
        uniform vec4 animstate;
        uniform float side;
        @(? (>= (strstr $arg1 "3d") 0) [
            attribute vec2 vtexcoord0;
            varying vec2 texcoord2;
            uniform vec4 texgenS, texgenT;
        ])
        @(? (>= (strstr $arg1 "soft") 0) [
            uniform vec2 lineardepthscale;
            uniform vec3 softparams;
            varying float softdepth;
        ]) 
        varying vec4 color;
        varying vec2 texcoord0, texcoord1;
        void main(void)
        {
            vec4 wobble = vec4(vvertex.xyz*(1.0 + 0.5*abs(fract(dot(vvertex.xyz, center) + animstate.w*2.0) - 0.5)), vvertex.w);
            wobble.z *= side;
            gl_Position = explosionmatrix * wobble;
            @(? (>= (strstr $arg1 "soft") 0) [
                softdepth = softparams.y + dot(lineardepthscale, gl_Position.zw)*softparams.x;
            ])

            color = vcolor;
        
            @(? (>= (strstr $arg1 "3d") 0) [
                texcoord0 = vtexcoord0; 
                vec2 texgen = vec2(dot(texgenS, vvertex), dot(texgenT, vvertex)); 
                texcoord1 = texgen;
                texcoord2 = texgen - animstate.w*0.5;
            ] [
                //blow up the tex coords
                float dtc = 1.768 - animstate.x*1.414; // -2, 2.5; -> -2*sqrt(0.5), 2.5*sqrt(0.5);
                dtc *= dtc;
                texcoord0 = animstate.w*0.4 + dtc*vvertex.xy;
                texcoord1 = vvertex.xy*0.5 + 0.5; //using wobble makes it look too spherical at a distance
            ])
        } 
    ] [ 
        @(? (>= (strstr $arg1 "3d") 0) [
            varying vec2 texcoord2;
        ])
        @(if (>= (strstr $arg1 "soft") 0) [result [
            @(gfetchdefs tex2)
            uniform vec3 softparams;
            varying float softdepth;
        ]])
        varying vec4 color;
        varying vec2 texcoord0, texcoord1;
        uniform sampler2D tex0, tex1;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            vec2 dtc = texcoord0 + texture2D(tex0, @(? (>= (strstr $arg1 "3d") 0) "texcoord2" "texcoord1")).xy*0.1; // use color texture as noise to distort texcoords
            vec4 diffuse = texture2D(tex0, dtc);
            float blend = texture2D(tex1, texcoord1).r; // get blend factors from modulation texture 
            diffuse *= blend*4.0; // dup alpha into RGB channels + intensify and over saturate
            diffuse.b += 0.5 - blend*0.5; // blue tint 

            @(if (>= (strstr $arg1 "soft") 0) [result [
                fragcolor.rgb = diffuse.rgb * color.rgb;

                @(gdepthunpack depth tex2 gl_FragCoord.xy)
                fragcolor.a = diffuse.a * max(clamp(depth*softparams.x - softdepth, 0.0, 1.0) * color.a, softparams.z);
            ]] [result [
                fragcolor = diffuse * color;
            ]])
        }
    ]
]

explosionshader "explosion2d"
explosionshader "explosion2dsoft"
explosionshader "explosion3d"
explosionshader "explosion3dsoft"

shader 0 "particlenotexture" [
    #pragma CUBE2_fog
    attribute vec4 vvertex, vcolor;
    uniform mat4 camprojmatrix;
    uniform vec4 colorscale;
    varying vec4 color;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vcolor * colorscale;
    } 
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

particleshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        attribute vec4 vvertex, vcolor;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        uniform vec4 colorscale;
        varying vec4 color;
        varying vec3 surface;
        varying vec2 texcoord0;
        @(if (>= (strstr $arg1 "soft") 0) [result [
            uniform vec2 lineardepthscale;
            uniform vec3 softparams;
            varying float softdepth;
        ]])
        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;
            texcoord0 = vtexcoord0; 
            color = vcolor * colorscale; 

            @(if (>= (strstr $arg1 "soft") 0) [result [
                vec2 offset = vtexcoord0.xy*2.82842712474619 - 1.4142135623731;
                surface = vec3(offset, softparams.y + dot(lineardepthscale, gl_Position.zw)*softparams.x);
            ]])
        }
    ] [
        @(if (>= (strstr $arg1 "soft") 0) [result [
            @(gfetchdefs tex2)
            uniform vec3 softparams;
            varying float softdepth;
        ]])
        uniform sampler2D tex0;
        varying vec4 color;
        varying vec3 surface;
        varying vec2 texcoord0;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            #pragma CUBE2_variantoverride vec4 diffuse = texture2D(tex0, texcoord0).rrrg;
            vec4 diffuse = texture2D(tex0, texcoord0);

            @(if (>= (strstr $arg1 "soft") 0) [result [
                @(gdepthunpack depth tex2 gl_FragCoord.xy)
                diffuse.a *= clamp(depth*softparams.x - dot(surface.xy, surface.xy) - surface.z, 0.0, 1.0);
            ]])

            fragcolor = diffuse * color;
        }
    ]     
]

loop i 2 [
    particleshader (concatword "particle" (at ["" "soft"] $i))
]

shader 0 "blendbrush" [
    attribute vec4 vvertex, vcolor;
    uniform mat4 camprojmatrix;
    uniform vec4 texgenS, texgenT;
    uniform float ldrscale;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vec4(ldrscale * vcolor.rgb, vcolor.a);
        texcoord0 = vec2(dot(texgenS, vvertex), dot(texgenT, vvertex));
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = texture2D(tex0, texcoord0).r * color;
    }
]

shader 0 "fogoverlay" [
    attribute vec4 vvertex, vcolor;
    varying vec4 color;
    void main(void)
    {
        gl_Position = vvertex;
        color = vcolor;
    }
] [
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

lazyshader 0 "moviergb" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = texture2DRect(tex0, texcoord0);
    }
]

lazyshader 0 "movieyuv" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 sample = texture2DRect(tex0, texcoord0).rgb;
        fragcolor = vec4(dot(sample, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                         dot(sample, vec3(-0.148224, -0.290992, 0.439216)) + 0.501961,
                         dot(sample, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                         0.0);
    }
]

lazyshader 0 "moviey" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0 + vec2(-1.5, 0.0);
        texcoord1 = vtexcoord0 + vec2(-0.5, 0.0);
        texcoord2 = vtexcoord0 + vec2( 0.5, 0.0);
        texcoord3 = vtexcoord0 + vec2( 1.5, 0.0);
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, texcoord0).rgb;
        vec3 sample2 = texture2DRect(tex0, texcoord1).rgb;
        vec3 sample3 = texture2DRect(tex0, texcoord2).rgb;
        vec3 sample4 = texture2DRect(tex0, texcoord3).rgb;
        fragcolor = vec4(dot(sample3, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                         dot(sample2, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                         dot(sample1, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                         dot(sample4, vec3(0.256788, 0.504125, 0.097905)) + 0.062745);
    }
]

lazyshader 0 "movieu" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0 + vec2(-3.0, 0.0);
        texcoord1 = vtexcoord0 + vec2(-1.0, 0.0);
        texcoord2 = vtexcoord0 + vec2( 1.0, 0.0);
        texcoord3 = vtexcoord0 + vec2( 3.0, 0.0);
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, texcoord0).rgb;
        vec3 sample2 = texture2DRect(tex0, texcoord1).rgb;
        vec3 sample3 = texture2DRect(tex0, texcoord2).rgb;
        vec3 sample4 = texture2DRect(tex0, texcoord3).rgb;
        fragcolor = vec4(dot(sample3, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                         dot(sample2, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                         dot(sample1, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                         dot(sample4, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961);
    }
]

lazyshader 0 "moviev" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0 + vec2(-3.0, 0.0);
        texcoord1 = vtexcoord0 + vec2(-1.0, 0.0);
        texcoord2 = vtexcoord0 + vec2( 1.0, 0.0);
        texcoord3 = vtexcoord0 + vec2( 3.0, 0.0);
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, texcoord0).rgb;
        vec3 sample2 = texture2DRect(tex0, texcoord1).rgb;
        vec3 sample3 = texture2DRect(tex0, texcoord2).rgb;
        vec3 sample4 = texture2DRect(tex0, texcoord3).rgb;
        fragcolor = vec4(dot(sample3, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                         dot(sample2, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                         dot(sample1, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                         dot(sample4, vec3(0.439216, -0.367788, -0.071427)) + 0.501961);
    }
]

///////////////////////////////////////////////////
//
// reflective/refractive water shaders:
//
///////////////////////////////////////////////////

shader 0 "refractmask" [
    attribute vec4 vvertex;
    uniform mat4 camprojmatrix;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
    }
] [
    @(gfetchdefs tex0)
    uniform vec3 gdepthpackparams;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(if (= $gdepthformat 1) [result [
            vec3 packdepth = gfetch(tex0, gl_FragCoord.xy).rgb;
            float depth = dot(packdepth, gdepthunpackparams);
        ]] [result [
            @(gdepthunpack depth tex0 gl_FragCoord.xy) 
            @(gpackdepth packdepth depth)
        ]])
        fragcolor = vec4(packdepth, 0.0);
    }
]

lazyshader 0 "waterminimap" [
    attribute vec4 vvertex;
    uniform mat4 camprojmatrix;
    @(ginterpvert)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        @(gdepthpackvert)
    }
] [
    uniform vec3 watercolor;
    @(ginterpfrag)

    void main(void)
    {
        gcolor = vec4(0.0, 0.0, 0.0, 0.0);
        gnormal = vec4(0.5, 0.5, 1.0, 0.0);
        gglow = vec4(watercolor, 1.0);
        @(gdepthpackfrag)
    }
]

watershader = [
  lazyshader 0 $arg1 [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform vec3 camera;
    varying vec2 texcoord0;
    varying vec3 surface;
    @(? (>= (strstr $arg1 "reflect") 0) [
        uniform mat4 raymatrix;
        varying vec3 esurface;
    ])
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        surface = vvertex.xyz;
        @(? (>= (strstr $arg1 "reflect") 0) [
            esurface = (raymatrix * vvertex).xyz;
        ])
        texcoord0 = vtexcoord0 * 0.1;
        @(gdepthpackvert 1)
    }
  ] [
    @(gfetchdefs [tex7 tex8 tex9])
    uniform float millis;
    uniform vec3 camera;
    uniform mat4 linearworldmatrix;
    varying vec2 texcoord0;
    varying vec3 surface;
    uniform sampler2D tex0, tex1;
    uniform vec4 viewsize;
    uniform vec3 watercolor, waterdeepcolor, waterdeepfade;
    uniform float waterfog, waterspec;
    uniform vec4 waterreflect, waterrefract;
    uniform float refractdepth;
    @(? (>= (strstr $arg1 "caustics") 0) [
        uniform vec3 causticsS, causticsT;
        uniform vec3 causticsblend;
        uniform sampler2D tex2, tex3;
    ])
    @(? (>= (strstr $arg1 "env") 0) [
        uniform samplerCube tex4;
    ])
    @(? (>= (strstr $arg1 "reflect") 0) [
        uniform mat4 raymatrix;
        varying vec3 esurface;
    ])
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 camdir = camera - surface, camvec = normalize(camdir);
        vec3 bump = texture2D(tex0, texcoord0 + millis*0.05 + 0.23).rgb;
        vec3 bump2 = texture2D(tex0, texcoord0 - millis*0.05 + 0.71).rgb;
        vec3 bump3 = texture2D(tex0, texcoord0 + millis*vec2(0.05, -0.05) + 0.49).rgb;
        vec3 bump4 = texture2D(tex0, texcoord0 + millis*vec2(-0.05, 0.05) + 0.67).rgb;
        bump = normalize(bump + bump2 + bump3 + bump4 - 2.0);
        vec2 rtc = bump.xy * waterrefract.w;

        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterrefract.xyz;
        float rdepth = dot(gfetch(tex7, rtc).rgb, gdepthunpackparams);
        vec3 rpos = (linearworldmatrix * vec4(rdepth*rtc, rdepth, 1.0)).xyz;

        @(if (>= (strstr $arg1 "under") 0) [result [
            float above = rpos.z - surface.z; 
            float alpha = clamp(above, 0.0, 1.0);
        ]] [result [
            vec3 rdir = rpos.xyz - camera;
            float raydepth = length(rdir)*(1.0 + camdir.z/rdir.z);
            float deep = surface.z - rpos.z;
            float alpha = clamp(deep*0.5, 0.0, 1.0);

            @(? (>= (strstr $arg1 "caustics") 0) [
                vec2 ctc = vec2(dot(causticsS, rpos.xyz), dot(causticsT, rpos.xyz));
                float caustics = causticsblend.x*texture2D(tex2, ctc).r + causticsblend.y*texture2D(tex3, ctc).r + causticsblend.z;
                rcolor *= caustics;
            ])

            rcolor = mix(rcolor, watercolor, clamp(raydepth * waterfog, 0.0, 1.0));
            rcolor = mix(rcolor, waterdeepcolor, clamp(deep * waterdeepfade, 0.0, 1.0));
        ]])

        vec3 reflectdir = -reflect(camvec, bump);
        reflectdir.z = abs(reflectdir.z);
        @(if (>= (strstr $arg1 "reflect") 0) [result [
            reflectdir.z += 0.125;
            vec3 edir = (raymatrix * vec4(waterreflect.w*reflectdir, 0.0)).xyz;
            vec3 epos = esurface + edir;
            @(loopconcat i 4 [result [
                @(gdepthunpackproj [edepth@[i]] tex9 epos [
                    if(edepth@[i] < epos.z || edepth@[i] > esurface.z) epos += edir;
                ] [
                    edepth@[i] = edepth@[i]*gdepthscale.y + gdepthscale.z;
                    if(gdepthscale.x < epos.z*edepth@[i] || gdepthscale.x > esurface.z*edepth@[i]) epos += edir;
                ])
            ]])
            vec2 etc = epos.xy/epos.z;
            vec3 reflect = gfetchclamp(tex8, etc).rgb * waterreflect.xyz;
            float edgefade = clamp(4.0*(0.5 - max(abs(etc.x*viewsize.z - 0.5)*0.75 + 0.25/4.0, abs(etc.y*viewsize.w - 0.5))), 0.0, 1.0);
            float fresnel = 0.25 + 0.75*pow(clamp(1.0 - dot(camvec, bump), 0.0, 1.0), 4.0);
            rcolor = mix(rcolor, reflect, fresnel*edgefade);
        ]] [if (>= (strstr $arg1 "env") 0) [result [
            vec3 reflect = textureCube(tex4, reflectdir).rgb*0.5;
            float fresnel = 0.5*pow(clamp(1.0 - dot(camvec, bump), 0.0, 1.0), 4.0);
            rcolor = mix(rcolor, reflect, fresnel);
        ]]])

        gcolor = vec4(0.0, 0.0, 0.0, waterspec*alpha);
        gnormal = vec4(bump*0.5+0.5, 0.0);
        gglow = vec4(rcolor*alpha, alpha);
        @(gdepthpackfrag)
    }
  ]  
]

watershader "water"
watershader "watercaustics"
watershader "waterenv"
watershader "waterenvcaustics"
watershader "waterreflect"
watershader "waterreflectcaustics"
watershader "underwater"

causticshader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        void main(void)
        {
            gl_Position = vvertex;
        }
    ] [
        @(gfetchdefs tex9)
        uniform mat4 causticsmatrix;
        uniform vec3 causticsblend;
        uniform sampler2D tex0, tex1;
        uniform vec4 waterdeepfade;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            @(gdepthunpack depth tex9 gl_FragCoord.xy [
                vec3 ctc = (causticsmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).xyz;
            ] [
                vec4 ctc = causticsmatrix * vec4(gl_FragCoord.xy, depth, 1.0);
                ctc.xyz /= ctc.w;
            ])
            float caustics = causticsblend.x*texture2D(tex0, ctc.xy).r + causticsblend.y*texture2D(tex1, ctc.xy).r + causticsblend.z;
            caustics *= clamp(ctc.z, 0.0, 1.0) * clamp(1.0 - ctc.z*waterdeepfade.w, 0.0, 1.0);
            fragcolor.rgb = vec3(0.5 + caustics);
        }
    ]
]
causticshader caustics

waterfogshader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        void main(void)
        {
            gl_Position = vvertex;
        }
    ] [
        @(gfetchdefs tex9)
        uniform mat4 waterfogmatrix;
        uniform vec3 fogcolor, fogparams;
        uniform float waterdeep;
        uniform vec3 waterdeepcolor, waterdeepfade;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            @(gdepthunpack depth tex9 gl_FragCoord.xy [
                float fogbelow = (waterfogmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).z;
                #define fogcoord depth 
            ] [
                vec3 pos = (waterfogmatrix * vec4(gl_FragCoord.xy, depth, 1.0)).xzw;
                pos.xy /= pos.z;
                #define fogbelow pos.y
                #define fogcoord pos.x
            ])
            float foglerp = clamp((fogparams.x - fogcoord) * fogparams.z, 0.0, 1.0);
            foglerp *= clamp(2.0*fogbelow + 0.5, 0.0, 1.0);
            vec3 fogcolor = mix(fogcolor, waterdeepcolor, clamp(fogbelow*waterdeepfade, 0.0, 1.0));
            fragcolor.rgb = fogcolor;
            fragcolor.a = foglerp;
        }
    ]
]
waterfogshader waterfog

lazyshader 0 "lava" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert)
    }
] [
    uniform sampler2D tex0, tex1;
    uniform float lavaglow, lavaspec;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag)

    void main(void)
    {
        vec3 diffuse = texture2D(tex0, texcoord0).rgb;
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0-1.0;
        vec3 bumpw = world * bump;
        gcolor = vec4(diffuse, lavaspec);
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(diffuse*lavaglow, 1.0);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "waterfallenv" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        camdir = camera.xyz - vvertex.xyz;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform samplerCube tex3;
    uniform sampler2D tex0, tex1;
    uniform vec3 waterfallcolor;
    uniform float waterfallspec;
    uniform vec4 waterfallrefract;
    uniform float refractdepth;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 diffuse = texture2D(tex0, texcoord0).rgb;
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * waterfallrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterfallrefract.xyz;

        float invfresnel = dot(camvec, bumpw);
        vec3 env = textureCube(tex3, 2.0*bumpw*invfresnel - camvec).rgb;
        env *= 0.1 + 0.4*pow(clamp(1.0 - invfresnel, 0.0, 1.0), 2.0);

        gcolor = vec4(0.0, 0.0, 0.0, waterfallspec*(1.0 - dot(diffuse, vec3(0.33))));
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(mix(rcolor, waterfallcolor, diffuse) + env, 1.0);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "waterfall" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert 1)
    }
] [ 
    @(gfetchdefs [tex7 tex8])
    uniform sampler2D tex0, tex1;
    uniform vec3 waterfallcolor;
    uniform float waterfallspec;
    uniform vec4 waterfallrefract;
    uniform float refractdepth;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 diffuse = texture2D(tex0, texcoord0).rgb;
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * waterfallrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterfallrefract.xyz;

        gcolor = vec4(0.0, 0.0, 0.0, waterfallspec*(1.0 - dot(diffuse, vec3(0.33))));
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(mix(rcolor, waterfallcolor, diffuse), 1.0);
        @(gdepthpackfrag)
    }
]
altshader waterfallenv waterfall

lazyshader 0 "glassenv" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        camdir = camera.xyz - vvertex.xyz;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert 1)
    }
] [ 
    @(gfetchdefs [tex7 tex8])
    uniform samplerCube tex0;
    uniform sampler2D tex1;
    uniform float glassspec;
    uniform vec4 glassrefract;
    uniform float refractdepth;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * glassrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb;
        rcolor *= glassrefract.xyz;
      
        float invfresnel = dot(camvec, bumpw);
        vec3 env = textureCube(tex0, 2.0*bumpw*invfresnel - camvec).rgb;
        env *= 0.1 + 0.4*pow(clamp(1.0 - invfresnel, 0.0, 1.0), 2.0);
  
        gcolor = vec4(0.0, 0.0, 0.0, glassspec);
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(rcolor + env, 1.0);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "glass" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform sampler2D tex1;
    uniform float glassspec;
    uniform vec4 glassrefract;
    uniform float refractdepth;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = world * bump;

        vec2 rtc = bump.xy * glassrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb;
        rcolor *= glassrefract.xyz;
        
        gcolor = vec4(0.0, 0.0, 0.0, glassspec);
        gnormal = vec4(bumpw*0.5+0.5, 0.0);
        gglow = vec4(rcolor, 1.0); 
        @(gdepthpackfrag)
    }
]
altshader glassenv glass

defershader 0 "grass" [
  loop i 2 [
    variantshader 0 "grass" (? $i 0 -1) [
        attribute vec4 vvertex, vcolor;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        @(ginterpvert)
        varying vec2 texcoord0;
        varying vec4 colorscale;
        @(? $i [uniform vec4 blendmapparams; varying vec2 texcoord1;])
        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;
            colorscale = vcolor;
            texcoord0 = vtexcoord0; 
            @(? $i [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ])
            @(gdepthpackvert)
        }
    ] [
        uniform sampler2D tex0;
        uniform float grasstest;
        @(ginterpfrag)
        varying vec2 texcoord0;
        varying vec4 colorscale;
        @(? $i [uniform sampler2D tex1; varying vec2 texcoord1;])
        void main(void)
        {
            vec4 color = texture2D(tex0, texcoord0) * colorscale;
            @(? $i [
                color.a *= texture2D(tex1, texcoord1).r;
            ])
            if(color.a <= grasstest)
                discard;
            gcolor = vec4(color.rgb, 0.0);
            gnormal = vec4(0.5, 0.5, 1.0, 0.0); 
            gglow = vec4(0.0, 0.0, 0.0, 1.0);
            @(gdepthpackfrag)
        }
    ]
  ]
]

shader 0 "overbrightdecal" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        color = vcolor;
        texcoord0 = vtexcoord0; 
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        #pragma CUBE2_variantoverride vec4 diffuse = texture2D(tex0, texcoord0).rrrg;
        vec4 diffuse = texture2D(tex0, texcoord0);
        fragcolor = mix(color, diffuse, color.a);
    }
]

shader 0 "decal" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 camprojmatrix;
    uniform vec4 colorscale;
    varying vec4 color;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        texcoord0 = vtexcoord0;
        color = vcolor * colorscale;
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        #pragma CUBE2_variantoverride vec4 diffuse = texture2D(tex0, texcoord0).rrrg;
        vec4 diffuse = texture2D(tex0, texcoord0);
        fragcolor = diffuse * color;
    }
]

shader 0 "skybox" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 skymatrix;
    uniform float ldrscale;
    varying vec4 colorscale;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = skymatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    uniform sampler2D tex0;
    varying vec4 colorscale;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = colorscale * texture2D(tex0, texcoord0);
    }
]

shader 0 "skyboxoverbright" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 skymatrix;
    uniform float ldrscale;
    varying vec4 colorscale;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = skymatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    uniform sampler2D tex0;
    uniform vec2 overbrightparams;
    varying vec4 colorscale;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        float lum = dot(vec3(@lumweights), color.rgb);
        float overbright = 1.0 + overbrightparams.x*clamp(lum - overbrightparams.y, 0.0, 1.0);
        color.rgb *= overbright;
        fragcolor = color * colorscale;
    }
]

shader 0 "skyfog" [
    attribute vec4 vvertex, vcolor;
    uniform mat4 skymatrix;
    uniform float ldrscale;
    varying vec4 color;
    void main(void)
    {
        gl_Position = skymatrix * vvertex;
        color = vec4(ldrscale * vcolor.rgb, vcolor.a);
    }
] [
    uniform sampler2D tex0;
    varying vec4 color;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        fragcolor = color;
    }
]

lazyshader 0 "tqaamaskmovement" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    @(gfetchdefs tex0)
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        float mask = gfetch(tex0, texcoord0).a;
        @(? $msaasamples [mask = step(0.75, mask);])
        fragcolor = vec4(mask, 0.0, 0.0, 0.25);
    }
]

lazyshader 0 "tqaaresolve" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    @(gfetchdefs tex2)
    uniform sampler2DRect tex0, tex1;
    uniform mat4 reprojectmatrix;
    uniform vec3 maxvelocity;
    uniform vec4 quincunx;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(gdepthunpack depth tex2 texcoord0 [
            vec4 prevtc = reprojectmatrix * vec4(depth*texcoord0, depth, 1.0);
        ] [
            vec4 prevtc = reprojectmatrix * vec4(texcoord0, depth, 1.0);
        ])
        prevtc.xy /= prevtc.w;
        vec2 vel = prevtc.xy - texcoord0;

        vec4 color = texture2DRect(tex0, texcoord0 + quincunx.xy);
        float vscale = color.a*maxvelocity.x*inversesqrt(dot(vel, vel) + 1e-6);
        vec4 prevcolor = texture2DRect(tex1, texcoord0 + quincunx.zw + vel*vscale);

        float weight = 0.5 - 0.5*color.a;
        weight *= clamp(1.0 - maxvelocity.z*abs(color.a - prevcolor.a), 0.0, 1.0);
        fragcolor = mix(color, prevcolor, weight);
    }
]

lazyshader 0 "tqaaresolvemasked" [
    attribute vec4 vvertex;
    attribute vec2 vtexcoord0;
    varying vec2 texcoord0;
    void main(void)
    {
        gl_Position = vvertex;
        texcoord0 = vtexcoord0; 
    }
] [
    @(gfetchdefs tex2)
    uniform sampler2DRect tex0, tex1, tex3;
    uniform mat4 reprojectmatrix;
    uniform vec3 maxvelocity;
    uniform vec4 quincunx;
    uniform float movemaskscale;
    varying vec2 texcoord0;
    fragdata(0, fragcolor, vec4)
    void main(void)
    {
        @(gdepthunpack depth tex2 texcoord0 [
            vec4 prevtc = reprojectmatrix * vec4(depth*texcoord0, depth, 1.0);
        ] [
            vec4 prevtc = reprojectmatrix * vec4(texcoord0, depth, 1.0);
        ])
        prevtc.xy /= prevtc.w;
        vec2 vel = prevtc.xy - texcoord0;

        float mask = clamp(2.0*texture2DRect(tex3, (texcoord0 + quincunx.xy)*movemaskscale).r, 0.0, 1.0);
        vec4 color = texture2DRect(tex0, texcoord0 + quincunx.xy*(1.0 - mask));
        float vscale = color.a*maxvelocity.x*inversesqrt(dot(vel, vel) + 1e-6);
        vec4 prevcolor = texture2DRect(tex1, texcoord0 + quincunx.zw + vel*vscale);
        float prevmask = clamp(4.0*texture2DRect(tex3, (texcoord0 + quincunx.zw + vel*vscale)*movemaskscale).r, 0.0, 1.0);

        float weight = 0.5 - 0.5*color.a;
        weight *= clamp(1.0 - maxvelocity.z*abs(color.a - prevcolor.a), 0.0, 1.0);
        weight *= 1.0 - max(mask, prevmask);
        fragcolor = mix(color, prevcolor, weight);
    }
]

smaaopt = [ >= (strstr $smaaopts $arg1) 0 ]
smaashaders = [
    smaapreset = $arg1   
    smaaopts = $arg2
    exec "data/smaa.cfg"
]

fxaaopt = [ >= (strstr $fxaaopts $arg1) 0 ]
fxaashaders = [
    fxaapreset = $arg1
    fxaaopts = $arg2
    exec "data/fxaa.cfg"
]

